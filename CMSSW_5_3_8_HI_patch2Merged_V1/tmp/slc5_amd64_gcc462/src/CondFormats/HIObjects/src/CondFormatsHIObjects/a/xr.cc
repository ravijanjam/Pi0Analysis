// Generated at Tue Jan 14 17:28:47 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/gpfs22/home/maguirc/CMSSW_5_3_8_HI_patch2/src/CondFormats/HIObjects/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_287 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_229 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_296 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_286 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_284 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_119 = ::Reflex::TypeBuilder(Reflex::Literal("RPFlatParams"));
  ::Reflex::Type type_175 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_84 = ::Reflex::TypeBuilder(Reflex::Literal("CentralityTable"));
  ::Reflex::Type type_341 = ::Reflex::TypeBuilder(Reflex::Literal("RPFlatParams::EP"));
  ::Reflex::Type type_335 = ::Reflex::TypeBuilder(Reflex::Literal("CentralityTable::CBin"));
  ::Reflex::Type type_334 = ::Reflex::TypeBuilder(Reflex::Literal("CentralityTable::BinValues"));
  ::Reflex::Type type_182 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPFlatParams::EP>"));
  ::Reflex::Type type_217 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPFlatParams::EP>"));
  ::Reflex::Type type_183 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<CentralityTable::CBin>"));
  ::Reflex::Type type_218 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<CentralityTable::CBin>"));
  ::Reflex::Type type_250 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPFlatParams::EP,std::allocator<RPFlatParams::EP> >"));
  ::Reflex::Type type_323 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >"));
  ::Reflex::Type type_251 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CentralityTable::CBin,std::allocator<CentralityTable::CBin> >"));
  ::Reflex::Type type_324 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPFlatParams::EP*,std::vector<RPFlatParams::EP> >"));
  ::Reflex::Type type_325 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >"));
  ::Reflex::Type type_326 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const CentralityTable::CBin*,std::vector<CentralityTable::CBin> >"));
  ::Reflex::Type type_245 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> > >"));
  ::Reflex::Type type_244 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPFlatParams::EP*,std::vector<RPFlatParams::EP> > >"));
  ::Reflex::Type type_247 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> > >"));
  ::Reflex::Type type_246 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const CentralityTable::CBin*,std::vector<CentralityTable::CBin> > >"));
  ::Reflex::Type type_1177 = ::Reflex::ReferenceBuilder(type_84);
  ::Reflex::Type type_84c = ::Reflex::ConstBuilder(type_84);
  ::Reflex::Type type_1178 = ::Reflex::ReferenceBuilder(type_84c);
  ::Reflex::Type type_1190 = ::Reflex::ReferenceBuilder(type_119);
  ::Reflex::Type type_119c = ::Reflex::ConstBuilder(type_119);
  ::Reflex::Type type_1191 = ::Reflex::ReferenceBuilder(type_119c);
  ::Reflex::Type type_1403 = ::Reflex::ArrayBuilder(type_284, 50);
  ::Reflex::Type type_1404 = ::Reflex::ArrayBuilder(type_287, 50);
  ::Reflex::Type type_405 = ::Reflex::ReferenceBuilder(type_341);
  ::Reflex::Type type_341c = ::Reflex::ConstBuilder(type_341);
  ::Reflex::Type type_407 = ::Reflex::ReferenceBuilder(type_341c);
  ::Reflex::Type type_401 = ::Reflex::PointerBuilder(type_341);
  ::Reflex::Type type_403 = ::Reflex::PointerBuilder(type_341c);
  ::Reflex::Type type_243 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_175);
  ::Reflex::Type type_230 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_229);
  ::Reflex::Type type_217c = ::Reflex::ConstBuilder(type_217);
  ::Reflex::Type type_1218 = ::Reflex::ReferenceBuilder(type_217c);
  ::Reflex::Type type_182c = ::Reflex::ConstBuilder(type_182);
  ::Reflex::Type type_1219 = ::Reflex::ReferenceBuilder(type_182c);
  ::Reflex::Type type_1220 = ::Reflex::ReferenceBuilder(type_182);
  ::Reflex::Type type_470 = ::Reflex::ReferenceBuilder(type_335);
  ::Reflex::Type type_335c = ::Reflex::ConstBuilder(type_335);
  ::Reflex::Type type_472 = ::Reflex::ReferenceBuilder(type_335c);
  ::Reflex::Type type_466 = ::Reflex::PointerBuilder(type_335);
  ::Reflex::Type type_468 = ::Reflex::PointerBuilder(type_335c);
  ::Reflex::Type type_218c = ::Reflex::ConstBuilder(type_218);
  ::Reflex::Type type_1222 = ::Reflex::ReferenceBuilder(type_218c);
  ::Reflex::Type type_183c = ::Reflex::ConstBuilder(type_183);
  ::Reflex::Type type_1223 = ::Reflex::ReferenceBuilder(type_183c);
  ::Reflex::Type type_1224 = ::Reflex::ReferenceBuilder(type_183);
  ::Reflex::Type type_1400 = ::Reflex::ReferenceBuilder(type_334);
  ::Reflex::Type type_334c = ::Reflex::ConstBuilder(type_334);
  ::Reflex::Type type_1401 = ::Reflex::ReferenceBuilder(type_334c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __CentralityTable
#undef __CentralityTable
#endif
class __CentralityTable {
  public:
  __CentralityTable();
  ::std::vector<CentralityTable::CBin> m_table;
};
#ifdef __RPFlatParams
#undef __RPFlatParams
#endif
class __RPFlatParams {
  public:
  __RPFlatParams();
  virtual ~__RPFlatParams() throw();
  ::std::vector<RPFlatParams::EP> m_table;
};
#ifdef __RPFlatParams__EP
#undef __RPFlatParams__EP
#endif
struct __RPFlatParams__EP {
  public:
  __RPFlatParams__EP();
  float x[50];
  float y[50];
  float xSub1[50];
  float ySub1[50];
  float xSub2[50];
  float ySub2[50];
  int RPNameIndx[50];
};
#ifdef __std__vector_RPFlatParams__EP_
#undef __std__vector_RPFlatParams__EP_
#endif
class __std__vector_RPFlatParams__EP_ : protected ::std::_Vector_base<RPFlatParams::EP,std::allocator<RPFlatParams::EP> > {
  public:
  __std__vector_RPFlatParams__EP_();
};
#ifdef __CentralityTable__CBin
#undef __CentralityTable__CBin
#endif
struct __CentralityTable__CBin {
  public:
  __CentralityTable__CBin();
  float bin_edge;
  ::CentralityTable::BinValues n_part;
  ::CentralityTable::BinValues n_coll;
  ::CentralityTable::BinValues n_hard;
  ::CentralityTable::BinValues b;
  ::CentralityTable::BinValues eccRP;
  ::CentralityTable::BinValues ecc2;
  ::CentralityTable::BinValues ecc3;
  ::CentralityTable::BinValues ecc4;
  ::CentralityTable::BinValues ecc5;
  ::CentralityTable::BinValues S;
  ::CentralityTable::BinValues var0;
  ::CentralityTable::BinValues var1;
  ::CentralityTable::BinValues var2;
};
#ifdef __std__vector_CentralityTable__CBin_
#undef __std__vector_CentralityTable__CBin_
#endif
class __std__vector_CentralityTable__CBin_ : protected ::std::_Vector_base<CentralityTable::CBin,std::allocator<CentralityTable::CBin> > {
  public:
  __std__vector_CentralityTable__CBin_();
};
#ifdef __CentralityTable__BinValues
#undef __CentralityTable__BinValues
#endif
struct __CentralityTable__BinValues {
  public:
  __CentralityTable__BinValues();
  float mean;
  float var;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class CentralityTable -------------------------------
static void destructor_336(void*, void * o, const std::vector<void*>&, void *) {
(((::CentralityTable*)o)->::CentralityTable::~CentralityTable)();
}
static  void operator_337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CentralityTable*)o)->operator=)(*(const ::CentralityTable*)arg[0]);
  else   (((::CentralityTable*)o)->operator=)(*(const ::CentralityTable*)arg[0]);
}

static void constructor_338( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralityTable(*(const ::CentralityTable*)arg[0]);
  else ::new(mem) ::CentralityTable(*(const ::CentralityTable*)arg[0]);
}

static void constructor_339( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralityTable();
  else ::new(mem) ::CentralityTable();
}

static void method_newdel_84( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CentralityTable >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CentralityTable >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CentralityTable >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CentralityTable >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CentralityTable >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CentralityTable -------------------------------
void __CentralityTable_db_datamem(Reflex::Class*);
void __CentralityTable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CentralityTable_datamem_bld(&__CentralityTable_db_datamem);
Reflex::GenreflexMemberBuilder __CentralityTable_funcmem_bld(&__CentralityTable_db_funcmem);
void __CentralityTable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CentralityTable"), typeid(::CentralityTable), sizeof(::CentralityTable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CentralityTable"), destructor_336, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1177, type_1178), Reflex::Literal("operator="), operator_337, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1178), Reflex::Literal("CentralityTable"), constructor_338, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CentralityTable"), constructor_339, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_84, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CentralityTable_datamem_bld);
}

//------Delayed data member builder for class CentralityTable -------------------
void __CentralityTable_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_183, Reflex::Literal("m_table"), OffsetOf(__shadow__::__CentralityTable, m_table), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CentralityTable -------------------
void __CentralityTable_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPFlatParams -------------------------------
static  void operator_342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPFlatParams*)o)->operator=)(*(const ::RPFlatParams*)arg[0]);
  else   (((::RPFlatParams*)o)->operator=)(*(const ::RPFlatParams*)arg[0]);
}

static void constructor_343( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFlatParams(*(const ::RPFlatParams*)arg[0]);
  else ::new(mem) ::RPFlatParams(*(const ::RPFlatParams*)arg[0]);
}

static void constructor_344( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFlatParams();
  else ::new(mem) ::RPFlatParams();
}

static void destructor_345(void*, void * o, const std::vector<void*>&, void *) {
(((::RPFlatParams*)o)->::RPFlatParams::~RPFlatParams)();
}
static void method_newdel_119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPFlatParams >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPFlatParams >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPFlatParams >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPFlatParams >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPFlatParams >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPFlatParams -------------------------------
void __RPFlatParams_db_datamem(Reflex::Class*);
void __RPFlatParams_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPFlatParams_datamem_bld(&__RPFlatParams_db_datamem);
Reflex::GenreflexMemberBuilder __RPFlatParams_funcmem_bld(&__RPFlatParams_db_funcmem);
void __RPFlatParams_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPFlatParams"), typeid(::RPFlatParams), sizeof(::RPFlatParams), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1190, type_1191), Reflex::Literal("operator="), operator_342, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1191), Reflex::Literal("RPFlatParams"), constructor_343, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPFlatParams"), constructor_344, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPFlatParams"), destructor_345, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPFlatParams_datamem_bld);
}

//------Delayed data member builder for class RPFlatParams -------------------
void __RPFlatParams_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_182, Reflex::Literal("m_table"), OffsetOf(__shadow__::__RPFlatParams, m_table), ::Reflex::PUBLIC)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class RPFlatParams -------------------
void __RPFlatParams_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class EP -------------------------------
static void destructor_1186(void*, void * o, const std::vector<void*>&, void *) {
(((::RPFlatParams::EP*)o)->::RPFlatParams::EP::~EP)();
}
static  void operator_1187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPFlatParams::EP*)o)->operator=)(*(const ::RPFlatParams::EP*)arg[0]);
  else   (((::RPFlatParams::EP*)o)->operator=)(*(const ::RPFlatParams::EP*)arg[0]);
}

static void constructor_1188( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFlatParams::EP(*(const ::RPFlatParams::EP*)arg[0]);
  else ::new(mem) ::RPFlatParams::EP(*(const ::RPFlatParams::EP*)arg[0]);
}

static void constructor_1189( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFlatParams::EP();
  else ::new(mem) ::RPFlatParams::EP();
}

static void method_newdel_341( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPFlatParams::EP >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPFlatParams::EP >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPFlatParams::EP >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPFlatParams::EP >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPFlatParams::EP >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EP -------------------------------
void __RPFlatParams__EP_db_datamem(Reflex::Class*);
void __RPFlatParams__EP_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPFlatParams__EP_datamem_bld(&__RPFlatParams__EP_db_datamem);
Reflex::GenreflexMemberBuilder __RPFlatParams__EP_funcmem_bld(&__RPFlatParams__EP_db_funcmem);
void __RPFlatParams__EP_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPFlatParams::EP"), typeid(::RPFlatParams::EP), sizeof(::RPFlatParams::EP), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EP"), destructor_1186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_405, type_407), Reflex::Literal("operator="), operator_1187, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_407), Reflex::Literal("EP"), constructor_1188, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EP"), constructor_1189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_341, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPFlatParams__EP_datamem_bld);
}

//------Delayed data member builder for class EP -------------------
void __RPFlatParams__EP_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1403, Reflex::Literal("x"), OffsetOf(__shadow__::__RPFlatParams__EP, x), ::Reflex::PUBLIC)
  .AddDataMember(type_1403, Reflex::Literal("y"), OffsetOf(__shadow__::__RPFlatParams__EP, y), ::Reflex::PUBLIC)
  .AddDataMember(type_1403, Reflex::Literal("xSub1"), OffsetOf(__shadow__::__RPFlatParams__EP, xSub1), ::Reflex::PUBLIC)
  .AddDataMember(type_1403, Reflex::Literal("ySub1"), OffsetOf(__shadow__::__RPFlatParams__EP, ySub1), ::Reflex::PUBLIC)
  .AddDataMember(type_1403, Reflex::Literal("xSub2"), OffsetOf(__shadow__::__RPFlatParams__EP, xSub2), ::Reflex::PUBLIC)
  .AddDataMember(type_1403, Reflex::Literal("ySub2"), OffsetOf(__shadow__::__RPFlatParams__EP, ySub2), ::Reflex::PUBLIC)
  .AddDataMember(type_1404, Reflex::Literal("RPNameIndx"), OffsetOf(__shadow__::__RPFlatParams__EP, RPNameIndx), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class EP -------------------
void __RPFlatParams__EP_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<RPFlatParams::EP,std::allocator<RPFlatParams::EP> > -------------------------------
static void constructor_416( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFlatParams::EP>();
  else ::new(mem) ::std::vector<RPFlatParams::EP>();
}

static void constructor_417( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFlatParams::EP>(*(const ::std::allocator<RPFlatParams::EP>*)arg[0]);
  else ::new(mem) ::std::vector<RPFlatParams::EP>(*(const ::std::allocator<RPFlatParams::EP>*)arg[0]);
}

static void constructor_418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFlatParams::EP>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPFlatParams::EP>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFlatParams::EP>(*(::std::size_t*)arg[0],
      *(const ::RPFlatParams::EP*)arg[1]);
  else ::new(mem) ::std::vector<RPFlatParams::EP>(*(::std::size_t*)arg[0],
      *(const ::RPFlatParams::EP*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFlatParams::EP>(*(::std::size_t*)arg[0],
      *(const ::RPFlatParams::EP*)arg[1],
      *(const ::std::allocator<RPFlatParams::EP>*)arg[2]);
  else ::new(mem) ::std::vector<RPFlatParams::EP>(*(::std::size_t*)arg[0],
      *(const ::RPFlatParams::EP*)arg[1],
      *(const ::std::allocator<RPFlatParams::EP>*)arg[2]);
  }
}

static void constructor_419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFlatParams::EP>(*(const ::std::vector<RPFlatParams::EP>*)arg[0]);
  else ::new(mem) ::std::vector<RPFlatParams::EP>(*(const ::std::vector<RPFlatParams::EP>*)arg[0]);
}

static void destructor_420(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPFlatParams::EP>*)o)->::std::vector<RPFlatParams::EP>::~vector)();
}
static  void operator_421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFlatParams::EP>*)o)->operator=)(*(const ::std::vector<RPFlatParams::EP>*)arg[0]);
  else   (((::std::vector<RPFlatParams::EP>*)o)->operator=)(*(const ::std::vector<RPFlatParams::EP>*)arg[0]);
}

static  void method_422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFlatParams::EP>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPFlatParams::EP*)arg[1]);
}

static  void method_423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >)((((::std::vector<RPFlatParams::EP>*)o)->begin)());
  else   (((::std::vector<RPFlatParams::EP>*)o)->begin)();
}

static  void method_424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPFlatParams::EP*,std::vector<RPFlatParams::EP> >)((((const ::std::vector<RPFlatParams::EP>*)o)->begin)());
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->begin)();
}

static  void method_425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >)((((::std::vector<RPFlatParams::EP>*)o)->end)());
  else   (((::std::vector<RPFlatParams::EP>*)o)->end)();
}

static  void method_426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPFlatParams::EP*,std::vector<RPFlatParams::EP> >)((((const ::std::vector<RPFlatParams::EP>*)o)->end)());
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->end)();
}

static  void method_431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPFlatParams::EP>*)o)->size)());
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->size)();
}

static  void method_432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPFlatParams::EP>*)o)->max_size)());
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->max_size)();
}

static  void method_433( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPFlatParams::EP>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPFlatParams::EP>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPFlatParams::EP*)arg[1]);
  }
}

static  void method_434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPFlatParams::EP>*)o)->capacity)());
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->capacity)();
}

static  void method_435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPFlatParams::EP>*)o)->empty)());
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->empty)();
}

static  void method_436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFlatParams::EP>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFlatParams::EP>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPFlatParams::EP>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFlatParams::EP>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFlatParams::EP>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPFlatParams::EP>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFlatParams::EP>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFlatParams::EP>*)o)->front)();
  else   (((::std::vector<RPFlatParams::EP>*)o)->front)();
}

static  void method_443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFlatParams::EP>*)o)->front)();
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->front)();
}

static  void method_444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFlatParams::EP>*)o)->back)();
  else   (((::std::vector<RPFlatParams::EP>*)o)->back)();
}

static  void method_445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFlatParams::EP>*)o)->back)();
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->back)();
}

static  void method_446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPFlatParams::EP>*)o)->data)());
  else   (((::std::vector<RPFlatParams::EP>*)o)->data)();
}

static  void method_447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPFlatParams::EP>*)o)->data)());
  else   (((const ::std::vector<RPFlatParams::EP>*)o)->data)();
}

static  void method_448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFlatParams::EP>*)o)->push_back)(*(const ::RPFlatParams::EP*)arg[0]);
}

static  void method_449( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPFlatParams::EP>*)o)->pop_back)();
}

static  void method_450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >)((((::std::vector<RPFlatParams::EP>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[0],
    *(const ::RPFlatParams::EP*)arg[1]));
  else   (((::std::vector<RPFlatParams::EP>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[0],
    *(const ::RPFlatParams::EP*)arg[1]);
}

static  void method_451( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFlatParams::EP>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPFlatParams::EP*)arg[2]);
}

static  void method_452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >)((((::std::vector<RPFlatParams::EP>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[0]));
  else   (((::std::vector<RPFlatParams::EP>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[0]);
}

static  void method_453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >)((((::std::vector<RPFlatParams::EP>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[1]));
  else   (((::std::vector<RPFlatParams::EP>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPFlatParams::EP*,std::vector<RPFlatParams::EP> >*)arg[1]);
}

static  void method_454( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFlatParams::EP>*)o)->swap)(*(::std::vector<RPFlatParams::EP>*)arg[0]);
}

static  void method_455( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPFlatParams::EP>*)o)->clear)();
}

static void method_newdel_182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPFlatParams::EP> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPFlatParams::EP> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPFlatParams::EP> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPFlatParams::EP> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPFlatParams::EP> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPFlatParams::EP,std::allocator<RPFlatParams::EP> >")), ::Reflex::BaseOffset< ::std::vector<RPFlatParams::EP>,::std::_Vector_base<RPFlatParams::EP,std::allocator<RPFlatParams::EP> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPFlatParams::EP> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPFlatParams::EP> >::Generate();
}

//------Dictionary for class vector<RPFlatParams::EP,std::allocator<RPFlatParams::EP> > -------------------------------
void __std__vector_RPFlatParams__EP__db_datamem(Reflex::Class*);
void __std__vector_RPFlatParams__EP__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPFlatParams__EP__datamem_bld(&__std__vector_RPFlatParams__EP__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPFlatParams__EP__funcmem_bld(&__std__vector_RPFlatParams__EP__db_funcmem);
void __std__vector_RPFlatParams__EP__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPFlatParams::EP>"), typeid(::std::vector<RPFlatParams::EP>), sizeof(::std::vector<RPFlatParams::EP>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_250, ::Reflex::BaseOffset< ::std::vector<RPFlatParams::EP>, ::std::_Vector_base<RPFlatParams::EP,std::allocator<RPFlatParams::EP> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_341, Reflex::Literal("std::vector<RPFlatParams::EP>::_Alloc_value_type"))
  .AddTypedef(type_250, Reflex::Literal("std::vector<RPFlatParams::EP>::_Base"))
  .AddTypedef(type_217, Reflex::Literal("std::vector<RPFlatParams::EP>::_Tp_alloc_type"))
  .AddTypedef(type_341, Reflex::Literal("std::vector<RPFlatParams::EP>::value_type"))
  .AddTypedef(type_401, Reflex::Literal("std::vector<RPFlatParams::EP>::pointer"))
  .AddTypedef(type_403, Reflex::Literal("std::vector<RPFlatParams::EP>::const_pointer"))
  .AddTypedef(type_405, Reflex::Literal("std::vector<RPFlatParams::EP>::reference"))
  .AddTypedef(type_407, Reflex::Literal("std::vector<RPFlatParams::EP>::const_reference"))
  .AddTypedef(type_323, Reflex::Literal("std::vector<RPFlatParams::EP>::iterator"))
  .AddTypedef(type_324, Reflex::Literal("std::vector<RPFlatParams::EP>::const_iterator"))
  .AddTypedef(type_244, Reflex::Literal("std::vector<RPFlatParams::EP>::const_reverse_iterator"))
  .AddTypedef(type_245, Reflex::Literal("std::vector<RPFlatParams::EP>::reverse_iterator"))
  .AddTypedef(type_243, Reflex::Literal("std::vector<RPFlatParams::EP>::size_type"))
  .AddTypedef(type_230, Reflex::Literal("std::vector<RPFlatParams::EP>::difference_type"))
  .AddTypedef(type_217, Reflex::Literal("std::vector<RPFlatParams::EP>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_416, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218), Reflex::Literal("vector"), constructor_417, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_243, type_407, type_1218), Reflex::Literal("vector"), constructor_418, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1219), Reflex::Literal("vector"), constructor_419, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_420, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPFlatParams__EP__funcmem_bld);
}

//------Delayed data member builder for class vector<RPFlatParams::EP,std::allocator<RPFlatParams::EP> > -------------------
void __std__vector_RPFlatParams__EP__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPFlatParams::EP,std::allocator<RPFlatParams::EP> > -------------------
void __std__vector_RPFlatParams__EP__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1220, type_1219), Reflex::Literal("operator="), operator_421, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_243, type_407), Reflex::Literal("assign"), method_422, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_323), Reflex::Literal("begin"), method_423, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_324), Reflex::Literal("begin"), method_424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_323), Reflex::Literal("end"), method_425, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_324), Reflex::Literal("end"), method_426, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_243), Reflex::Literal("size"), method_431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_243), Reflex::Literal("max_size"), method_432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_243, type_341), Reflex::Literal("resize"), method_433, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_243), Reflex::Literal("capacity"), method_434, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_286), Reflex::Literal("empty"), method_435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_243), Reflex::Literal("reserve"), method_436, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_405, type_243), Reflex::Literal("operator[]"), operator_437, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_407, type_243), Reflex::Literal("operator[]"), operator_438, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_405, type_243), Reflex::Literal("at"), method_440, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_407, type_243), Reflex::Literal("at"), method_441, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_405), Reflex::Literal("front"), method_442, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_407), Reflex::Literal("front"), method_443, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_405), Reflex::Literal("back"), method_444, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_407), Reflex::Literal("back"), method_445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_401), Reflex::Literal("data"), method_446, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_403), Reflex::Literal("data"), method_447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_407), Reflex::Literal("push_back"), method_448, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("pop_back"), method_449, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_323, type_323, type_407), Reflex::Literal("insert"), method_450, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_323, type_243, type_407), Reflex::Literal("insert"), method_451, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_323, type_323), Reflex::Literal("erase"), method_452, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_323, type_323, type_323), Reflex::Literal("erase"), method_453, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_1220), Reflex::Literal("swap"), method_454, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("clear"), method_455, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class CBin -------------------------------
static void destructor_1173(void*, void * o, const std::vector<void*>&, void *) {
(((::CentralityTable::CBin*)o)->::CentralityTable::CBin::~CBin)();
}
static  void operator_1174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CentralityTable::CBin*)o)->operator=)(*(const ::CentralityTable::CBin*)arg[0]);
  else   (((::CentralityTable::CBin*)o)->operator=)(*(const ::CentralityTable::CBin*)arg[0]);
}

static void constructor_1175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralityTable::CBin(*(const ::CentralityTable::CBin*)arg[0]);
  else ::new(mem) ::CentralityTable::CBin(*(const ::CentralityTable::CBin*)arg[0]);
}

static void constructor_1176( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralityTable::CBin();
  else ::new(mem) ::CentralityTable::CBin();
}

static void method_newdel_335( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CentralityTable::CBin >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CentralityTable::CBin >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CentralityTable::CBin >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CentralityTable::CBin >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CentralityTable::CBin >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CBin -------------------------------
void __CentralityTable__CBin_db_datamem(Reflex::Class*);
void __CentralityTable__CBin_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CentralityTable__CBin_datamem_bld(&__CentralityTable__CBin_db_datamem);
Reflex::GenreflexMemberBuilder __CentralityTable__CBin_funcmem_bld(&__CentralityTable__CBin_db_funcmem);
void __CentralityTable__CBin_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CentralityTable::CBin"), typeid(::CentralityTable::CBin), sizeof(::CentralityTable::CBin), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CBin"), destructor_1173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_470, type_472), Reflex::Literal("operator="), operator_1174, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_472), Reflex::Literal("CBin"), constructor_1175, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CBin"), constructor_1176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_335, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CentralityTable__CBin_datamem_bld);
}

//------Delayed data member builder for class CBin -------------------
void __CentralityTable__CBin_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_284, Reflex::Literal("bin_edge"), OffsetOf(__shadow__::__CentralityTable__CBin, bin_edge), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("n_part"), OffsetOf(__shadow__::__CentralityTable__CBin, n_part), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("n_coll"), OffsetOf(__shadow__::__CentralityTable__CBin, n_coll), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("n_hard"), OffsetOf(__shadow__::__CentralityTable__CBin, n_hard), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("b"), OffsetOf(__shadow__::__CentralityTable__CBin, b), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("eccRP"), OffsetOf(__shadow__::__CentralityTable__CBin, eccRP), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("ecc2"), OffsetOf(__shadow__::__CentralityTable__CBin, ecc2), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("ecc3"), OffsetOf(__shadow__::__CentralityTable__CBin, ecc3), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("ecc4"), OffsetOf(__shadow__::__CentralityTable__CBin, ecc4), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("ecc5"), OffsetOf(__shadow__::__CentralityTable__CBin, ecc5), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("S"), OffsetOf(__shadow__::__CentralityTable__CBin, S), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("var0"), OffsetOf(__shadow__::__CentralityTable__CBin, var0), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("var1"), OffsetOf(__shadow__::__CentralityTable__CBin, var1), ::Reflex::PUBLIC)
  .AddDataMember(type_334, Reflex::Literal("var2"), OffsetOf(__shadow__::__CentralityTable__CBin, var2), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CBin -------------------
void __CentralityTable__CBin_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<CentralityTable::CBin,std::allocator<CentralityTable::CBin> > -------------------------------
static void constructor_481( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CentralityTable::CBin>();
  else ::new(mem) ::std::vector<CentralityTable::CBin>();
}

static void constructor_482( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CentralityTable::CBin>(*(const ::std::allocator<CentralityTable::CBin>*)arg[0]);
  else ::new(mem) ::std::vector<CentralityTable::CBin>(*(const ::std::allocator<CentralityTable::CBin>*)arg[0]);
}

static void constructor_483( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CentralityTable::CBin>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<CentralityTable::CBin>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CentralityTable::CBin>(*(::std::size_t*)arg[0],
      *(const ::CentralityTable::CBin*)arg[1]);
  else ::new(mem) ::std::vector<CentralityTable::CBin>(*(::std::size_t*)arg[0],
      *(const ::CentralityTable::CBin*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CentralityTable::CBin>(*(::std::size_t*)arg[0],
      *(const ::CentralityTable::CBin*)arg[1],
      *(const ::std::allocator<CentralityTable::CBin>*)arg[2]);
  else ::new(mem) ::std::vector<CentralityTable::CBin>(*(::std::size_t*)arg[0],
      *(const ::CentralityTable::CBin*)arg[1],
      *(const ::std::allocator<CentralityTable::CBin>*)arg[2]);
  }
}

static void constructor_484( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CentralityTable::CBin>(*(const ::std::vector<CentralityTable::CBin>*)arg[0]);
  else ::new(mem) ::std::vector<CentralityTable::CBin>(*(const ::std::vector<CentralityTable::CBin>*)arg[0]);
}

static void destructor_485(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<CentralityTable::CBin>*)o)->::std::vector<CentralityTable::CBin>::~vector)();
}
static  void operator_486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CentralityTable::CBin>*)o)->operator=)(*(const ::std::vector<CentralityTable::CBin>*)arg[0]);
  else   (((::std::vector<CentralityTable::CBin>*)o)->operator=)(*(const ::std::vector<CentralityTable::CBin>*)arg[0]);
}

static  void method_487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CentralityTable::CBin>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::CentralityTable::CBin*)arg[1]);
}

static  void method_488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >)((((::std::vector<CentralityTable::CBin>*)o)->begin)());
  else   (((::std::vector<CentralityTable::CBin>*)o)->begin)();
}

static  void method_489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CentralityTable::CBin*,std::vector<CentralityTable::CBin> >)((((const ::std::vector<CentralityTable::CBin>*)o)->begin)());
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->begin)();
}

static  void method_490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >)((((::std::vector<CentralityTable::CBin>*)o)->end)());
  else   (((::std::vector<CentralityTable::CBin>*)o)->end)();
}

static  void method_491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CentralityTable::CBin*,std::vector<CentralityTable::CBin> >)((((const ::std::vector<CentralityTable::CBin>*)o)->end)());
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->end)();
}

static  void method_496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CentralityTable::CBin>*)o)->size)());
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->size)();
}

static  void method_497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CentralityTable::CBin>*)o)->max_size)());
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->max_size)();
}

static  void method_498( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<CentralityTable::CBin>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<CentralityTable::CBin>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::CentralityTable::CBin*)arg[1]);
  }
}

static  void method_499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CentralityTable::CBin>*)o)->capacity)());
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->capacity)();
}

static  void method_500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<CentralityTable::CBin>*)o)->empty)());
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->empty)();
}

static  void method_501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CentralityTable::CBin>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CentralityTable::CBin>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CentralityTable::CBin>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CentralityTable::CBin>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CentralityTable::CBin>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CentralityTable::CBin>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_506( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CentralityTable::CBin>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CentralityTable::CBin>*)o)->front)();
  else   (((::std::vector<CentralityTable::CBin>*)o)->front)();
}

static  void method_508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CentralityTable::CBin>*)o)->front)();
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->front)();
}

static  void method_509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CentralityTable::CBin>*)o)->back)();
  else   (((::std::vector<CentralityTable::CBin>*)o)->back)();
}

static  void method_510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CentralityTable::CBin>*)o)->back)();
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->back)();
}

static  void method_511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<CentralityTable::CBin>*)o)->data)());
  else   (((::std::vector<CentralityTable::CBin>*)o)->data)();
}

static  void method_512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<CentralityTable::CBin>*)o)->data)());
  else   (((const ::std::vector<CentralityTable::CBin>*)o)->data)();
}

static  void method_513( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CentralityTable::CBin>*)o)->push_back)(*(const ::CentralityTable::CBin*)arg[0]);
}

static  void method_514( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CentralityTable::CBin>*)o)->pop_back)();
}

static  void method_515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >)((((::std::vector<CentralityTable::CBin>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[0],
    *(const ::CentralityTable::CBin*)arg[1]));
  else   (((::std::vector<CentralityTable::CBin>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[0],
    *(const ::CentralityTable::CBin*)arg[1]);
}

static  void method_516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CentralityTable::CBin>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::CentralityTable::CBin*)arg[2]);
}

static  void method_517( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >)((((::std::vector<CentralityTable::CBin>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[0]));
  else   (((::std::vector<CentralityTable::CBin>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[0]);
}

static  void method_518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >)((((::std::vector<CentralityTable::CBin>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[1]));
  else   (((::std::vector<CentralityTable::CBin>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CentralityTable::CBin*,std::vector<CentralityTable::CBin> >*)arg[1]);
}

static  void method_519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CentralityTable::CBin>*)o)->swap)(*(::std::vector<CentralityTable::CBin>*)arg[0]);
}

static  void method_520( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CentralityTable::CBin>*)o)->clear)();
}

static void method_newdel_183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<CentralityTable::CBin> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<CentralityTable::CBin> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<CentralityTable::CBin> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<CentralityTable::CBin> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<CentralityTable::CBin> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CentralityTable::CBin,std::allocator<CentralityTable::CBin> >")), ::Reflex::BaseOffset< ::std::vector<CentralityTable::CBin>,::std::_Vector_base<CentralityTable::CBin,std::allocator<CentralityTable::CBin> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<CentralityTable::CBin> >::Generate();
  else ::Reflex::Proxy< ::std::vector<CentralityTable::CBin> >::Generate();
}

//------Dictionary for class vector<CentralityTable::CBin,std::allocator<CentralityTable::CBin> > -------------------------------
void __std__vector_CentralityTable__CBin__db_datamem(Reflex::Class*);
void __std__vector_CentralityTable__CBin__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_CentralityTable__CBin__datamem_bld(&__std__vector_CentralityTable__CBin__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_CentralityTable__CBin__funcmem_bld(&__std__vector_CentralityTable__CBin__db_funcmem);
void __std__vector_CentralityTable__CBin__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<CentralityTable::CBin>"), typeid(::std::vector<CentralityTable::CBin>), sizeof(::std::vector<CentralityTable::CBin>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_251, ::Reflex::BaseOffset< ::std::vector<CentralityTable::CBin>, ::std::_Vector_base<CentralityTable::CBin,std::allocator<CentralityTable::CBin> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_335, Reflex::Literal("std::vector<CentralityTable::CBin>::_Alloc_value_type"))
  .AddTypedef(type_251, Reflex::Literal("std::vector<CentralityTable::CBin>::_Base"))
  .AddTypedef(type_218, Reflex::Literal("std::vector<CentralityTable::CBin>::_Tp_alloc_type"))
  .AddTypedef(type_335, Reflex::Literal("std::vector<CentralityTable::CBin>::value_type"))
  .AddTypedef(type_466, Reflex::Literal("std::vector<CentralityTable::CBin>::pointer"))
  .AddTypedef(type_468, Reflex::Literal("std::vector<CentralityTable::CBin>::const_pointer"))
  .AddTypedef(type_470, Reflex::Literal("std::vector<CentralityTable::CBin>::reference"))
  .AddTypedef(type_472, Reflex::Literal("std::vector<CentralityTable::CBin>::const_reference"))
  .AddTypedef(type_325, Reflex::Literal("std::vector<CentralityTable::CBin>::iterator"))
  .AddTypedef(type_326, Reflex::Literal("std::vector<CentralityTable::CBin>::const_iterator"))
  .AddTypedef(type_246, Reflex::Literal("std::vector<CentralityTable::CBin>::const_reverse_iterator"))
  .AddTypedef(type_247, Reflex::Literal("std::vector<CentralityTable::CBin>::reverse_iterator"))
  .AddTypedef(type_243, Reflex::Literal("std::vector<CentralityTable::CBin>::size_type"))
  .AddTypedef(type_230, Reflex::Literal("std::vector<CentralityTable::CBin>::difference_type"))
  .AddTypedef(type_218, Reflex::Literal("std::vector<CentralityTable::CBin>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_481, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1222), Reflex::Literal("vector"), constructor_482, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_243, type_472, type_1222), Reflex::Literal("vector"), constructor_483, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1223), Reflex::Literal("vector"), constructor_484, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_485, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_CentralityTable__CBin__funcmem_bld);
}

//------Delayed data member builder for class vector<CentralityTable::CBin,std::allocator<CentralityTable::CBin> > -------------------
void __std__vector_CentralityTable__CBin__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<CentralityTable::CBin,std::allocator<CentralityTable::CBin> > -------------------
void __std__vector_CentralityTable__CBin__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1224, type_1223), Reflex::Literal("operator="), operator_486, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_243, type_472), Reflex::Literal("assign"), method_487, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_325), Reflex::Literal("begin"), method_488, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_326), Reflex::Literal("begin"), method_489, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_325), Reflex::Literal("end"), method_490, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_326), Reflex::Literal("end"), method_491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_243), Reflex::Literal("size"), method_496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_243), Reflex::Literal("max_size"), method_497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_243, type_335), Reflex::Literal("resize"), method_498, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_243), Reflex::Literal("capacity"), method_499, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_286), Reflex::Literal("empty"), method_500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_243), Reflex::Literal("reserve"), method_501, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_470, type_243), Reflex::Literal("operator[]"), operator_502, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_472, type_243), Reflex::Literal("operator[]"), operator_503, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_470, type_243), Reflex::Literal("at"), method_505, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_472, type_243), Reflex::Literal("at"), method_506, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_470), Reflex::Literal("front"), method_507, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_472), Reflex::Literal("front"), method_508, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_470), Reflex::Literal("back"), method_509, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_472), Reflex::Literal("back"), method_510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_466), Reflex::Literal("data"), method_511, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_468), Reflex::Literal("data"), method_512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_472), Reflex::Literal("push_back"), method_513, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("pop_back"), method_514, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_325, type_325, type_472), Reflex::Literal("insert"), method_515, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_325, type_243, type_472), Reflex::Literal("insert"), method_516, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_325, type_325), Reflex::Literal("erase"), method_517, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_325, type_325, type_325), Reflex::Literal("erase"), method_518, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296, type_1224), Reflex::Literal("swap"), method_519, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("clear"), method_520, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BinValues -------------------------------
static void destructor_1155(void*, void * o, const std::vector<void*>&, void *) {
(((::CentralityTable::BinValues*)o)->::CentralityTable::BinValues::~BinValues)();
}
static  void operator_1156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CentralityTable::BinValues*)o)->operator=)(*(const ::CentralityTable::BinValues*)arg[0]);
  else   (((::CentralityTable::BinValues*)o)->operator=)(*(const ::CentralityTable::BinValues*)arg[0]);
}

static void constructor_1157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralityTable::BinValues(*(const ::CentralityTable::BinValues*)arg[0]);
  else ::new(mem) ::CentralityTable::BinValues(*(const ::CentralityTable::BinValues*)arg[0]);
}

static void constructor_1158( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralityTable::BinValues();
  else ::new(mem) ::CentralityTable::BinValues();
}

static void method_newdel_334( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CentralityTable::BinValues >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CentralityTable::BinValues >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CentralityTable::BinValues >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CentralityTable::BinValues >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CentralityTable::BinValues >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BinValues -------------------------------
void __CentralityTable__BinValues_db_datamem(Reflex::Class*);
void __CentralityTable__BinValues_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CentralityTable__BinValues_datamem_bld(&__CentralityTable__BinValues_db_datamem);
Reflex::GenreflexMemberBuilder __CentralityTable__BinValues_funcmem_bld(&__CentralityTable__BinValues_db_funcmem);
void __CentralityTable__BinValues_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CentralityTable::BinValues"), typeid(::CentralityTable::BinValues), sizeof(::CentralityTable::BinValues), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BinValues"), destructor_1155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1400, type_1401), Reflex::Literal("operator="), operator_1156, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1401), Reflex::Literal("BinValues"), constructor_1157, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BinValues"), constructor_1158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_334, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CentralityTable__BinValues_datamem_bld);
}

//------Delayed data member builder for class BinValues -------------------
void __CentralityTable__BinValues_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_284, Reflex::Literal("mean"), OffsetOf(__shadow__::__CentralityTable__BinValues, mean), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("var"), OffsetOf(__shadow__::__CentralityTable__BinValues, var), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BinValues -------------------
void __CentralityTable__BinValues_db_funcmem(Reflex::Class*) {

}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __CentralityTable_dict(); 
      __RPFlatParams_dict(); 
      __RPFlatParams__EP_dict(); 
      __std__vector_RPFlatParams__EP__dict(); 
      __CentralityTable__CBin_dict(); 
      __std__vector_CentralityTable__CBin__dict(); 
      __CentralityTable__BinValues_dict(); 
    }
    ~Dictionaries() {
      type_84.Unload(); // class CentralityTable 
      type_119.Unload(); // class RPFlatParams 
      type_341.Unload(); // class RPFlatParams::EP 
      type_182.Unload(); // class std::vector<RPFlatParams::EP> 
      type_335.Unload(); // class CentralityTable::CBin 
      type_183.Unload(); // class std::vector<CentralityTable::CBin> 
      type_334.Unload(); // class CentralityTable::BinValues 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
