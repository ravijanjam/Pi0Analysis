#include <iostream>
#include <fstream>
#include <math.h>

#include <TROOT.h>
#include <TFile.h>
#include <TSystem.h>
#include <TStyle.h>
#include <TNtuple.h>
#include <TCanvas.h>
#include <TProfile.h>
#include <TProfile2D.h>
#include <TRandom.h>
#include <TH1F.h>
#include <TH2F.h>
#include <TMath.h>
#include <TRandom1.h>
#include <TLatex.h>
#include <TF1.h>
#include <TMultiGraph.h>
#include <TGraphErrors.h>
#include <TAxis.h>
#include <TLine.h>
#include <TDatime.h>
using namespace std;

// v2 fit function for single particles
Double_t v2SinglesFit(Double_t *x, Double_t *par) {
  return par[0]*(1.0 + 2.0*par[1]*cos(2.0*x[0]));
}

// v2 fit function for pairs
Double_t v2Fit(Double_t *x, Double_t *par) {
  return 1.0 + 2.0*par[0]*cos(2.0*x[0]);
}

Double_t v2FitPlusGaussian(Double_t *x, Double_t *par) {
  if(par[3] != 0) {
    return par[1]*(1.0 + 2.0*par[0]*cos(2.0*x[0])) +
      par[2]*exp(-x[0]*x[0]/(par[3]*par[3]));
  }
  else {
    return 0.0; 
  }
}

// constant background
Double_t constantBackground(Double_t *x, Double_t *par) {
  return par[0];
}

// one parameter linear background function
Double_t linearBackgroundOneParameter(Double_t *x, Double_t *par) {
  return  par[0]*x[0];
}

// two-parameter linear background function
Double_t linearBackground(Double_t *x, Double_t *par) {
  return par[0] + par[1]*x[0];
}

// Quadratic background function
Double_t quadraticBackground(Double_t *x, Double_t *par) {
  return par[0] + par[1]*x[0] + par[2]*x[0]*x[0];
}

// Gauss peak function
Double_t gaussPeak(Double_t *x, Double_t *par) {
  if(par[2] != 0.0) {
    double arg = x[0] - par[1];
    return par[0]*exp(-arg*arg/(par[2]*par[2]));
  }
  return 0.0;
}

// sum of quadratic background and peak function
Double_t fitFunctionQuadratic(Double_t *x, Double_t *par) {
  return quadraticBackground(x,par) + gaussPeak(x,&par[3]);
}

// sum of one-parameter linear background and peak function
Double_t fitFunctionOneLinear(Double_t *x, Double_t *par) {
  return linearBackgroundOneParameter(x,par) + gaussPeak(x,&par[1]);
}

// sum of two-linear background and peak function
Double_t fitFunctionLinear(Double_t *x, Double_t *par) {
  return linearBackground(x,par) + gaussPeak(x,&par[2]);
}

// sum of constant background and peak function
Double_t fitFunctionConstant(Double_t *x, Double_t *par) {
  return constantBackground(x,par) + gaussPeak(x,&par[1]);
}

// sum of linear background and two peak functions
Double_t fitFunctionLinear2Peaks(Double_t *x, Double_t *par) {
  return linearBackground(x,par) + gaussPeak(x,&par[2]) + gaussPeak(x,&par[5]);
}

#include <DataFormats/Math/interface/deltaPhi.h>

const double rECal = 1.29;                         // radial distance of ECAL

//
// Input file control: h1TreeFilesNameList.txt  is scanned for the names of the input files
//

//===============================Initial declarations===================================================

void flowPi0AnalyzeParallel(const int iOption=10,
			    const int runNumber=152745,
			    const unsigned int nFilesToProcess=1,
			    char *inputFileList="romapi0FileList.txt",
			    char *rootOutputFileName="rootOutputFile.root",
			    bool writeHistogramFile=true,
			    bool readHistogramFile=false,
			    bool harvestFiles = false,
			    const int centLow=16,
			    const int centHigh=20,
			    const unsigned int reactionPlaneAngleChoice=1,
			    const unsigned int NPHIBINS=6,            // number of reaction plane bins
			    const unsigned int bufferDepth=3,         // depth of mixed event buffer      
			    const unsigned int RPClass=1,             // number of reaction plane classes (originally 6)
			    const unsigned int ZVertClass=1,          // number of Z-Vertex classses (originally 4)
			    const float lowEtaLimit=-1.0,
			    const float highEtaLimit=+1.0,
			    const float lowPtCut=2.5,
			    const float highPtCut=3.0,
			    const float lowFalsePairMassCut=0.200,
			    const float highFalsePairMassCut=0.250,
			    const bool useUnClassedMassWindow=true,
			    const float subtractedYieldMinimumFactor=-0.10,
			    const bool useHalfWidth=false,
			    const float subtractedYieldWidthFactor=2.0,
			    const bool useAsymmetricMassCuts=false,
			    const float lowerAsymmetricWidthFactor=2.0,
			    const float upperAsymmetricWidthFactor=4.0,
			    const float clustEnrCut=0.4,
			    const float clustS49Cut=0.87,
			    const float clusterEnergyAsymmetryCut=-1.0,
			    const float ppConversionCutRadius=-0.20,        // Exclude pairs for which the pT sum of all other clusters within this radius has >= 0.5 of the pT of this pair
			    const bool useCoreEnergy=false,
			    const float coreEnergyCorrection=1.09,
			    const int nMassBins = 75,                       // Number of mass bins for the pi0 mass histograms
			    const float maximumPi0MassForHistogram = 0.30,  // Highest mass to be plotted (GeV/c^2)
			    const float minimumSeparation=0.05,
			    const bool usePtDependentSeparation=true,
			    const double rescaleSeparationFactor=0.70,
			    unsigned int simulationData=0) {
	
  const bool useFixedOpeningAngleCut=true;     // aOpenAngleCutParameter/pT + bOpenAngleCutParameter/pT*pT
  const float aOpenAngleCutParameter=0.1699;
  const float bOpenAngleCutParameter=-0.1115;
  const bool usePHENIXOpeningAngleCut=false;
  const float minimumOpeningAngleFactor=0.0425;

  const bool useClustS25Cut=false;         // not effective
  const float clust25CutScaleFactor=1.0;   // not effective

  unsigned int countSeparationPtCut = 0;;
  const double aSeparationCoefficient = 35.657;
  const double bSeparationCoefficient = -4.1995;
  //
  // predicted minimum separation distance dSeparation = aSeparationCoefficient/pT + bSeparationCoefficient/(pT*pT);
  //
  if(usePtDependentSeparation) {
    cout << "\n Using a pT dependent separation cut parameterization " << aSeparationCoefficient << "/pT - ";
    cout <<  fabs(bSeparationCoefficient)  << "/pT^2";
    cout << ",  with a rescale factor " << rescaleSeparationFactor << endl;
  }
  else {
    cout << "\n Not using a a pT dependent separation cut" << endl;
  }

  bool useOldClustS25Cut = false;          // not useful
  const float clustS25Cut = 0.20;
  if(useOldClustS25Cut) {
    cout << "\n  Using old version of S25 cluster cut" << endl;
  }

  if(harvestFiles && readHistogramFile) {
    cerr << "\n Cannot have a true for harvestFiles paired with a true for readHistogramFile\n";
    return;
  }
	
  if(harvestFiles && !writeHistogramFile) {
    cerr << "\n Cannot have a true for harvestFiles paired with a false for writeHistogramFile\n";
    return;	
  }
	
  if(harvestFiles && iOption == 31) {
    cerr << "\n Cannot have a true for harvestFiles paired iOption = 31\n";
    return;	
  }

  if(iOption== 31 && readHistogramFile) {
    cerr << "\n Cannnot have iOption = 31 paired with a true value for readHistogramFile\n";
    return;
  }
	
  if(iOption== 31 && !writeHistogramFile) {
    cerr << "\n Cannnot have iOption = 31 paired with a false value for writeHistogramFile\n";
    return;
  }
	
  //
  // Variables which had been in the calling argument list (can only have 40 such variables)
  //

  const float lowTruePairMassCut=0.100;
  const float highTruePairMassCut=0.176;

  const unsigned int CentClass=1;           // number of centrality classes

  const int maximumClusterEntries=0;
  bool useReactionPlaneAngle=true;
	
  const float clustS1Cut = 0.2;

  bool useZVertexStop = false;
  const float zVertexStop = -2.801476;

  bool useRecoEnergyRescale = false;
  const float recoEnergyRescale = 1.011;

  const float lowZVertex=-15.0;
  const float highZVertex=+15.0;
  const float subtractedStart=0.090;
  const float subtractedEnd=0.180;								 
  const int iBackgroundOption=1;
  const float clustPtCut=0.0;

  const float largerClust25CutLowestPt = 1.4*clust25CutScaleFactor;
  const float smallerClust25CutLowestPt = 2.2*clust25CutScaleFactor;

  const float largerClust25CutLowPt = 1.6*clust25CutScaleFactor;
  const float smallerClust25CutLowPt = 2.8*clust25CutScaleFactor;
                       
  const float largerClust25CutMidPt = 2.0*clust25CutScaleFactor;
  const float smallerClust25CutMidPt = 3.5*clust25CutScaleFactor;
                       
  const float largerClust25CutHighPt = 2.0*clust25CutScaleFactor;
  const float smallerClust25CutHighPt = 5.0*clust25CutScaleFactor;

    ////////////////////////////////////////////////////////////////
    const int _nEtaBins = 16;
    const int _nPhiBins = 36;
    const int _nBins = 16*36;
    const int _DETA = 31;
    const double _pi = 3.1415927;
    
    double _etaMin = -1.0;
    double _dEta = 2*fabs(_etaMin)/double(_nEtaBins);
    double _dPhi = 2*_pi/double(_nPhiBins);
    double _DEta = 2*_nEtaBins - 1;
    
    double _avgPi0EtaPhi[_nBins];
    double _TrackPi0Phi[1000];
    double _TrackPi0Eta[1000];
    double _TrackPi0Pt[1000];
    double _Arraypi0[_nPhiBins][_DETA];
    int checkStoredPi0;
    int CrossCheckPi0 = 0;
    
    cout << "     _etaMin:" << _etaMin << endl;
    cout << "       _dEta:" << _dEta << endl;
    cout << "       _dPhi:" << _dPhi << endl;
    cout << "       _DEta:" << _DEta << endl;
    
    TProfile *_Avgpi0 = new TProfile("_Avgpi0", "Profile of avgerage pi0", _nBins, double(0.), double(_nBins));
    TProfile2D *_Avgpi0_dEtadPhi = new TProfile2D("_Avgpi0_dEtadPhi", "Why doesn't it look like a triangle?", _nPhiBins, double(0.), double(_nPhiBins), _DEta, double(0.), double(_DEta));
    /////////////////////////////////////////////////////////////////
    
  //
  // Short self-documentation
  // 
  if(iOption == 0) {
    cout << endl;
    cout << "\n***********************************************************************************************************************************";
    cout << "\n         iOption choices for flowPi0Analyze.C macro";
    cout << "\n iOption=0    Prints this self-documentation";
    cout << "\n iOption=5    Obtains the v2 paramters for the reaction plane decomposition of the aziumuthal yields";
    cout << "\n iOption=10  Obtains a single invaraint mass histogram with a mixed-event combinatoric background subtraction";
    cout << "\n iOption=-10   Obtains a single invaraint mass histogram with a parameterized combinatoric background fit";
    cout << "\n              The single invariant mass histograms are for the complete eta and pT ranges specified in the input control parameters";
    cout << "\n***********************************************************************************************************************************";
    cout << endl << endl;
    return;
  }

  if(readHistogramFile && writeHistogramFile) {
    cerr << "\n Cannot do a simultaneous read and write of the histogram file";
    cerr << endl;
    return;
  }

  if(bufferDepth < 2) {
    cerr << "\n An events buffer minimum depth of 2 is required";
    cerr << endl;
    return;
  }
	
  if(reactionPlaneAngleChoice != 1  && reactionPlaneAngleChoice != 9) {
    cerr << "\n Invalid Reaction Plane Choice " << reactionPlaneAngleChoice << endl;
    return;
  }
	
  if(reactionPlaneAngleChoice == 1)
    cout << "\n\n Reaction Plane Angle Choice is HFAngle" << endl << endl;
	
  bool usingGapAnglePair = false;
  if(reactionPlaneAngleChoice == 9) {
    cout << "\n\n Reaction Plane Angle Choice is PsEtGap/NGAngle Pair" << endl << endl;
    usingGapAnglePair = true;
  }
	
  if(usePHENIXOpeningAngleCut && useFixedOpeningAngleCut) {
    cerr << "\n Cannot use both opening angle cut equations" << endl;
    return;
  }
	
  if(usePHENIXOpeningAngleCut)
    cout << "\n Using PHENIX opening angle cut equation" << endl;
	
  if(useFixedOpeningAngleCut) {
    cout << "\n Using Fixed opening angle cut parameterization " << aOpenAngleCutParameter << "/pT + ";
    cout << bOpenAngleCutParameter << "/pT^2" << endl;
  }

  //
  // No longer important parameters for signal + background fitting
  //
  float fitStart=0.090;
  float fitEnd=0.18;
  float peakStart=0.10;
  float peakEnd=0.17;

  //
  // Obtain integer centrality numbers
  //
  int lowCent = 2.5*centLow;
  int highCent = 2.5*centHigh;	
  int useEventsProcessed;

  char fileName[200];

  TDatime *dateTime = new TDatime;
  dateTime->Set();     // set to system date/time
  int date = dateTime->GetDate();
  cout << "\n Date " << date << endl;

  unsigned int countClusterS25Cut = 0;
  //unsigned int countBadReactionPlaneAngle = 0;

  const float clusterClosestCut = -1.00;
  unsigned int countClosestCut = 0;
  unsigned int countSeparationCut = 0;

  unsigned int countConversionCut = 0;

  unsigned int countSameEventAsymmetryCut = 0;
  unsigned int countMixedEventAsymmetryCut = 0;
  unsigned int countSameEvents = 0;
  unsigned const minimumClustersPerEvent = 2;

  unsigned int countOpeningAngleCut = 0;
  const float minimumOpeningAngleFactorSquared = minimumOpeningAngleFactor*minimumOpeningAngleFactor/(2.0*coreEnergyCorrection*coreEnergyCorrection);
  const float minimumSeparationSquared = minimumSeparation*minimumSeparation;

  bool useClusterEnergyAsymmetryCut = clusterEnergyAsymmetryCut > 0.0;

  bool realData = simulationData==0;
  bool toyModel = simulationData==1;
  bool hydjetModel = simulationData==2;
  bool pythiaModel = simulationData==3;
	
  if(toyModel || pythiaModel) {
    lowCent = 0;
    highCent = 99;
  }
	
  TGraphErrors *graphFlow = 0;
  TF1 *flowFitFcn = 0;
  TF1 *flowFitFcn2 = 0;
  TF1 *noFlowFitFcn = 0;
		
  bool useToyModelRPResolution = true;
  float toyModelRPResolution = +0.50;  // radians
  TRandom1 *randomNumber = new TRandom1();
  randomNumber->SetSeed(1);
	
  unsigned int countOutOfRangeDeltaRP = 0;

  unsigned int countClustersStored = 0;
  unsigned int countClustersInGlobalCut = 0;
  unsigned int countMixedClusterExamined = 0;
  unsigned int countClusterEvents = 0;
  int countClusterEntries = 0;
  unsigned int maximumClustersInSingleEvent = 0;
  const unsigned int maximumNumberAcceptedCluster = 1000;     // maximum number of clusters in a class set
  struct acceptedClusterInformation {                         //========================Here's the struct=============================================
    Long64_t thisEvent;
    unsigned int kCluster;
    Float_t clustEta;
    Float_t clustPhi;
    Float_t clustPt;
    Float_t clustEnr;
    Float_t clustS49;
    Float_t clustS25;
    Float_t closestNeighbor;
    Float_t hfAllAngle;
    Float_t negEtaGapAngle;
    Float_t posEtaGapAngle;
  };

  acceptedClusterInformation acceptedClusterInformationArray[RPClass][ZVertClass][CentClass][bufferDepth][maximumNumberAcceptedCluster];
  unsigned int countAcceptedCluster[RPClass][ZVertClass][CentClass][bufferDepth];
  Long64_t eventNumberCluster[RPClass][ZVertClass][CentClass][bufferDepth];
	
  //Declaration of leaves types
  Int_t           Run;
  Int_t           Event;
  Int_t           LumiSection;
  Double_t        cent_val;
  Int_t           cent_bin;
  Int_t           nHITracks;
  Double_t        zVertEvt;
  Double_t        zVertEvtS;
  Double_t        PGAngle;
  Double_t        NGAngle;
  Double_t        HFAngle;
  Int_t           nCry;
  Float_t         eCry[35000];
  Float_t         ptCry[35000];
  Float_t         timeCry[35000];
  Int_t           flagCry[35000];
  Int_t           ietaCry[35000];
  Int_t           iphiCry[35000];
  Int_t           iCry[35000];
  Int_t           iSM[35000];
  Float_t         etaCry;
  Float_t         phiCry;
  Int_t           nClu;
  Float_t         ptClu[10000];
  Float_t         etaClu[10000];
  Float_t         phiClu[10000];
  Float_t         S1Clu[10000];
  Float_t         S4Clu[10000];
  Float_t         S9Clu[10000];
  Float_t         S25Clu[10000];
  Float_t         timeClu[10000];
  Int_t           nCryClu[10000];
  Int_t           indexCryClu[10000][9];
	
  unsigned int totalEvents = 0;
  unsigned int totalEventsInCentralityRange = 0;
  unsigned int totalAcceptedPi0 = 0;
  unsigned int totalEventsWithClusters = 0;
  unsigned int countMixedMassInPtAndEtaWindows = 0.0;

  char countsPerBin[100];
  int binWidth = 1000.0*maximumPi0MassForHistogram/nMassBins + 0.001;
  sprintf(countsPerBin, "Counts per %d MeV/c^{2} bin", binWidth);

  double harvestedMass[nMassBins];
  double harvestedAvgPi0[_nPhiBins*_nEtaBins];
	
  TH1D *pi0MassHistogram = 0;
  TH1D *pi0EtaTrueHistogram = 0;
  TH1D *pi0PhiTrueHistogram = 0;
  TH1D *pi0PtTrueHistogram = 0;

  TH1D *pi0PhiRPTrueHistogram = 0;	

  TH1D *pi0OpenAngleHistogram = 0;
  TH1D *pi0OpenAngleHistogramMixed = 0;
	
  TH1D *eventAcceptedReactionPlaneAngleHistogram = 0;
  TH1D *pi0AcceptedReactionPlaneAngleHistogram = 0;
		
  TH1D *pi0MassHistogramSameEvent = 0;
  TH1D *pi0MassHistogramMixed = 0;
	
  TH1D *etaMassHistogram = 0;
  TH1D *etaMassHistogramMixed = 0;

  TH1D *diffMidEtaHFAngle = 0;	
  TH1D *diffPosEtaGapHFAngle = 0;
  TH1D *diffNegEtaGapHFAngle = 0;
  TH1D *diffEtaGapAngle = 0;
	
  int nBinsOneD = 100;
  double harvestedAngle[nBinsOneD];
	
  //const unsigned int NETABINS = 4;
  //const float lowEtaBin[NETABINS] =  {0.00, 0.35, 0.70, 1.05};
  //const float highEtaBin[NETABINS] = {0.35, 0.70, 1.05, 1.40};
	
  const unsigned int NETABINS = 1;
  const float lowEtaBin[NETABINS] =  {0.00};
  const float highEtaBin[NETABINS] = {0.80};
	
  const float lowPhiBin6[6] =  {0.0,              TMath::Pi()/12.0, TMath::Pi()/6.0, TMath::Pi()/4.0, TMath::Pi()/3.0,      5.0*TMath::Pi()/12.0};
  const float highPhiBin6[6] = {TMath::Pi()/12.0, TMath::Pi()/6.0,  TMath::Pi()/4.0, TMath::Pi()/3.0, 5.0*TMath::Pi()/12.0, TMath::Pi()/2.0};

  const float lowPhiBin9[9] =  {0.0,                 TMath::Pi()/9.0,     2.0*TMath::Pi()/9.0, TMath::Pi()/3.0,     4.0*TMath::Pi()/9.0, 5.0*TMath::Pi()/9.0, 
				2.0*TMath::Pi()/3.0, 7.0*TMath::Pi()/9.0, 8.0*TMath::Pi()/9.0};
  const float highPhiBin9[9] = {TMath::Pi()/9.0,     2.0*TMath::Pi()/9.0, TMath::Pi()/3.0,     4.0*TMath::Pi()/9.0, 5.0*TMath::Pi()/9.0, 2.0*TMath::Pi()/3.0,
				7.0*TMath::Pi()/9.0, 8.0*TMath::Pi()/9.0, TMath::Pi()};

  float lowPhiBin[NPHIBINS];
  float highPhiBin[NPHIBINS];
  for(unsigned int iPhi=0; iPhi<NPHIBINS; iPhi++) {
    if(NPHIBINS == 6) {
      lowPhiBin[iPhi] =  lowPhiBin6[iPhi];
      highPhiBin[iPhi] =  highPhiBin6[iPhi];
    }
    else {
      lowPhiBin[iPhi] =  lowPhiBin9[iPhi];
      highPhiBin[iPhi] =  highPhiBin9[iPhi];
    }
  } // initialize the phi bin limits, according to the size of NPHIBINS (6 or 9)

  float deltaRPClass = (0.5*TMath::Pi())/RPClass;

  float lowZVertBin[ZVertClass];
  float highZVertBin[ZVertClass];
  float deltaZ = (highZVertex - lowZVertex)/ZVertClass;
  for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
    lowZVertBin[kZVert] = lowZVertex + kZVert*deltaZ;
    highZVertBin[kZVert] = lowZVertBin[kZVert] + deltaZ;
    cout << "\n kZVert " << kZVert;
    cout << ",  lowZVertBin[kZVert] " <<  lowZVertBin[kZVert];
    cout << ",  highZVertBin[kZVert] " << highZVertBin[kZVert];
  }
  cout << endl;

  const unsigned int NPTBINS = 8;
  if(iOption >=1 && iOption <=5) {
    cerr << "\n This version of the code using 8 pT bins is not compatibile with iOption = " << iOption << endl;
    return;
  }

  // 
  // Old version with only 4 pt bins
  //
  // const float lowPtBin[NPTBINS] =  {3.4, 4.6, 6.0, 3.4};
  // const float highPtBin[NPTBINS] = {4.6, 6.0, 8.5, 8.5};

  //
  // Complete pT range for 8 pT (full-size) bins
  //
  const float lowPtBin[NPTBINS] =  {1.6, 2.0, 2.5, 3.0, 4.0, 6.0, 8.0, 1.6};
  const float highPtBin[NPTBINS] = {2.0, 2.5, 3.0, 4.0, 6.0, 8.0, 12.0, 12.0};

  //
  // Complete pT range for 16 pT (half-size) bins
  //
  //const float lowPtBin[NPTBINS] =  {1.0, 1.2, 1.4, 1.6, 1.8, 2.00, 2.25, 2.50, 2.75, 3.0, 3.5, 4.0, 5.0, 6.0, 8.00, 1.0};
  //const float highPtBin[NPTBINS] = {1.2, 1.4, 1.6, 1.8, 2.0, 2.25, 2.50, 2.75, 3.00, 3.5, 4.0, 5.0, 6.0, 8.0, 12.0, 12.0};
  //

  TH1D *pi0MassEtaPhiPtHistogram[NETABINS][NPHIBINS][NPTBINS];
  TH1D *pi0MassEtaPtHistogram[NETABINS][NPTBINS];
  TH1D *pi0MassEtaPtHistogramMixed[NETABINS][NPTBINS];

  TH1D *pi0MassEtaPtRPZVertCentHistogram[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
  TH1D *pi0MassEtaPhiPtRPZVertCentHistogram[NETABINS][NPHIBINS][NPTBINS][RPClass][ZVertClass][CentClass];

  TH1D *pi0MassEtaPtRPZVertCentHistogramMixed[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];

  TH1D *dummyMassHistogram = new TH1D("dummyMassHistogram", "Dummy", nMassBins, 0.0,  maximumPi0MassForHistogram);

  if(!readHistogramFile) {

    diffMidEtaHFAngle = new TH1D("diffMidEtaHFAngle", "RP Angle Difference MidEta - HF", nBinsOneD, -TMath::Pi(), +TMath::Pi());
    diffMidEtaHFAngle->SetXTitle("#Delta#Phi_{RP} (radians)");
    diffMidEtaHFAngle->SetYTitle("Counts");

    diffPosEtaGapHFAngle = new TH1D("diffPosEtaGapHFAngle", "RP Angle Difference PosEtaGap - HF", nBinsOneD, -TMath::Pi(), +TMath::Pi());
    diffPosEtaGapHFAngle->SetXTitle("#Delta#Phi_{RP} (radians)");
    diffPosEtaGapHFAngle->SetYTitle("Counts");

    diffNegEtaGapHFAngle = new TH1D("diffNegEtaGapHFAngle", "RP Angle Difference NegEtaGap - HF", nBinsOneD, -TMath::Pi(), +TMath::Pi());
    diffNegEtaGapHFAngle->SetXTitle("#Delta#Phi_{RP} (radians)");
    diffNegEtaGapHFAngle->SetYTitle("Counts");
		
    diffEtaGapAngle = new TH1D("diffEtaGapAngle", "RP Angle Difference PosEtaGap - NegEtaGap", nBinsOneD, -TMath::Pi(), +TMath::Pi());
    diffEtaGapAngle->SetXTitle("#Delta#Phi_{RP} (radians)");
    diffEtaGapAngle->SetYTitle("Counts");				

    pi0MassHistogram = new TH1D("pi0MassHistogram", "#pi^{0} Peak in Heavy Ion Events", nMassBins, 0.0, maximumPi0MassForHistogram);
    pi0MassHistogram->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    pi0MassHistogram->SetYTitle(countsPerBin);
		
    char histogramName[200];
    char histogramTitle[200];
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	sprintf(histogramName, "pi0MassMixedEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Mixed-event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogramMixed[kEta][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	pi0MassEtaPtHistogramMixed[kEta][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	pi0MassEtaPtHistogramMixed[kEta][kPt]->SetYTitle(countsPerBin);
	sprintf(histogramName, "pi0MassEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Same-event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogram[kEta][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	pi0MassEtaPtHistogram[kEta][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	pi0MassEtaPtHistogram[kEta][kPt]->SetYTitle(countsPerBin);
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  sprintf(histogramName, "pi0MassEtaBin%dPhiBin%dPtBin%d", kEta, kPhi, kPt);
	  sprintf(histogramTitle, "#pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt]);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetYTitle(countsPerBin);

	  for(unsigned int kRP=0; kRP<RPClass; kRP++) {
	    for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	      for(unsigned int kCent=0; kCent<CentClass; kCent++) {

		if(kPhi == 0) { // check on kPhi = 0 to set up histograms which do not depend on phi angle
		  sprintf(histogramName, "pi0MassSameEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
		  sprintf(histogramTitle, "Same event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			  lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
		  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
		  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->SetYTitle(countsPerBin);

		  sprintf(histogramName, "pi0MassMixedEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
		  sprintf(histogramTitle, "Mixed event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			  lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
		  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
		  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->SetYTitle(countsPerBin);

		} // check on kPhi = 0 to set up histograms which do not depend on phi angle

		sprintf(histogramName, "pi0MassSameEtaBin%dPhiBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPhi, kPt, kRP, kZVert, kCent);
		sprintf(histogramTitle, "Same event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
		pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
		pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetYTitle(countsPerBin);


	      } // loop over centrality classes
	    } // loop over ZVertex classes
	  } // loop over RP Classes	

	} // loop over phi bins

      } // loop over pt bins	
    } // loop over eta bins

    pi0OpenAngleHistogram = new TH1D("pi0OpenAngleHistogram", "#pi^{0} Opening Angle in Heavy Ion Events", 3*nBinsOneD, 0.0, 0.1);
    pi0OpenAngleHistogram->SetXTitle("#Delta#theta (radians)");
    pi0OpenAngleHistogram->SetYTitle("Counts");
				
    pi0OpenAngleHistogramMixed = new TH1D("pi0OpenAngleHistogramMixed", "#pi^{0} Opening Angle in Heavy Ion Mixed Events", 3*nBinsOneD, 0.0, 0.1);
    pi0OpenAngleHistogramMixed->SetXTitle("#Delta#theta (radians)");
    pi0OpenAngleHistogramMixed->SetYTitle("Counts");
		
    eventAcceptedReactionPlaneAngleHistogram = new TH1D("eventAcceptedReactionPlaneAngle", "Event Accepted Reaction Plane Angle",
							90, -0.5*TMath::Pi(), +0.5*TMath::Pi());
    eventAcceptedReactionPlaneAngleHistogram->SetXTitle("Event Reaction Plane Angle (radians)");
    eventAcceptedReactionPlaneAngleHistogram->SetYTitle("Counts per 2 degree bin");
		
    pi0AcceptedReactionPlaneAngleHistogram = new TH1D("pi0AcceptedReactionPlaneAngle", "Reaction Plane Angle for Accepted #pi^{0}",
						      90, -0.5*TMath::Pi(), +0.5*TMath::Pi());
    pi0AcceptedReactionPlaneAngleHistogram->SetXTitle("Reaction Plane Angle (radians)");
    pi0AcceptedReactionPlaneAngleHistogram->SetYTitle("Counts per 2 degree bin");

    pi0MassHistogramSameEvent = new TH1D("pi0MassHistogramSameEvent", "#pi^{0} Peak in Heavy Ion Same Events", nMassBins, 0.0, maximumPi0MassForHistogram);
    pi0MassHistogramSameEvent->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    pi0MassHistogramSameEvent->SetYTitle(countsPerBin);		

    pi0MassHistogramMixed = new TH1D("pi0MassHistogramMixed", "#pi^{0} Peak in Heavy Ion Mixed Events", nMassBins, 0.0, maximumPi0MassForHistogram);
    pi0MassHistogramMixed->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    pi0MassHistogramMixed->SetYTitle(countsPerBin);
				
    etaMassHistogram = new TH1D("etaMassHistogram", "#eta (547 MeV) Peak in Heavy Ion Events", 35, 0.30, 0.80);
    etaMassHistogram->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    etaMassHistogram->SetYTitle("Counts per 17 MeV/c^{2} bin");

    etaMassHistogramMixed = new TH1D("etaMassHistogramMixed", "#eta (547 MeV) Peak in Heavy Ion Mixed Events", 35, 0.30, 0.80);
    etaMassHistogramMixed->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    etaMassHistogramMixed->SetYTitle("Counts per 17 MeV/c^{2} bin");
		
    pi0EtaTrueHistogram = new TH1D("pi0EtaTrueHistogram", "True #pi^{0} #eta distribution", nBinsOneD, -1.5, +1.5);
    pi0EtaTrueHistogram->SetXTitle("#eta");
    pi0EtaTrueHistogram->SetYTitle("Counts per 0.015 bin");

    pi0PhiTrueHistogram = new TH1D("pi0PhiTrueHistogram", "True #pi^{0} azimuthal distribution", nBinsOneD, -3.3, +3.3);
    pi0PhiTrueHistogram->SetXTitle("Azimuthal angle #phi (radians)");
    pi0PhiTrueHistogram->SetYTitle("Counts per 0.066 radians bin");

    pi0PhiRPTrueHistogram = new TH1D("pi0PhiRPTrueHistogram", "True #pi^{0} RP azimuthal distribution", nBinsOneD, 0.0, TMath::Pi());
    pi0PhiRPTrueHistogram->SetXTitle("Azimuthal angle #phi (radians)");
    pi0PhiRPTrueHistogram->SetYTitle("Counts per 0.0314 radians bin");

    pi0PtTrueHistogram = new TH1D("pi0PtTrueHistogram", "True #pi^{0} p_{T}", nBinsOneD, 0.0, 7.5);
    pi0PtTrueHistogram->SetXTitle("Transverse momentum p_T (GeV/c)");
    pi0PtTrueHistogram->SetYTitle("Counts per 5 MeV/c bin");

    if(!harvestFiles) {

      unsigned int kFile = 0;
      ifstream inFile(inputFileList);
      if(inFile.eof()) {
	cerr << "\n Unable to find inputFileList input file";
	cerr << endl;
	return;
      }

      unsigned int currentBufferEventIndexCluster[RPClass][ZVertClass][CentClass];
      for(unsigned int iCurBuf=0; iCurBuf<RPClass; iCurBuf++){
	for(unsigned int jCurBuf=0; jCurBuf<ZVertClass; jCurBuf++){
	  for(unsigned int kCurBuf=0; kCurBuf<CentClass; kCurBuf++){
	    currentBufferEventIndexCluster[iCurBuf][jCurBuf][kCurBuf] = 0; 
	  }
	}
      }

      for (unsigned int kBuffer=0; kBuffer<bufferDepth; kBuffer++) {
	for (unsigned int kRPC=0; kRPC<RPClass; kRPC++) {
	  for (unsigned int kZVC=0; kZVC<ZVertClass; kZVC++) {
	    for (unsigned int kCC=0; kCC<CentClass; kCC++) {
	      countAcceptedCluster[kRPC][kZVC][kCC][kBuffer] = 0;
	      eventNumberCluster[kRPC][kZVC][kCC][kBuffer] = 0;
	    }
	  }
	}
      }

      //
      //=============================================================Loop over input files=========================================================
      //

      while(!inFile.eof()) {
			
	if(kFile >= nFilesToProcess)
	  break;
			
	inFile.getline(fileName, 200);
	if(inFile.eof()) {
	  cout << "\n Breaking from the input file list reading at kFile = " << kFile << endl;
	  break;
	}
		
	TFile *f1 = new TFile(fileName);
	if (!f1) {
	  cerr << "\n Unable to find file " << fileName;
	  cerr << endl;
	  return;
	}
			
	TTree *h1 = (TTree*)f1->Get("h1");
	if(!h1) {
	  cerr << "\n Unable to find h1 tree";
	  kFile++;
	  cerr << "\n Skipping kFile " << kFile << " " << fileName << endl;
	  cerr << endl;
	  continue;
	}
			
	// Set branch addresses.
	h1->SetBranchAddress("Run",&Run);
	h1->SetBranchAddress("Event",&Event);
	h1->SetBranchAddress("LumiSection",&LumiSection);
	h1->SetBranchAddress("cent_val",&cent_val);
	h1->SetBranchAddress("cent_bin",&cent_bin);
	h1->SetBranchAddress("nHITracks",&nHITracks);
	h1->SetBranchAddress("zVertEvt",&zVertEvt);
	h1->SetBranchAddress("zVertEvtS",&zVertEvtS);
	h1->SetBranchAddress("PGAngle",&PGAngle);
	h1->SetBranchAddress("NGAngle",&NGAngle);
	h1->SetBranchAddress("HFAngle",&HFAngle);
	h1->SetBranchAddress("nCry",&nCry);
	h1->SetBranchAddress("eCry",eCry);
	h1->SetBranchAddress("ptCry",ptCry);
	h1->SetBranchAddress("timeCry",timeCry);
	h1->SetBranchAddress("flagCry",flagCry);
	h1->SetBranchAddress("ietaCry",ietaCry);
	h1->SetBranchAddress("iphiCry",iphiCry);
	h1->SetBranchAddress("iCry",iCry);
	h1->SetBranchAddress("iSM",iSM);
	h1->SetBranchAddress("etaCry",&etaCry);
	h1->SetBranchAddress("phiCry",&phiCry);
	h1->SetBranchAddress("nClu",&nClu);
	h1->SetBranchAddress("ptClu",ptClu);
	h1->SetBranchAddress("etaClu",etaClu);
	h1->SetBranchAddress("phiClu",phiClu);
	h1->SetBranchAddress("S1Clu",S1Clu);
	h1->SetBranchAddress("S4Clu",S4Clu);
	h1->SetBranchAddress("S9Clu",S9Clu);
	h1->SetBranchAddress("S25Clu",S25Clu);
	h1->SetBranchAddress("timeClu",timeClu);
	h1->SetBranchAddress("nCryClu",nCryClu);
	h1->SetBranchAddress("indexCryClu",indexCryClu);
	
	if(maximumClusterEntries == 0 || countClusterEntries < maximumClusterEntries) {//=================================================================

	  Long64_t nEntriesC = h1->GetEntries();

	  cout << "\n Entries in clusters NTUPLE = " << nEntriesC << endl;

	  Long64_t nEntries0C = nEntriesC/10;

	  Long64_t readEntriesC = nEntriesC;
	  if(maximumClusterEntries > 0 && maximumClusterEntries < nEntriesC) {
	    readEntriesC = maximumClusterEntries;
	    nEntries0C = readEntriesC/10;
	  }

	  if(nEntries0C < 1)
	    nEntries0C = 1;

	  h1->GetEntry(0);
	  //
	  // Should check for valid Run number, and constancy of Run
	  //

	  Long64_t thisEvent = Event;
	  int thisRun = Run;
	  int thiscent_bin = cent_bin;
	  int thisnClu = nClu;

	  //
	  // These values are set event-by-event in the while loop below
	  //
	  unsigned int thisRPClass = 0;
	  unsigned int thisZVertClass = 0;
	  unsigned int thisCentClass = 0;
	  float reactionPlaneAngle = 0.0;
	  float RPClassAngle = 0.0;

	  //
	  // the currentAcceptedClusterNumber counts the clusters in the given class set of the acceptedClusterInformationArray
	  //
	  unsigned int currentAcceptedClusterNumber = 0;

	  cout << "\n Begin clusters NTUPLE scan with iOption = " << iOption << " for file " << fileName;
	  cout << "\n First event number " << thisEvent  << " with centrality " << cent_bin << " in run " << thisRun << " centrality value " << cent_val;
	  cout << ", readEntriesC " << readEntriesC << ", nEntries0C " << nEntries0C;
	  cout << endl;
        
	  Long64_t iEntry =0;
	  while(iEntry<readEntriesC) {//=========================Start loop over entries/events======================================================
			
	    h1->GetEntry(iEntry);
		
	    if(iEntry > 0 && iEntry%nEntries0C == 0) {
	      cout << "\n Entry " << iEntry << " with countMixedInPtAndEtaWindows " << countMixedMassInPtAndEtaWindows << " and nClu " << nClu;
	      cout << ", clusters in global cuts " << countClustersInGlobalCut;
	      cout << ", total clusters stored " << countClustersStored; 
	      cout << ", same event pi0 store " << pi0MassHistogramSameEvent->GetEntries();
	      cout << ", openAngle cuts " << countOpeningAngleCut; 
	      cout << ", pTSeparateCut " << countSeparationPtCut;
	      cout << ", conversionCut " << countConversionCut;
	    }

	    if(useZVertexStop && fabs(zVertexStop - zVertEvt)<0.000001) {
	      cout << "\n Stopping at zVertEvt = " << zVertEvt << endl;
	      break;
	    }
				
	    iEntry++;
	    countClusterEntries++;

	    thisEvent = Event;
	    if(thisEvent < 0) {
	      cerr << "\n thisEvent = " << thisEvent << ",  Event = " << Event << endl;
	      return;
	    } // check for negative event number (should not happen)

	    totalEvents++;
	    thiscent_bin = cent_bin;
	    thisnClu = nClu;

	    if(reactionPlaneAngleChoice == 1) {

	      RPClassAngle = fabs(HFAngle); // HFAngle stored in radians, -pi/2 to + pi/2
	      thisRPClass = RPClassAngle/deltaRPClass;

	      if(thisRPClass >= RPClass)
		continue; // we should count these skipped events because of RPClass overrun
    
	    }
	    else if(reactionPlaneAngleChoice == 9) {
	      thisRPClass = 0;
	    }
	    else {
	      cerr << "No reaction plane plane choice!" << endl;
	      return;
	    }

	    thisZVertClass = (zVertEvt-lowZVertex)/deltaZ;

	    if(thisZVertClass >= ZVertClass)
	      continue; // we should count these skipped events because of ZVertClass overrun

	    //
	    // For now we keep thisCentClass as 0
	    //

	    countClusterEvents++;
	    eventNumberCluster[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]] = thisEvent;
		
	    if(currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass] >= bufferDepth) {
	      cerr << "\n currentBufferEventIndexCluster " << currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass] << " exceeds buffer depth " << bufferDepth;
	      cerr << "\n thisRPClass = " << thisRPClass;
	      cerr << ",  thisZVertClass = " << thisZVertClass;
	      cerr << ",  thisCentClass = " << thisCentClass;
	      cerr << endl;
	      return;
	    } // safety check
		
	    //
	    // Global cuts for events
	    //

	    if(cent_bin < centLow || cent_bin >= centHigh ||
	       zVertEvtS < lowZVertex || zVertEvtS > highZVertex)
	      continue;

	    totalEventsInCentralityRange++;
	    countClustersInGlobalCut += nClu; 
		
	    currentAcceptedClusterNumber = 0;
        checkStoredPi0 = 0;
          
          for (int EtaPhi=0; EtaPhi<_nBins;++EtaPhi)
          {
              _avgPi0EtaPhi[EtaPhi] = 0;
          }
          
          for(int xBin=0; xBin<_nPhiBins; xBin++)
          {
              for(int yBin=0; yBin<_DETA; yBin++)
              {
                  _Arraypi0[xBin][yBin] = 0;
              }
          }
		
	    //
	    //============================Loop over clusters in current event, put current event into array==============================================
	    //
	    for(int kCluster=0; kCluster<nClu; kCluster++) {
			
	      float clustrEnr = S9Clu[kCluster];
	      float clustrPt = ptClu[kCluster];
	      float clustrS49 = S4Clu[kCluster]/clustrEnr;
	      float clustrS1 = S1Clu[kCluster];
	      float clustrEta = etaClu[kCluster];
	      float clustrS25 = S25Clu[kCluster];

	      if(useRecoEnergyRescale) {
		//
		// Used for Pythia MC Summer 10
		//
		clustrPt *= recoEnergyRescale;
		clustrEnr *= recoEnergyRescale;
		clustrS25 *= recoEnergyRescale;
	      }

	      //
	      // These cuts are used as the global cuts below for the pi0 mass histograms
	      //
	      if(clustrEnr > clustEnrCut && clustrPt > clustPtCut &&
		 clustrS49 > clustS49Cut && clustrS1 > clustS1Cut &&
		 fabs(clustrEta) < 1.49 && (!useOldClustS25Cut || fabs(1.0 - clustrS25/clustrEnr) < clustS25Cut)) {
	
		if(currentAcceptedClusterNumber >= maximumNumberAcceptedCluster) {
		  cerr << "\n currentAcceptedClusterNumber is too large " << currentAcceptedClusterNumber << endl;
		  return;
		} // safety check on too many clusters
				
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].thisEvent = thisEvent;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].kCluster = kCluster;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].clustEta = clustrEta;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].clustPhi = phiClu[kCluster];
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].clustPt = clustrPt;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].clustEnr = clustrEnr;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].clustS49 = clustrS49;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].clustS25 = clustrS25;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].hfAllAngle = HFAngle;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].posEtaGapAngle = PGAngle;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].negEtaGapAngle = NGAngle;
		acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][currentAcceptedClusterNumber].closestNeighbor = 1.0e+38;  // not used presently
				
		if(currentAcceptedClusterNumber == 0) {
		  if(usingGapAnglePair) { // using EtaGap event plane
		    eventAcceptedReactionPlaneAngleHistogram->Fill(PGAngle);
		    eventAcceptedReactionPlaneAngleHistogram->Fill(NGAngle);
		  }
		  else { // using HF event plane
		    eventAcceptedReactionPlaneAngleHistogram->Fill(HFAngle);
		  }
		} // check on first accepted event
				
		currentAcceptedClusterNumber++;
		countClustersStored++;
		if(currentAcceptedClusterNumber > maximumClustersInSingleEvent)
		  maximumClustersInSingleEvent = currentAcceptedClusterNumber;
				
	      } // check for good cluster
			
	    } // loop over good clusters=======================end loop filling array with current clusters=================================================

	    if(currentAcceptedClusterNumber >= minimumClustersPerEvent) {
	      totalEventsWithClusters++;
	      countAcceptedCluster[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]] = currentAcceptedClusterNumber; // clusters accepted in the current event
		
	      //
	      // Calculate same-event and mixed-event mass spectra
	      //

	      for(unsigned int jCluster1=0; jCluster1<currentAcceptedClusterNumber; jCluster1++) {//=====loop over clusters in current event=============
					
		if(acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].closestNeighbor < clusterClosestCut) {
		  countClosestCut++;
		  cerr << "\n Fail closest neighbor check, outer loop" << endl;
		  return; // not in use at present
		}
					
		Long64_t currentEvent = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].thisEvent;
			
		float ptCluster1 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].clustPt;
		float etaCluster1 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].clustEta;
		float phiCluster1 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].clustPhi;
		float enrCluster1 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].clustEnr;
		float s49Cluster1 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].clustS49;
		float s25Cluster1 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].clustS25;
         
		//                phiCluster1 += _pi; //flipping all cluster azimuth with pi radians
              
		float p1x = ptCluster1*cos(phiCluster1);
		float p1y = ptCluster1*sin(phiCluster1);
		float p1z = enrCluster1*cos(2.0*atan(exp(-etaCluster1)));
			
		double clust1Theta = 2.0*atan(exp(-etaCluster1));
			
		float xCluster1 = rECal*cos(phiCluster1);
		float yCluster1 = rECal*sin(phiCluster1);
		float zCluster1 = rECal/tan(clust1Theta);
			
		for(unsigned int kBuffer=0; kBuffer<bufferDepth; kBuffer++) {//=======Loop over OTHER events============================================
		  bool sameEventCheck = false;
		  if(currentEvent == eventNumberCluster[thisRPClass][thisZVertClass][thisCentClass][kBuffer]) {
		    sameEventCheck = true;
		  }
				
		  unsigned int previousAcceptedNumber = countAcceptedCluster[thisRPClass][thisZVertClass][thisCentClass][kBuffer];
		  if(sameEventCheck && currentAcceptedClusterNumber != previousAcceptedNumber) {
		    cerr << "\n Programming error, same event cluster numbers are not the same";
		    cerr << ";  currentAcceptedClusterNumber " << currentAcceptedClusterNumber;
		    cerr << ",  previousAcceptedNumber " << previousAcceptedNumber;
		    cerr << ",  currentEvent = " << currentEvent;
		    cerr << endl;
		    return;
		  }
		
		  for(unsigned int jCluster2=0; jCluster2<previousAcceptedNumber; jCluster2++) {//=============loop over clusters in kbuffer================
				
		    if(acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].closestNeighbor < clusterClosestCut) {
		      countClosestCut++;
		      cerr << "\n Fail closest neighbor check, outer loop" << endl;
		      return;  // not in use at present
		    }

		    Long64_t previousEvent = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].thisEvent;
		    if(previousEvent == currentEvent && !sameEventCheck) {
		      cerr << "\n Programming error: trying to mix clusters with the same event number " << currentEvent;
		      cerr << ",  kBuffer = " << kBuffer << ", clusters in previous event " << previousAcceptedNumber;
		      for(unsigned int jBuffer=0; jBuffer<bufferDepth; jBuffer++) {
			cout << "\n jBuffer " << jBuffer << ",  eventNumber " << eventNumberCluster[thisRPClass][thisZVertClass][thisCentClass][jBuffer];
			cout << ", clusters in event " << countAcceptedCluster[thisRPClass][thisZVertClass][thisCentClass][jBuffer];
		      }
		      cerr << endl;
		      return;
		    }	
				
		    if(sameEventCheck && jCluster2<=jCluster1)
		      continue;
							
		    if(sameEventCheck)
		      countSameEvents++;

		    countMixedClusterExamined++;
					
		    float ptCluster2 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].clustPt;
		    float etaCluster2 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].clustEta;
		    float enrCluster2 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].clustEnr;
		    float s49Cluster2 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].clustS49;
		    float s25Cluster2 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].clustS25;
		    float phiCluster2 = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][kBuffer][jCluster2].clustPhi;
		    float p2x = ptCluster2*cos(phiCluster2);
		    float p2y = ptCluster2*sin(phiCluster2);
		    float p2z = enrCluster2*cos(2.0*atan(exp(-etaCluster2)));					
		    double clust2Theta = 2.0*atan(exp(-etaCluster2));

		    float pxsum = p1x + p2x;
		    float pysum = p1y + p2y;
		    float pi0Pt = sqrt(pxsum*pxsum + pysum*pysum);
			
		    float pi0Phi = atan2(pysum, pxsum); 
		    float pzsum = p1z + p2z;
		    float totalMomentum = sqrt(pi0Pt*pi0Pt + pzsum*pzsum);
		    float pi0Theta = acos(pzsum/totalMomentum);
		    float pi0Eta = -log(tan(pi0Theta/2.));

		    bool ppConversionCutFail = false;
		    if(sameEventCheck && ppConversionCutRadius > 0.0) {
		      //
		      // Check the pT sum of all other clusters in this event
		      //
		      float ptSum = 0.0;
		      for(unsigned int jCluster0=0; jCluster0<currentAcceptedClusterNumber; jCluster0++) {
			if(jCluster0 != jCluster1 && jCluster0 != jCluster2) {
			  float clustEta0 =  acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster0].clustEta;
			  float diffEta0 = fabs(clustEta0 - pi0Eta);
			  if(diffEta0 < ppConversionCutRadius) {
			    float clustPhi0 =  acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster0].clustPhi;
			    float diffPhi0 = fabs(deltaPhi(clustPhi0, pi0Phi));
			    if(diffPhi0 < ppConversionCutRadius) {
			      float testRadius = sqrt(diffPhi0*diffPhi0 + diffEta0*diffEta0);
			      if(testRadius < ppConversionCutRadius) {
				ptSum += acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster0].clustPt;
			      } // check if this cluster is within the conversion cut radius value
			    }  // immediate check on diffEta0 being too large
			  } // immediate check on diffEta0 being too large
			} // exclude the clusters forming this pair
		      } // loop over jCluster0
		      if(ptSum >= 0.5*pi0Pt)
			ppConversionCutFail = true;
		    } // same event check

		    if(ppConversionCutFail) {
		      countConversionCut++;
		      continue; // skip this pair because of conversion cut check
		    }

		    float xCluster2 = rECal*cos(phiCluster2);
		    float yCluster2 = rECal*sin(phiCluster2);
		    float zCluster2 = rECal/tan(clust2Theta);
					
		    float dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		      (yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		      (zCluster2 - zCluster1)*(zCluster2- zCluster1);
					
		    static int separationPrint = 0;
		    if(separationPrint < 0) {
		      separationPrint++;
		      cout << "\n separation squared " << dSeparationSquared;
		      if(separationPrint >= 10) {
			cout << endl;
		      }
		    }  // debug print for separation distances
					
		    if(dSeparationSquared < minimumSeparationSquared) {
		      countSeparationCut++;
		      continue;
		    } // check for passing absolute minimum separation cut

		    if(usePtDependentSeparation && pi0Pt > 0.0 ) {
		      //
		      // Parameterization result is in cm, but need meters for checking
		      //
		      double predictedMinimumDistance = 0.01*rescaleSeparationFactor*(aSeparationCoefficient/pi0Pt + bSeparationCoefficient/(pi0Pt*pi0Pt));
		      if(dSeparationSquared < predictedMinimumDistance*predictedMinimumDistance) {
			countSeparationPtCut++;
			continue;
		      } // check for passing pT dependent separation cut
		    }

		    if(useClustS25Cut) {
		      float enrLarger = enrCluster1;
		      float enrSmaller = enrCluster2;
		      float s25Larger = s25Cluster1;
		      float s25Smaller = s25Cluster2;

		      if(enrCluster1 < enrCluster2) {
			enrLarger = enrCluster2;
			enrSmaller = enrCluster1;
			s25Larger = s25Cluster2;
			s25Smaller = s25Cluster1;
		      } // check on the cluster with the larger energy

		      if(pi0Pt < 2.0) {
			if(s25Larger/enrLarger > largerClust25CutLowestPt ||
			   s25Smaller/enrSmaller > smallerClust25CutLowestPt) {
			  countClusterS25Cut++;
			  continue;
			}
		      } // check on lowest pT range

		      if(pi0Pt >= 2.0 && pi0Pt < 4.0) {
			if(s25Larger/enrLarger > largerClust25CutLowPt ||
			   s25Smaller/enrSmaller > smallerClust25CutLowPt) {
			  countClusterS25Cut++;
			  continue;
			}
		      } // check on low pT range

		      if(pi0Pt >= 4.0 && pi0Pt < 6.0) {
			if(s25Larger/enrLarger > largerClust25CutMidPt ||
			   s25Smaller/enrSmaller > smallerClust25CutMidPt) {
			  countClusterS25Cut++;
			  continue;
			}
		      } // check on mid pT range

		      if(pi0Pt >= 6.0){
			if(s25Larger/enrLarger > largerClust25CutHighPt ||
			   s25Smaller/enrSmaller > smallerClust25CutHighPt) {
			  countClusterS25Cut++;
			  continue;
			}
		      } // check on high pT range

		    } // check on using S25 cluster cut
					
		    //
		    // Compute the reco mass quantities for combinations satisfying pT and eta cuts
		    //					
		    float absPi0Eta = fabs(pi0Eta);
				
		    float pi0Energy = enrCluster1 + enrCluster2;
		    float combinedEventPi0Mass = sqrt(pi0Energy*pi0Energy - totalMomentum*totalMomentum);

		    if(useCoreEnergy) {
		      if(s49Cluster1<=1.0)
			combinedEventPi0Mass *= sqrt(coreEnergyCorrection*s49Cluster1);
		      if(s49Cluster2<=1.0)
			combinedEventPi0Mass *= sqrt(coreEnergyCorrection*s49Cluster2);
		    }

		    if(useClusterEnergyAsymmetryCut && combinedEventPi0Mass < maximumPi0MassForHistogram) {  // asymmetry cut for pi0 mass only
		      float clusterEnergySum = enrCluster2 + enrCluster1;

		      if(clusterEnergySum <= 0.0) {
			cerr << "\n Reconstruction error, cluster energy sum = " << clusterEnergySum;
			cerr << "\n  Cluster1 energy = " <<  enrCluster1;
			cerr << "\n  Cluster2 energy = " <<  enrCluster2;
			cerr << endl;
			return;
		      } // safety check on cluster energy sum

		      float clusterEnergyAsymmetry = fabs(enrCluster2 - enrCluster1)/clusterEnergySum;
		      if(clusterEnergyAsymmetry >  clusterEnergyAsymmetryCut) {

			if(!sameEventCheck)
			  countMixedEventAsymmetryCut++;
			else
			  countSameEventAsymmetryCut++;

			continue;  // skip this combination
		      }

		    } // check on using cluster energy asymmetry cut

		    double cosOpenAngle = cos(clust1Theta)*cos(clust2Theta) + sin(clust1Theta)*sin(clust2Theta)*cos(phiCluster2 - phiCluster1);
		    float openAngle = acos(cosOpenAngle);

		    if(combinedEventPi0Mass > 0.0 && combinedEventPi0Mass < maximumPi0MassForHistogram) {
		      //
		      // Checks for combinations in the pi0 mass range
		      //

		      bool failOpeningAngleCut = false;
		      if(usePHENIXOpeningAngleCut || useFixedOpeningAngleCut)
			failOpeningAngleCut = true;

		      if(usePHENIXOpeningAngleCut) {
			//
			// opening angle cut according to PHENIX analysis notes for the pi0
			//
			float openingAngleCut = 1.0 - minimumOpeningAngleFactorSquared/(s49Cluster1*s49Cluster2);
			if(cosOpenAngle < openingAngleCut)
			  failOpeningAngleCut = false;
		      } // check on usePHENIXOpeningAngleCut
				
		      if(useFixedOpeningAngleCut) {
			//
			// opening angle cut according to pT-Dependent parameterization
			//
			float pTDependentOpenAngleCut = aOpenAngleCutParameter/pi0Pt + bOpenAngleCutParameter/(pi0Pt*pi0Pt);
			if(openAngle > pTDependentOpenAngleCut)
			  failOpeningAngleCut = false;
		      } // check on using pT-dependent opening angle parameterization
				
		      if(failOpeningAngleCut) {
			if(sameEventCheck) {
			  countOpeningAngleCut++;
			} // count the number of same-event failures to pass opening angle cut
			continue; // skip this combination
		      } // check on passing opening angle cut, either same-event or mixed-event
		
		    } // check on being  inside pi0 mass histogram region 

		    if(pi0Pt < lowPtCut || pi0Pt > highPtCut)
		      continue;
		    if(pi0Eta <= lowEtaLimit || pi0Eta >= highEtaLimit)
		      continue;
					
		    countMixedMassInPtAndEtaWindows++;
							
		    if(!sameEventCheck && combinedEventPi0Mass > 0.3 && combinedEventPi0Mass < 0.80)
		      etaMassHistogramMixed->Fill(combinedEventPi0Mass);

		    if(sameEventCheck && combinedEventPi0Mass > 0.3 && combinedEventPi0Mass < 0.80)
		      etaMassHistogram->Fill(combinedEventPi0Mass);
			
		    if(combinedEventPi0Mass > 0.0 && combinedEventPi0Mass < maximumPi0MassForHistogram) {

		      if(!usingGapAnglePair) {
			reactionPlaneAngle = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].hfAllAngle;
		      } // using HF event plane
		      else {
			if(pi0Eta >= 0.0)
			  reactionPlaneAngle = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].negEtaGapAngle;
			else
			  reactionPlaneAngle = acceptedClusterInformationArray[thisRPClass][thisZVertClass][thisCentClass][currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]][jCluster1].posEtaGapAngle;
		      } // using gap event plane

		      if(reactionPlaneAngle < -TMath::Pi() ||
			 reactionPlaneAngle > TMath::Pi()) {
			cerr << "\n Bad reaction plane angle error" << endl;
			return;
			//countBadReactionPlaneAngle++;             // this counter is always 0
			//continue;
		      }

		      float testCosineTwoDelta = cos(2.0*(pi0Phi - reactionPlaneAngle)); 
		      float testEpsilon = fabs(0.001*testCosineTwoDelta);
		      if(testEpsilon < 1.0e-05)
			testEpsilon = 1.0e-05;

		      float recPi0PhiRP = deltaPhi(pi0Phi, reactionPlaneAngle);
		      if(recPi0PhiRP < 0)
			recPi0PhiRP += TMath::Pi();
		
		      if(fabs(cos(2.0*recPi0PhiRP) - testCosineTwoDelta) > testEpsilon) {
			cerr << "\n Fail cosine(2*Delta) test";
			cerr << ", testCosineTwoDelta " << testCosineTwoDelta;
			cerr << ", current cosine(2*Delta) " << cos(2.0*recPi0PhiRP);
			cerr << ", diff " << fabs(cos(2.0*recPi0PhiRP) - testCosineTwoDelta);
			cerr << endl;
			return;
		      }
		
		      if(NPHIBINS == 6 && recPi0PhiRP > TMath::Pi()/2.0)
			recPi0PhiRP = TMath::Pi() - recPi0PhiRP;  // Using pi/2 as the upper limit

		      if(recPi0PhiRP < lowPhiBin[0] || recPi0PhiRP > highPhiBin[NPHIBINS-1]) {
			cerr << "\n recPi0PhiRP out of range:";
			cerr << " recPi0PhiRP " << recPi0PhiRP;
			cerr << ", pi0Phi " << pi0Phi;
			cerr << ", reactionPlaneAngle " << reactionPlaneAngle;
			cerr << ", deltaPhi " << deltaPhi(pi0Phi, reactionPlaneAngle);
			cerr << endl;
			countOutOfRangeDeltaRP++;
		      }

		      /*
			cout << "\n thisRPClass " << thisRPClass << ", HFAngle " << HFAngle << ", RPClassAngle " << RPClassAngle;
			cout << "\n thisZVertClass " << thisZVertClass << ", zVertEvt " << zVertEvt;
			cout << "\n thisCentClass " << thisCentClass;
			cout << "\n Temporary stop" << endl;
		      */
 
		      for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
			if(absPi0Eta >= lowEtaBin[kEta] && absPi0Eta < highEtaBin[kEta]) {
			  for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
			    if(pi0Pt >= lowPtBin[kPt] && pi0Pt < highPtBin[kPt]) {
			      if(sameEventCheck) {
				//
				// Fill same-event histograms
				//
				pi0MassEtaPtHistogram[kEta][kPt]->Fill(combinedEventPi0Mass);
				pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][thisRPClass][thisZVertClass][thisCentClass]->Fill(combinedEventPi0Mass);
				for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
				  if(recPi0PhiRP >= lowPhiBin[kPhi] && recPi0PhiRP < highPhiBin[kPhi]) {
				    pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->Fill(combinedEventPi0Mass);  // this histogram is not divided into classes
				    pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][thisRPClass][thisZVertClass][thisCentClass]->Fill(combinedEventPi0Mass);
				    break;
				  } // check for inside phi delta-RP bin
				} // loop over phi bins
			      }
			      else {
				//
				// Fill mixed-event histograms
				//
				pi0MassEtaPtHistogramMixed[kEta][kPt]->Fill(combinedEventPi0Mass);
				pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][thisRPClass][thisZVertClass][thisCentClass]->Fill(combinedEventPi0Mass);
			      }
			    } // check for inside pt bin
			  } // loop over pt bins
			  break;
			} // check for inside eta bin
		      } // loop over eta bins	

		      if(sameEventCheck) {
			//
			// These are original same event histograms, not divided into classes
			//
			pi0MassHistogramSameEvent->Fill(combinedEventPi0Mass);
			pi0AcceptedReactionPlaneAngleHistogram->Fill(reactionPlaneAngle);
			pi0OpenAngleHistogram->Fill(openAngle);
    
			//
			// Introduce "true" same event mass cuts related to the ridge effect
			//
			if(toyModel ||
			   (combinedEventPi0Mass > lowTruePairMassCut && combinedEventPi0Mass < highTruePairMassCut )) {
                    pi0MassHistogram->Fill(combinedEventPi0Mass);
                    _TrackPi0Phi[checkStoredPi0] = pi0Phi;
                    _TrackPi0Eta[checkStoredPi0] = pi0Eta;
                    _TrackPi0Pt[checkStoredPi0] = pi0Pt;
                
                    int iPhi1 = int( (_pi+pi0Phi)/_dPhi);
                    if (iPhi1<0 || iPhi1>=_nPhiBins) continue;
                    int iEta1 = int( (pi0Eta - _etaMin)/_dEta);
                    if (iEta1<0 || iEta1>=_nEtaBins) continue;
                    int iEtaPhi = iEta1*_nPhiBins+iPhi1;
                
                    _avgPi0EtaPhi[iEtaPhi]++;
                
                    pi0EtaTrueHistogram->Fill(pi0Eta);
                    pi0PhiTrueHistogram->Fill(pi0Phi);
                    pi0PhiRPTrueHistogram->Fill(recPi0PhiRP);
                    pi0PtTrueHistogram->Fill(pi0Pt);
                    checkStoredPi0++;
			        totalAcceptedPi0++;   // accepted pi0 in the true mass window

                    } // check on toy model or mass cuts
		      } // same event check
		      else {
			//
			// These are other original mixed event histograms, not divided into classes
			//
			pi0MassHistogramMixed->Fill(combinedEventPi0Mass);

			pi0OpenAngleHistogramMixed->Fill(openAngle);
						
		      } // check for mixed event mode
		    } // check histogram mass window
					
		  } // loop over previous event clusters
				
		} // loop over event buffer
			
	      } // loop over current clusters
			
	      currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass]++;
	      if(currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass] == bufferDepth)
		currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass] = 0;  // roll back to the start of the buffer for filling with the next event
			
	      if(currentBufferEventIndexCluster[thisRPClass][thisZVertClass][thisCentClass] >= bufferDepth) {
		cerr << "\n Programming error: attempting to set an index beyond the event limit in the buffer";
		cerr << endl;
		return;
	      }

	    } // check for minimum number of clusters in the this event

          ///////////// calculations for dipion correlations ///////
          CrossCheckPi0 += checkStoredPi0;
          if(checkStoredPi0 > 1) {
          for(int i1=0; i1<checkStoredPi0; i1++)
          {
              int iPhi = int( (_pi+_TrackPi0Phi[i1])/_dPhi);
              if (iPhi<0 || iPhi>=_nPhiBins) continue;
              int iEta = int( (_TrackPi0Eta[i1]-_etaMin)/_dEta);
              if (iEta<0 || iEta>=_nEtaBins) continue;
              
              for(int j1=0; j1<checkStoredPi0; j1++)
              {
                  if(i1 != j1)
                  {
                      int jPhi = int( (_pi+_TrackPi0Phi[j1])/_dPhi);
                      if (jPhi<0 || jPhi>=_nPhiBins) continue;
                      int jEta = int( (_TrackPi0Eta[j1]-_etaMin)/_dEta);
                      if (jEta<0 || jEta>=_nEtaBins) continue;
                      
                      int _Delta_Eta = iEta - jEta + _nEtaBins;
                      int _Delta_Phi = iPhi - jPhi; 
                      if(_Delta_Phi<0) _Delta_Phi += _nPhiBins; 
                      
                      _Arraypi0[_Delta_Phi][_Delta_Eta-1] += 1;
                  }
              }
            
          }
          }
          
          for (int _EtaPhi=0; _EtaPhi<_nEtaBins*_nPhiBins; ++_EtaPhi)
          {
              _Avgpi0->Fill(_EtaPhi, _avgPi0EtaPhi[_EtaPhi]);
          }
          
          float nPhiBin1, nEtaBin1;
          for(int nPhiBin=0; nPhiBin<_nPhiBins; nPhiBin++)
          {
              nPhiBin1 = float(nPhiBin) + 0.5;
              for(int nEtaBin=1; nEtaBin<=_DEta; nEtaBin++)
              {
                  nEtaBin1 = float(nEtaBin) - 0.5;
                  _Avgpi0_dEtadPhi->Fill(nPhiBin1, nEtaBin1, _Arraypi0[nPhiBin][nEtaBin-1]);
              }
          }
	  } // while loop over cluster entries (event loop)

	  cout << "\n Finished scan of cluster NTUPLE, with countClusterEntries cumulative total = " << countClusterEntries;
	  cout << "\n  Currently with pi0 mixed event entries = " << pi0MassHistogramMixed->GetEntries();
	  cout << ",  and  eta mixed event entries = " << etaMassHistogramMixed->GetEntries();
	  cout << "\n  total number of events for clusters = " << countClusterEvents;
	  cout << ",  mixed clusters examined " << countMixedClusterExamined;
	  cout << ",  events containing at least one cluster " << totalEventsWithClusters++;
	  cout << ",  clusters in global cuts " << countClustersInGlobalCut;

	  if(countClusterEntries >=  maximumClusterEntries)
	    cout << "\n  *** Have reached maximumClusterEntries value " << maximumClusterEntries << " ***";
	
	  cout << endl;

	} // check for cluster entry limit
		
	kFile++;
	cout << "\n Finished processing file " << kFile << " with name " << fileName;
	cout << "\n\n Cumulative accepted pi0 " << totalAcceptedPi0<< '\t'<< "Cross check pi0: "<<CrossCheckPi0<<endl;
	cout << ",  cumulative events " << totalEvents;
	cout << ",  events in centrality range " << totalEventsInCentralityRange;
	cout << ",  out of range deltaRP count " << countOutOfRangeDeltaRP;
	cout <<"\n  Maximum number of clusters in a single event = " <<  maximumClustersInSingleEvent;
	if(f1) {
	  f1->Close();
	  cout << "\n Closed file " << fileName;
	  delete f1;
	}
	cout << endl;

      } // while loop over input files

      cout << "\n\n Finished all NTUPLE scans with total events = " << totalEvents;

      unsigned int maximumCountPerClass = 0;
      unsigned int totalCountClass = 0;
      unsigned int nonZeroCountClass = 0;
      for(unsigned int kBuffer=0; kBuffer<bufferDepth; kBuffer++) {
	for(unsigned int kCent=0; kCent<CentClass; kCent++) {
	  for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	    for(unsigned int kRP=0; kRP<RPClass; kRP++) {
	      //cout << "\n countAcceptedCluster[" << kRP << "][" << kZVert << "][" << kCent << "][" << kBuffer << "] = " << countAcceptedCluster[kRP][kZVert][kCent][kBuffer]; 

	      if(countAcceptedCluster[kRP][kZVert][kCent][kBuffer] > 0) {
		nonZeroCountClass++;
		totalCountClass += countAcceptedCluster[kRP][kZVert][kCent][kBuffer];
		if(countAcceptedCluster[kRP][kZVert][kCent][kBuffer] > maximumCountPerClass)
		  maximumCountPerClass = countAcceptedCluster[kRP][kZVert][kCent][kBuffer];
	      }

	    } // loop over kRP
	  } // loop over kZVert
	} // loop over kClass
      } // loop over kBuffer

      cout << "\n Maximum accepted clusters in any one class " <<  maximumCountPerClass;
      cout << ";  number of non-zero classes " <<  nonZeroCountClass;
      if(nonZeroCountClass > 0)
	cout << "; average number of clusters per non-zero class " << float(totalCountClass)/float(nonZeroCountClass);

      cout << endl;

    } // check on not harvesting files

  } // check on not reading histogram file


  //========================================================Below this, all about making histograms and such=============================================

	
  if(harvestFiles) {
    //
    // Harvesting histograms from previous parallel jobs
    //
		
    int useRunNumber = runNumber;
    if(toyModel)
      useRunNumber = 0;		
		
    TFile *parallelRootInputFiles[nFilesToProcess];
    ifstream parallelFile(inputFileList);
    if(parallelFile.eof()) {
      cerr << "\n Unable to find inputFileList input file";
      cerr << endl;
      return;
    }
    cout << "\n List of harvested files:";
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
      parallelRootInputFiles[kFile] = 0;
      parallelFile.getline(fileName, 200);
      if(parallelFile.eof()) {
	cerr << "\n File read error for harvester list at kFile = " << kFile << endl;
	return;
      }
      cout << "\n " << kFile + 1 << ") " << fileName;
      parallelRootInputFiles[kFile] = new TFile(fileName);			
    } // loop over list of input files
    cout << endl;
		
    for(int kMass=0; kMass<nMassBins; kMass++) {
      harvestedMass[kMass] = 0.0;
    }
    double sumBinCount = 0;
    double sumParallelCount = 0;
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
      pi0MassHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0MassHistogram");
      if(!pi0MassHistogram) {
	cerr << "\n Cannot find harvested pi0MassHistogram for kFile = " << kFile << endl;
	return;
      }
      sumParallelCount += pi0MassHistogram->Integral();
      for(int kMass=0; kMass<nMassBins; kMass++) {
	sumBinCount += pi0MassHistogram->GetBinContent(kMass+1);
	harvestedMass[kMass] += pi0MassHistogram->GetBinContent(kMass+1);
      }
      cout << "\n sumBinCount " << sumBinCount;
    } // loop over outputs from parallel jobs
		
    double checkSum = 0.0;
    for(int kMass=1; kMass<=nMassBins; kMass++) {
      double massSum = harvestedMass[kMass-1];
      checkSum += massSum;
      if(massSum > 0.0) {
	pi0MassHistogram->SetBinContent(kMass, massSum);
	pi0MassHistogram->SetBinError(kMass, sqrt(massSum));
      } // check on non-zero mass
    } // loop over mass bins
      
      ////////////////////////// Harvesting dipion variables//////////////////////////
      
      for(int _iBin=0; _iBin<16*36; _iBin++) {
          harvestedAvgPi0[_iBin] = 0.0;
      }
   
      for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
          _Avgpi0 = (TProfile*)parallelRootInputFiles[kFile]->Get("_Avgpi0");
          if(!_Avgpi0) {
              cerr << "\n Cannot find harvested _Avgpi0 histogram for kFile = " << kFile << endl;
              return;
          }
          sumParallelCount += _Avgpi0->Integral();
          for(int _iBin=0; _iBin<16*36; _iBin++) {
              sumBinCount += _Avgpi0->GetBinContent(_iBin+1);
              harvestedAvgPi0[_iBin] += _Avgpi0->GetBinContent(_iBin+1);
          }
          cout << "\n sumBinCount " << sumBinCount;
      } // loop over outputs from parallel jobs
      
 
      for(int _iBin=1; _iBin<=16*36; _iBin++) {
          double pi0Sum = harvestedAvgPi0[_iBin-1];
          checkSum += pi0Sum;
          if(pi0Sum > 0.0) {
              _Avgpi0->SetBinContent(_iBin, pi0Sum);
              _Avgpi0->SetBinError(_iBin, sqrt(pi0Sum));
          } // check on non-zero mass
      } // loop over mass bins
		
    cout << "\n Avg pi0 sum in all parallel files " << sumParallelCount;
    cout << ",  pi0 sum in harvested file " << _Avgpi0->Integral();
    cout << ",  check sum mass " << checkSum;
    cout << endl;
    //  **************************************************************************
      
      float nPhiBin1, nEtaBin1;
      for(int nPhiBin=0; nPhiBin<_nPhiBins; nPhiBin++)
      {
          nPhiBin1 = float(nPhiBin) + 0.5;
          for(int nEtaBin=1; nEtaBin<=_DEta; nEtaBin++)
          {
              nEtaBin1 = float(nEtaBin) - 0.5;
              _Avgpi0_dEtadPhi->Fill(nPhiBin1, nEtaBin1, _Arraypi0[nPhiBin][nEtaBin-1]);
          }
      }
    //////////////////////////////////////////////////////////////////////////
		
    for(int kMass=0; kMass<nMassBins; kMass++) {
      harvestedMass[kMass] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
      pi0MassHistogramSameEvent = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0MassHistogramSameEvent");
      if(!pi0MassHistogramSameEvent) {
	cerr << "\n Cannot find harvested pi0MassHistogramSameEvent" << endl;
	return;
      }
      for(int kMass=0; kMass<nMassBins; kMass++) {
	harvestedMass[kMass] += pi0MassHistogramSameEvent->GetBinContent(kMass+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kMass=1; kMass<=nMassBins; kMass++) {
      double massSum = harvestedMass[kMass-1];
      if(massSum > 0.0) {
	pi0MassHistogramSameEvent->SetBinContent(kMass, massSum);
	pi0MassHistogramSameEvent->SetBinError(kMass, sqrt(massSum));
      } // check on non-zero mass
    } // loop over mass bins

    for(int kMass=0; kMass<nMassBins; kMass++) {
      harvestedMass[kMass] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
      pi0MassHistogramMixed = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0MassHistogramMixed");
      if(!pi0MassHistogramMixed) {
	cerr << "\n Cannot find harvested pi0MassHistogramMixed" << endl;
	return;
      }
      for(int kMass=0; kMass<nMassBins; kMass++) {
	harvestedMass[kMass] += pi0MassHistogramMixed->GetBinContent(kMass+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kMass=1; kMass<=nMassBins; kMass++) {
      double massSum = harvestedMass[kMass-1];
      if(massSum > 0.0) {
	pi0MassHistogramMixed->SetBinContent(kMass, massSum);
	pi0MassHistogramMixed->SetBinError(kMass, sqrt(massSum));
      } // check on non-zero mass
    } // loop over mass bins	
		
    for(int kAngle=0; kAngle<90; kAngle++) {
      harvestedAngle[kAngle] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
			
      eventAcceptedReactionPlaneAngleHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("eventAcceptedReactionPlaneAngle");
      if(!eventAcceptedReactionPlaneAngleHistogram) {
	cerr << "\n Cannot find eventAcceptedReactionPlaneAngle" << endl;
	return;
      }
			
      for(int kAngle=0; kAngle<90; kAngle++) {
	harvestedAngle[kAngle] += eventAcceptedReactionPlaneAngleHistogram->GetBinContent(kAngle+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kAngle=1; kAngle<=90; kAngle++) {
      double massSum = harvestedAngle[kAngle-1];
      if(massSum > 0.0) {
	eventAcceptedReactionPlaneAngleHistogram->SetBinContent(kAngle, massSum);
	eventAcceptedReactionPlaneAngleHistogram->SetBinError(kAngle, sqrt(massSum));
      } // check on non-zero mass
    } // loop over angle bins
		
    for(int kAngle=0; kAngle<90; kAngle++) {
      harvestedAngle[kAngle] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
			
      pi0AcceptedReactionPlaneAngleHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0AcceptedReactionPlaneAngle");
      if(!pi0AcceptedReactionPlaneAngleHistogram) {
	cerr << "\n Cannot find pi0AcceptedReactionPlaneAngle" << endl;
	return;
      }
			
      for(int kAngle=0; kAngle<90; kAngle++) {
	harvestedAngle[kAngle] += pi0AcceptedReactionPlaneAngleHistogram->GetBinContent(kAngle+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kAngle=1; kAngle<=90; kAngle++) {
      double massSum = harvestedAngle[kAngle-1];
      if(massSum > 0.0) {
	pi0AcceptedReactionPlaneAngleHistogram->SetBinContent(kAngle, massSum);
	pi0AcceptedReactionPlaneAngleHistogram->SetBinError(kAngle, sqrt(massSum));
      } // check on non-zero mass
    } // loop over angle bins
		
    for(int kMass=0; kMass<nMassBins; kMass++) {
      harvestedMass[kMass] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
      etaMassHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("etaMassHistogram");
      if(!etaMassHistogram) {
	cerr << "\n Cannot find harvested etaMassHistogram" << endl;
	return;
      }
      for(int kMass=0; kMass<nMassBins; kMass++) {
	harvestedMass[kMass] += etaMassHistogram->GetBinContent(kMass+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kMass=1; kMass<=nMassBins; kMass++) {
      double massSum = harvestedMass[kMass-1];
      if(massSum > 0.0) {
	etaMassHistogram->SetBinContent(kMass, massSum);
	etaMassHistogram->SetBinError(kMass, sqrt(massSum));
      } // check on non-zero mass
    } // loop over mass bins
	
    for(int kMass=0; kMass<nMassBins; kMass++) {
      harvestedMass[kMass] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
      etaMassHistogramMixed = (TH1D*)parallelRootInputFiles[kFile]->Get("etaMassHistogramMixed");
      if(!etaMassHistogramMixed) {
	cerr << "\n Cannot find harvested etaMassHistogramMixed" << endl;
	return;
      }
      for(int kMass=0; kMass<nMassBins; kMass++) {
	harvestedMass[kMass] += etaMassHistogramMixed->GetBinContent(kMass+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kMass=1; kMass<=nMassBins; kMass++) {
      double massSum = harvestedMass[kMass-1];
      if(massSum > 0.0) {
	etaMassHistogramMixed->SetBinContent(kMass, massSum);
	etaMassHistogramMixed->SetBinError(kMass, sqrt(massSum));
      } // check on non-zero mass
    } // loop over mass bins
		
    for(int kAngle=0; kAngle<nBinsOneD; kAngle++) {
      harvestedAngle[kAngle] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
			
      pi0EtaTrueHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0EtaTrueHistogram");
      if(!pi0EtaTrueHistogram) {
	cerr << "\n Cannot find pi0EtaTrueHistogram" << endl;
	return;
      }
			
      for(int kAngle=0; kAngle<90; kAngle++) {
	harvestedAngle[kAngle] += pi0EtaTrueHistogram->GetBinContent(kAngle+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kAngle=1; kAngle<=90; kAngle++) {
      double massSum = harvestedAngle[kAngle-1];
      if(massSum > 0.0) {
	pi0EtaTrueHistogram->SetBinContent(kAngle, massSum);
	pi0EtaTrueHistogram->SetBinError(kAngle, sqrt(massSum));
      } // check on non-zero mass
    } // loop over angle bins
		
    for(int kAngle=0; kAngle<nBinsOneD; kAngle++) {
      harvestedAngle[kAngle] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
			
      pi0PhiTrueHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0PhiTrueHistogram");
      if(!pi0PhiTrueHistogram) {
	cerr << "\n Cannot find pi0PhiTrueHistogram" << endl;
	return;
      }
			
      for(int kAngle=0; kAngle<90; kAngle++) {
	sumBinCount += pi0PhiTrueHistogram->GetBinContent(kAngle+1);
	harvestedAngle[kAngle] += pi0PhiTrueHistogram->GetBinContent(kAngle+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kAngle=1; kAngle<=90; kAngle++) {
      double massSum = harvestedAngle[kAngle-1];
      if(massSum > 0.0) {
	pi0PhiTrueHistogram->SetBinContent(kAngle, massSum);
	pi0PhiTrueHistogram->SetBinError(kAngle, sqrt(massSum));
      } // check on non-zero mass
    } // loop over angle bins
		
    for(int kAngle=0; kAngle<nBinsOneD; kAngle++) {
      harvestedAngle[kAngle] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
			
      pi0PhiRPTrueHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0PhiRPTrueHistogram");
      if(!pi0PhiRPTrueHistogram) {
	cerr << "\n Cannot find pi0PhiRPTrueHistogram" << endl;
	return;
      }
			
      for(int kAngle=0; kAngle<90; kAngle++) {
	sumBinCount += pi0PhiRPTrueHistogram->GetBinContent(kAngle+1);
	harvestedAngle[kAngle] += pi0PhiRPTrueHistogram->GetBinContent(kAngle+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kAngle=1; kAngle<=90; kAngle++) {
      double massSum = harvestedAngle[kAngle-1];
      if(massSum > 0.0) {
	pi0PhiRPTrueHistogram->SetBinContent(kAngle, massSum);
	pi0PhiRPTrueHistogram->SetBinError(kAngle, sqrt(massSum));
      } // check on non-zero mass
    } // loop over angle bins
		
    //
    // pi0PtTrueHistogram is a pT histogram, not an angle histogram
    // The dimension is set at nBinsOneD
    //
    for(int kAngle=0; kAngle<nBinsOneD; kAngle++) {
      harvestedAngle[kAngle] = 0.0;
    }
    for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
			
      pi0PtTrueHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get("pi0PtTrueHistogram");
      if(!pi0PtTrueHistogram) {
	cerr << "\n Cannot find pi0PtTrueHistogram" << endl;
	return;
      }
			
      for(int kAngle=0; kAngle<nBinsOneD; kAngle++) {
	sumBinCount += pi0PtTrueHistogram->GetBinContent(kAngle+1);
	harvestedAngle[kAngle] += pi0PtTrueHistogram->GetBinContent(kAngle+1);
      }
    } // loop over outputs from parallel jobs
		
    for(int kAngle=1; kAngle<=nBinsOneD; kAngle++) {
      double massSum = harvestedAngle[kAngle-1];
      if(massSum > 0.0) {
	pi0PtTrueHistogram->SetBinContent(kAngle, massSum);
	pi0PtTrueHistogram->SetBinError(kAngle, sqrt(massSum));
      } // check on non-zero mass
    } // loop over angle bins	
		
    char histogramName[200];
    char histogramTitle[200];		
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	sprintf(histogramName, "pi0MassMixedEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Mixed-event #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	for(int kMass=0; kMass<nMassBins; kMass++) {
	  harvestedMass[kMass] = 0.0;
	}
	for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
	  pi0MassEtaPtHistogramMixed[kEta][kPt] = (TH1D*)parallelRootInputFiles[kFile]->Get(histogramName);
	  if(!pi0MassEtaPtHistogramMixed[kEta][kPt]) {
	    cerr << "\n Cannot find harvested " << histogramName << endl;
	    return;
	  }
	  for(int kMass=0; kMass<nMassBins; kMass++) {
	    harvestedMass[kMass] += pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(kMass+1);
	  }
	} // loop over outputs from parallel jobs
				
	for(int kMass=1; kMass<=nMassBins; kMass++) {
	  double massSum = harvestedMass[kMass-1];
	  if(massSum > 0.0) {
	    pi0MassEtaPtHistogramMixed[kEta][kPt]->SetBinContent(kMass, massSum);
	    pi0MassEtaPtHistogramMixed[kEta][kPt]->SetBinError(kMass, sqrt(massSum));
	  } // check on non-zero mass
	} // loop over mass bins
				
	sprintf(histogramName, "pi0MassEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Same-event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	for(int kMass=0; kMass<nMassBins; kMass++) {
	  harvestedMass[kMass] = 0.0;
	}
	for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
	  pi0MassEtaPtHistogram[kEta][kPt] = (TH1D*)parallelRootInputFiles[kFile]->Get(histogramName);
	  if(!pi0MassEtaPtHistogram[kEta][kPt]) {
	    cerr << "\n Cannot find harvested " << histogramName << endl;
	    return;
	  }
	  for(int kMass=0; kMass<nMassBins; kMass++) {
	    harvestedMass[kMass] += pi0MassEtaPtHistogram[kEta][kPt]->GetBinContent(kMass+1);
	  }
	} // loop over outputs from parallel jobs
				
	for(int kMass=1; kMass<=nMassBins; kMass++) {
	  double massSum = harvestedMass[kMass-1];
	  if(massSum > 0.0) {
	    pi0MassEtaPtHistogram[kEta][kPt]->SetBinContent(kMass, massSum);
	    pi0MassEtaPtHistogram[kEta][kPt]->SetBinError(kMass, sqrt(massSum));
	  } // check on non-zero mass
	} // loop over mass bins
				
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  sprintf(histogramName, "pi0MassEtaBin%dPhiBin%dPtBin%d", kEta, kPhi, kPt);
	  sprintf(histogramTitle, "#pi^{0}pi for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt]);
	  for(int kMass=0; kMass<nMassBins; kMass++) {
	    harvestedMass[kMass] = 0.0;
	  }
	  for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
	    pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt] = (TH1D*)parallelRootInputFiles[kFile]->Get(histogramName);
	    if(!pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]) {
	      cerr << "\n Cannot find harvested " << histogramName << endl;
	      return;
	    }
	    for(int kMass=0; kMass<nMassBins; kMass++) {
	      harvestedMass[kMass] += pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetBinContent(kMass+1);
	    }
	  } // loop over outputs from parallel jobs
					
	  for(int kMass=1; kMass<=nMassBins; kMass++) {
	    double massSum = harvestedMass[kMass-1];
	    if(massSum > 0.0) {
	      pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetBinContent(kMass, massSum);
	      pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetBinError(kMass, sqrt(massSum));
	    } // check on non-zero mass
	  } // loop over mass bins					
					
	  for(unsigned int kRP=0; kRP<RPClass; kRP++) {
	    for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	      for(unsigned int kCent=0; kCent<CentClass; kCent++) {
								
		if(kPhi == 0) { // check on kPhi = 0 to set up histograms which do not depend on phi angle
		  sprintf(histogramName, "pi0MassSameEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
		  sprintf(histogramTitle, "Same event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			  lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
									
		  for(int kMass=0; kMass<nMassBins; kMass++) {
		    harvestedMass[kMass] = 0.0;
		  }
		  for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
		    pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent] = (TH1D*)parallelRootInputFiles[kFile]->Get(histogramName);
		    if(!pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]) {
		      cerr << "\n Cannot find harvested " << histogramName << endl;
		      return;
		    }
		    for(int kMass=0; kMass<nMassBins; kMass++) {
		      harvestedMass[kMass] += pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(kMass+1);
		    }
		  } // loop over outputs from parallel jobs
									
		  for(int kMass=1; kMass<=nMassBins; kMass++) {
		    double massSum = harvestedMass[kMass-1];
		    if(massSum > 0.0) {
		      pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->SetBinContent(kMass, massSum);
		      pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->SetBinError(kMass, sqrt(massSum));
		    } // check on non-zero mass
		  } // loop over mass bins
										
		  sprintf(histogramName, "pi0MassMixedEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
		  sprintf(histogramTitle, "Mixed event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			  lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
									
		  for(int kMass=0; kMass<nMassBins; kMass++) {
		    harvestedMass[kMass] = 0.0;
		  }
		  for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
		    pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] = (TH1D*)parallelRootInputFiles[kFile]->Get(histogramName);
		    if(!pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]) {
		      cerr << "\n Cannot find harvested " << histogramName << endl;
		      return;
		    }
		    for(int kMass=0; kMass<nMassBins; kMass++) {
		      harvestedMass[kMass] += pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(kMass+1);
		    }
		  } // loop over outputs from parallel jobs
									
		  for(int kMass=1; kMass<=nMassBins; kMass++) {
		    double massSum = harvestedMass[kMass-1];
		    if(massSum > 0.0) {
		      pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->SetBinContent(kMass, massSum);
		      pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->SetBinError(kMass, sqrt(massSum));
		    } // check on non-zero mass
		  } // loop over mass bins
									
		} // check on kPhi = 0 to set up histograms which do not depend on phi angle
								
		sprintf(histogramName, "pi0MassSameEtaBin%dPhiBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPhi, kPt, kRP, kZVert, kCent);
		sprintf(histogramTitle, "Same event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);								
								
		for(int kMass=0; kMass<nMassBins; kMass++) {
		  harvestedMass[kMass] = 0.0;
		}
		for(unsigned int kFile=0; kFile<nFilesToProcess; kFile++) {
		  dummyMassHistogram = (TH1D*)parallelRootInputFiles[kFile]->Get(histogramName);
		  if(!dummyMassHistogram) {
		    cerr << "\n Cannot find harvested " << histogramName << endl;
		    return;
		  }
		  for(int kMass=0; kMass<nMassBins; kMass++) {
		    harvestedMass[kMass] += dummyMassHistogram->GetBinContent(kMass+1);
		  }
		} // loop over outputs from parallel jobs
			
		for(int kMass=1; kMass<=nMassBins; kMass++) {
		  double massSum = harvestedMass[kMass-1];
		  if(massSum > 0.0) {
		    pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetBinContent(kMass, massSum);
		    pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetBinError(kMass, sqrt(massSum));
		  } // check on non-zero mass
		} // loop over mass bins
							
	      }  // loop over Cent classes
	    }  // loop over ZVert classes
	  } // loop over RP classes					
	} // loop over phi bins
      } // loop over pt bins	
    } // loop over eta bins

    for(unsigned int kFile=0; kFile<nFilesToProcess-1; kFile++) {
      if(parallelRootInputFiles[kFile]) {
	// parallelRootInputFiles[kFile]->Close();	
	cout << "\n Closed file number " << kFile;
      } // loop over list of input files
      cout << endl;		
    }

  } // harvesting option
	
  if(writeHistogramFile) {
    TFile *flowPlotsFile;
		
    int useRunNumber = runNumber;
    if(toyModel)
      useRunNumber = 0;  
		
    char outputFileName[200];
    if(iOption != 31) {
      sprintf(outputFileName, "pi0FlowPlots_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_EtaLimit%4.2f.root", useRunNumber, lowCent, highCent, lowPtCut, highPtCut, highEtaLimit);
    }
    else {
      sprintf(outputFileName, rootOutputFileName);
    }
		
    char outputFileTitle[200];
    sprintf(outputFileTitle, "pi0 Flow Plots for Run %d, Centralities %d to %d, pT %3.1f to %3.1f, |eta| < %3.1f", runNumber, lowCent, highCent, lowPtCut, highPtCut, highEtaLimit);
    flowPlotsFile = new TFile(outputFileName, "recreate", outputFileTitle);
	
    _Avgpi0->Write();
    _Avgpi0_dEtadPhi->Write();
    pi0MassHistogram->Write();	
 //   pi0MassHistogramMixed->Write();
    pi0MassHistogramSameEvent->Write();
  //  etaMassHistogram->Write();
  //  etaMassHistogramMixed->Write();       	
  //  eventAcceptedReactionPlaneAngleHistogram->Write();
  //  pi0AcceptedReactionPlaneAngleHistogram->Write();
		
    pi0EtaTrueHistogram->Write();
    pi0PhiTrueHistogram->Write();
  //  pi0PhiRPTrueHistogram->Write();
    pi0PtTrueHistogram->Write();
		
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	//pi0MassEtaPtHistogramMixed[kEta][kPt]->Write();
	//pi0MassEtaPtHistogram[kEta][kPt]->Write();
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	//  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->Write();
	  for(unsigned int kRP=0; kRP<RPClass; kRP++) {
	    for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	      for(unsigned int kCent=0; kCent<CentClass; kCent++) {
		if(kPhi == 0) { // check on kPhi = 0 to set up histograms which do not depend on phi angle
		//  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->Write();
		//  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->Write();
									
		} // check on kPhi = 0 to set up histograms which do not depend on phi angle
								
		//pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->Write();
								
	      }
	    }
	  }
	} // loop over phi bins		
      } // loop over pt bins		
    } // loop over eta bins
		
    flowPlotsFile->Close();
		
    cout << "\n Wrote histograms to output file " << outputFileName;
    cout << endl;
		
    if(iOption == 31) {
      cout << "\n Finished processing for this parallel job\n";
      return;
    }
		
  } // check on writing histogram file
	
  if(readHistogramFile) {

    int useRunNumber = runNumber;
    if(toyModel)
      useRunNumber = 0;

    char inputFileName[200];
    sprintf(inputFileName, "pi0FlowPlots_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_EtaLimit%4.2f.root", useRunNumber, lowCent, highCent, lowPtCut, highPtCut, highEtaLimit);
    TFile *flowPlotsFile = new TFile(inputFileName);

 

    pi0MassHistogram = (TH1D*)flowPlotsFile->Get("pi0MassHistogram");
    if(!pi0MassHistogram) {
      cerr << "\n Cannot find pi0MassHistogram" << endl;
      return;
    }
       
    pi0MassHistogramSameEvent = (TH1D*)flowPlotsFile->Get("pi0MassHistogramSameEvent");
    if(!pi0MassHistogramSameEvent) {
      cerr << "\n Cannot find pi0MassHistogramSameEvent" << endl;
      return;
    }		

    pi0MassHistogramMixed = (TH1D*)flowPlotsFile->Get("pi0MassHistogramMixed");
    if(!pi0MassHistogramMixed) {
      cerr << "\n Cannot find pi0MassHistogramMixed" << endl;
      return;
    }
		
    eventAcceptedReactionPlaneAngleHistogram = (TH1D*)flowPlotsFile->Get("eventAcceptedReactionPlaneAngle");
    if(!eventAcceptedReactionPlaneAngleHistogram) {
      cerr << "\n Cannot find eventAcceptedReactionPlaneAngle" << endl;
      return;
    }
		
    pi0AcceptedReactionPlaneAngleHistogram = (TH1D*)flowPlotsFile->Get("pi0AcceptedReactionPlaneAngle");
    if(!pi0AcceptedReactionPlaneAngleHistogram) {
      cerr << "\n Cannot find pi0AcceptedReactionPlaneAngle" << endl;
      return;
    }
    
    etaMassHistogram = (TH1D*)flowPlotsFile->Get("etaMassHistogram");
    if(!etaMassHistogram) {
      cerr << "\n Unable to find etaMassHistogram histogram in input file";
      cerr << endl;
      return;
    }
 
    etaMassHistogramMixed = (TH1D*)flowPlotsFile->Get("etaMassHistogramMixed");
    if(!etaMassHistogramMixed) {
      cerr << "\n Unable to find etaMassHistogramMixed histogram in input file";
      cerr << endl;
      if(iOption == 20 || iOption == -20)
	return;
    }

    pi0EtaTrueHistogram = (TH1D*)flowPlotsFile->Get("pi0EtaTrueHistogram");
    if(!pi0EtaTrueHistogram) {
      cerr << "\n Cannot find pi0EtaTrueHistogram" << endl;
      return;
    }

    pi0PhiTrueHistogram = (TH1D*)flowPlotsFile->Get("pi0PhiTrueHistogram");
    if(!pi0PhiTrueHistogram) {
      cerr << "\n Cannot find pi0PhiTrueHistogram" << endl;
      return;
    }
		
    pi0PhiRPTrueHistogram = (TH1D*)flowPlotsFile->Get("pi0PhiRPTrueHistogram");
    if(!pi0PhiRPTrueHistogram) {
      cerr << "\n Cannot find pi0PhiTrueHistogram" << endl;
      return;
    }		

    pi0PtTrueHistogram = (TH1D*)flowPlotsFile->Get("pi0PtTrueHistogram");
    if(!pi0PtTrueHistogram) {
      cerr << "\n Cannot find pi0PtTrueHistogram" << endl;
      return;
    }
			
    char histogramName[200];
    char histogramTitle[200];		
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	sprintf(histogramName, "pi0MassMixedEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Mixed-event #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogramMixed[kEta][kPt] = (TH1D*)flowPlotsFile->Get(histogramName);
	if(!pi0MassEtaPtHistogramMixed[kEta][kPt]) {
	  cerr << "\n Cannot find " <<  histogramName << " with title " << histogramTitle << endl;
	  return;
	}		
	sprintf(histogramName, "pi0MassEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Same-event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogram[kEta][kPt] = (TH1D*)flowPlotsFile->Get(histogramName);
	if(!pi0MassEtaPtHistogram[kEta][kPt]) {
	  cerr << "\n Cannot find " <<  histogramName << " with title " << histogramTitle << endl;
	  return;
	}		
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  sprintf(histogramName, "pi0MassEtaBin%dPhiBin%dPtBin%d", kEta, kPhi, kPt);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt] = (TH1D*)flowPlotsFile->Get(histogramName);
	  sprintf(histogramTitle, "#pi^{0}pi for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt]);
	  if(!pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]) {
	    cerr << "\n Cannot find " <<  histogramName << " with title " << histogramTitle << endl;
	    return;
	  }
	  for(unsigned int kRP=0; kRP<RPClass; kRP++) {
	    for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	      for(unsigned int kCent=0; kCent<CentClass; kCent++) {

		if(kPhi == 0) { // check on kPhi = 0 to set up histograms which do not depend on phi angle
		  sprintf(histogramName, "pi0MassSameEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
		  sprintf(histogramTitle, "Same event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			  lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent] = (TH1D*)flowPlotsFile->Get(histogramName);
		  if(!pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]) {
		    cerr << "\n Cannot find " <<  histogramName << " with title " << histogramTitle << endl;
		    return;
		  }

		  sprintf(histogramName, "pi0MassMixedEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
		  sprintf(histogramTitle, "Mixed event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			  lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] = (TH1D*)flowPlotsFile->Get(histogramName);
		  if(!pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]) {
		    cerr << "\n Cannot find " <<  histogramName << " with title " << histogramTitle << endl;
		    return;
		  }

		} // check on kPhi = 0 to set up histograms which do not depend on phi angle

		sprintf(histogramName, "pi0MassSameEtaBin%dPhiBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPhi, kPt, kRP, kZVert, kCent);
		sprintf(histogramTitle, "Same event #pi^{0} for %5.2f < |#eta| < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent] = (TH1D*)flowPlotsFile->Get(histogramName);
		if(!pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]) {
		  cerr << "\n Cannot find " <<  histogramName << " with title " << histogramTitle << endl;
		  return;
		}

	      }  // loop over Cent classes
	    }  // loop over ZVert classes
	  } // loop over RP classes					
	} // loop over phi bins
      } // loop over pt bins	
    } // loop over eta bins

    /*	
      if(flowPlotsFile) {
      flowPlotsFile->Close();
      delete flowPlotsFile;
      }
    */

  } // check on reading histogram file
	
  useEventsProcessed = int(eventAcceptedReactionPlaneAngleHistogram->GetSum());
  if(usingGapAnglePair)
    useEventsProcessed /= 2;
	
  TCanvas *c1 = new TCanvas("c1", "Plotting Single Pi0", 200, 10, 700, 500);
  //
  // Use ROOT's gStyle function to set up plot options
  //
  gStyle->SetOptStat(1110);
  gStyle->SetStatTextColor(kBlue);
  gStyle->SetFuncColor(kBlue);
  gStyle->SetFuncWidth(2);
  gStyle->SetOptFit(1111);
  gStyle->SetFitFormat("6.5g");
	
  c1->SetFillColor(kWhite);	

  int kOption = iOption;
  if(iOption < 0)
    kOption = -iOption;
	
  if(kOption > 0 && kOption < 6) { // plot the 9 azimuthal distributions for a given eta and pt bin
		
    //
    // Set up utility histograms
    //
    TH1D *pi0MassEtaPhiPtHistogramMixed[NETABINS][NPHIBINS][NPTBINS];
    TH1D *pi0MassEtaPtHistogramCopyMixed[NETABINS][NPTBINS];
    TH1D *pi0MassEtaPhiPtHistogramSubtracted[NETABINS][NPHIBINS][NPTBINS];
    TH1D *pi0MassEtaPtHistogramSubtracted[NETABINS][NPTBINS];
		
    float subtractedYields[NETABINS][NPHIBINS][NPTBINS];
    float subtractedYieldErrors[NETABINS][NPHIBINS][NPTBINS];

    float binLowForYieldArray[NETABINS][NPTBINS];
    float binHighForYieldArray[NETABINS][NPTBINS];
    float mixedEventNormalizationFactor2DArray[NETABINS][NPTBINS];
    float mixedEventNormalizationFactor3DArray[NETABINS][NPHIBINS][NPTBINS];
    float mixedEventNormalizationErrorFactor2DArray[NETABINS][NPTBINS];
    float mixedEventNormalizationErrorFactor3DArray[NETABINS][NPHIBINS][NPTBINS];
	
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++ ) {
	binLowForYieldArray[kEta][kPt] = 0.0;
	binHighForYieldArray[kEta][kPt] = 0.0;
	mixedEventNormalizationFactor2DArray[kEta][kPt] = 0.0;
	mixedEventNormalizationErrorFactor2DArray[kEta][kPt] = 0.0;
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  subtractedYields[kEta][kPhi][kPt] = 0.0;
	  subtractedYieldErrors[kEta][kPhi][kPt] = 0.0;
	  mixedEventNormalizationFactor3DArray[kEta][kPhi][kPt] = 0.0;
	  mixedEventNormalizationErrorFactor3DArray[kEta][kPhi][kPt] = 0.0;
	}
      }
    }
		
    char histogramName[200];
    char histogramTitle[200];
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	sprintf(histogramName, "pi0MassSubtactedEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Background-subtracted (no classes) #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetYTitle(countsPerBin);
	sprintf(histogramName, "pi0MassCopyMixedEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Copy of Mixed-Event #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogramCopyMixed[kEta][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	pi0MassEtaPtHistogramCopyMixed[kEta][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	pi0MassEtaPtHistogramCopyMixed[kEta][kPt]->SetYTitle(countsPerBin);
				
	//
	// Partition by azimuthal angle in reaction plane
	//
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
					
	  sprintf(histogramName, "pi0MassMixedEtaBin%dPhiBin%dPtBin%d", kEta, kPhi, kPt);
	  sprintf(histogramTitle, "Mixed-event #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt]);
	  pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	  pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	  pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->SetYTitle(countsPerBin);
					
	  sprintf(histogramName, "pi0MassSubtractedEtaPhiBin%dPhiBin%dPtBin%d", kEta, kPhi, kPt);
	  sprintf(histogramTitle, "Subtracted #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt]);
	  pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	  pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	  pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetYTitle(countsPerBin);
					
	} // loop over phi bins	
      } // loop over pt bins	
    } // loop over eta bins
	
    unsigned int kPtLow = 0;
    unsigned int kPtHigh = 1;
    if(kOption == 2) {
      kPtLow = 1;
      kPtHigh = 2;
    }
    if(kOption == 3) {
      kPtLow = 2;
      kPtHigh = 3;
    }
    if(kOption == 4) {
      kPtLow = 3;
      kPtHigh = 4;
    }
    if(kOption == 5) {
      kPtLow = 0;
      kPtHigh = 3;
    }
    //
    // Obtain the background-subtracted yields
    //

    unsigned int kEtaLow = 0;
    unsigned int kEtaHigh = NETABINS;

    for(unsigned int kEta=kEtaLow; kEta<kEtaHigh; kEta++) {
      for(unsigned int kPt=kPtLow; kPt<kPtHigh; kPt++) {
	c1->Clear();
	c1->Divide(NPHIBINS/3,3);
	unsigned int kPanel = 1;

	//
	// Get normalization factor for unpartitioned histograms
	//
	double sameEventCountUnPartitioned = 0.0;
	double mixedEventCount = 0.0;
				
	for(int kBin=1; kBin<nMassBins; kBin++) {
	  double binCenter = pi0MassEtaPtHistogramMixed[kEta][kPt] ->GetBinCenter(kBin);
	  if(binCenter >= lowFalsePairMassCut && binCenter <= highFalsePairMassCut) {
	    sameEventCountUnPartitioned += pi0MassEtaPtHistogram[kEta][kPt]->GetBinContent(kBin);
	    mixedEventCount += pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(kBin);
	  } // check if mass bin is within the normalization region
	} // loop over mass bins
				
	if(mixedEventCount > 0.0 && sameEventCountUnPartitioned > 0 ) { // background subtraction for unpartitioned yields
	  double sameEventYield = 0.0;
	  double sameEventYieldError = 0.0;
					
	  double sameEventTotal = 0.0;
	  double normalizationFactorMixed = sameEventCountUnPartitioned/mixedEventCount;
	  mixedEventNormalizationFactor2DArray[kEta][kPt] = normalizationFactorMixed;
	  mixedEventNormalizationErrorFactor2DArray[kEta][kPt] = sqrt(1.0/sameEventCountUnPartitioned + 1.0/mixedEventCount);
	  for(int kBin=1; kBin<=nMassBins; kBin++) {    
	    double sameEventContent = pi0MassEtaPtHistogram[kEta][kPt]->GetBinContent(kBin);
	    double mixedEventContent = pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(kBin);
	    double mixedEventFractionalErrorSquared = 0.0;
	    if(mixedEventContent > 0.0)
	      mixedEventFractionalErrorSquared = 1.0/mixedEventContent;
	    double mixedEventNormalizedContent = normalizationFactorMixed*mixedEventContent;
	    pi0MassEtaPtHistogramCopyMixed[kEta][kPt]->SetBinContent(kBin, mixedEventNormalizedContent);
	    double combinedErrorSquared = sameEventContent + mixedEventNormalizedContent*mixedEventNormalizedContent*mixedEventFractionalErrorSquared;
	    sameEventYieldError += combinedErrorSquared;
	    double binCenter = pi0MassEtaPtHistogram[kEta][kPt]->GetBinCenter(kBin);
	    double sameEventSubtracted = sameEventContent - mixedEventNormalizedContent;
	    double sameEventSubtractedError = sqrt(combinedErrorSquared);
						
	    if(binCenter >= subtractedStart && binCenter <= subtractedEnd) {
	      sameEventTotal += sameEventContent;
	      sameEventYield += sameEventSubtracted;
	    }
	    if(sameEventContent > 0.0) {
	      pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetBinContent(kBin, sameEventSubtracted);
	      pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetBinError(kBin, sameEventSubtractedError);
	    }
	  } // loop over mixed event histogram
					
	}  // background subtraction for unpartitioned yields
			
	//
	// Partition according to the azimuthal angle in the reaction plane
	//
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
				
	  //
	  // Get normalization factor for partitioned histograms
	  //
	  double sameEventCount = 0.0;
				
	  for(int kBin=1; kBin<nMassBins; kBin++) {
	    double binCenter = pi0MassEtaPtHistogramMixed[kEta][kPt] ->GetBinCenter(kBin);
	    if(binCenter >= lowFalsePairMassCut && binCenter <= highFalsePairMassCut) {
	      sameEventCount += pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetBinContent(kBin);
	    } // check if mass bin is within the normalization region
	  } // loop over mass bins
		
	  if(mixedEventCount > 0.0 && sameEventCount > 0.0) {
					
	    double normalizationFactorMixed = sameEventCount/mixedEventCount;
	    mixedEventNormalizationFactor3DArray[kEta][kPhi][kPt] = normalizationFactorMixed;
	    mixedEventNormalizationErrorFactor3DArray[kEta][kPhi][kPt] = sqrt(1.0/sameEventCount + 1.0/mixedEventCount);
	    double normalizationFactorMixedSquared = normalizationFactorMixed*normalizationFactorMixed;
	    for(int kBin=1; kBin<=nMassBins; kBin++) {
	      double sameEventContent = pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetBinContent(kBin);
	      double mixedEventContent = pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(kBin);
	      double mixedEventFractionalErrorSquared = 0.0;
	      if(mixedEventContent > 0.0)
		mixedEventFractionalErrorSquared = 1.0/mixedEventContent;
	      double mixedEventNormalizedContent = normalizationFactorMixed*mixedEventContent;
	      pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->SetBinContent(kBin, mixedEventNormalizedContent);
	      double combinedErrorSquared = sameEventContent + mixedEventContent*normalizationFactorMixedSquared;
	      double sameEventSubtracted = sameEventContent - mixedEventNormalizedContent;
	      double sameEventSubtractedError = sqrt(combinedErrorSquared);
											
	      if(sameEventContent > 0.0) {
		pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetBinContent(kBin, sameEventSubtracted);
		pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetBinError(kBin, sameEventSubtractedError);
	      }

	    } // loop over mixed event histogram
					
	  } // check on mixed event > 0

	  //
	  // Plot the results
	  //
	  c1->cd(kPanel);
	  float fMaxHistValueMixed = 1.20*pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->GetBinContent(pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->GetMaximumBin());
	  float fMaxHistValueSameEvent = 1.20*pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetBinContent(pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetMaximumBin());

	  float fMaxHistValue = fMaxHistValueMixed;
	  if(fMaxHistValueSameEvent > fMaxHistValueMixed)
	    fMaxHistValue = fMaxHistValueSameEvent;
		
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetStats(0);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetMinimum(0);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetMaximum(fMaxHistValue);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->Draw();
	  if(kPanel == 1) {

	    char labelBuffer1[200];
	    if(realData)
	      sprintf(labelBuffer1, "Pb-Pb #sqrt{s} = 2.76 TeV, Run %d", runNumber);
	    if(hydjetModel)
	      sprintf(labelBuffer1, "HYDJET sim: Pb-Pb #sqrt{s} = 2.76 TeV");
	    if(pythiaModel)
	      sprintf(labelBuffer1, "Pythia sim: pp #sqrt{s} = 7.0 TeV");
	    if(toyModel)
	      sprintf(labelBuffer1, "Toy Model Simulation");

	    TLatex *lhcPbPb = new TLatex(0.014, 0.92*fMaxHistValue, labelBuffer1);
	    lhcPbPb->SetTextColor(2);
	    lhcPbPb->SetTextSize(0.05);
	    lhcPbPb->Draw();

	    if(realData || hydjetModel) {
	      char centBuffer1[200];
	      sprintf (centBuffer1, "Centralities %d to %d", lowCent, highCent);
	      TLatex *runB1 = new TLatex(0.014, 0.82*fMaxHistValue, centBuffer1);
	      runB1->SetTextColor(2);
	      runB1->SetTextSize(0.045);
	      runB1->Draw();
	    }
	    
	    if(!useReactionPlaneAngle) {
	      TLatex *noRP1 = new TLatex(0.014, 0.37*fMaxHistValue, "RP NOT USED!");
	      noRP1->SetTextColor(6);
	      noRP1->SetTextSize(0.05);
	      noRP1->Draw();
	    }

	  } // check on first panel

	  pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->SetFillColor(kYellow);
	  pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->SetLineWidth(2);
	  pi0MassEtaPhiPtHistogramMixed[kEta][kPhi][kPt]->Draw("same");
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetLineColor(kBlue);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetLineWidth(2);
	  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->Draw("same");

	  if(mixedEventCount > 0.0) {			

	    //
	    // Fit the background subtracted result
	    //
	    TF1 *fitFcn =  new TF1("fitFcn", gaussPeak, subtractedStart, subtractedEnd, 3);
	    fitFcn->SetParName(0, "peak Amplitude");
	    fitFcn->SetParName(1, "peak Centroid");
	    fitFcn->SetParName(2, "peak Sigma");
	    fitFcn->SetParameters(fMaxHistValue, 0.13, 0.02);

	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->Fit("fitFcn", "q0", "", subtractedStart, subtractedEnd);
	    float peakCentroid = fitFcn->GetParameter(1);
	    float peakCentroidError = fitFcn->GetParError(1);
	    float peakWidth = fabs(fitFcn->GetParameter(2));
	    float peakWidthError = fitFcn->GetParError(2);

	    TLatex *tSB2 = new TLatex(0.014, 0.75*fMaxHistValue, "Mass fit results (not used for v_{2} fitting)");
	    tSB2->SetTextColor(2);
	    tSB2->SetTextSize(0.043);
	    tSB2->Draw();

	    char signalBuffer3[200];
	    sprintf(signalBuffer3, "Mass = %5.1f #pm %5.1f MeV", 1000.0*peakCentroid, 1000.0*peakCentroidError);
	    TLatex *tSB3 = new TLatex(0.014, 0.68*fMaxHistValue, signalBuffer3);
	    tSB3->SetTextColor(2);
	    tSB3->SetTextSize(0.040);
	    tSB3->Draw();

	    char signalBuffer4[200];
	    sprintf(signalBuffer4, "Width = %5.1f #pm %5.1f MeV", 1000.0*peakWidth, 1000.0*peakWidthError);
	    TLatex *tSB4 = new TLatex(0.014, 0.61*fMaxHistValue, signalBuffer4);
	    tSB4->SetTextColor(2);
	    tSB4->SetTextSize(0.040);
	    tSB4->Draw();

	  } // check if mixed event yield > 0
				
	  kPanel++;
			
	} // loop over phi bins, for this eta and pt range
	
	if(iOption > 0) {
					
	  int useRunNumber = runNumber;
	  if(toyModel)
	    useRunNumber = 0;
					
	  //
	  // Partitioned yields before background subtraction (nine panels of azimuth at this eta and pt bin)
	  //
	  char graphOutputFileName[200];
	  sprintf(graphOutputFileName, "pi0FlowYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // C macro
	  sprintf(graphOutputFileName, "pi0FlowYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // gif file
	  sprintf(graphOutputFileName, "pi0FlowYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // pdf file
				 
	  TLine *baseLine = new TLine(0.0, 0.0, maximumPi0MassForHistogram, 0.0);
	  baseLine->SetLineColor(kBlack);
	  baseLine->SetLineWidth(2);
				 
	  //
	  // Fit the unpartitioned background subtracted result for this eta and pt range
	  //
	  TF1 *fitFcnU =  new TF1("fitFcnU", gaussPeak, subtractedStart, subtractedEnd, 3);
	  fitFcnU->SetParName(0, "peak Amplitude");
	  fitFcnU->SetParName(1, "peak Centroid");
	  fitFcnU->SetParName(2, "peak Sigma");
	  float fMaxHistValueU = 1.30*pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinContent(pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMaximumBin());
	  fitFcnU->SetParameters(fMaxHistValueU, 0.13, 0.02);
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->Fit("fitFcnU", "q0", "", subtractedStart, subtractedEnd);
	  float peakCentroidU = fitFcnU->GetParameter(1);
	  float peakWidthU = fabs(fitFcnU->GetParameter(2));
	  float binLowForYield = peakCentroidU - subtractedYieldWidthFactor*peakWidthU;
	  float binHighForYield = peakCentroidU + subtractedYieldWidthFactor*peakWidthU;
	  if(useAsymmetricMassCuts) {
	    binLowForYield = peakCentroidU - lowerAsymmetricWidthFactor*peakWidthU;
	    binHighForYield = peakCentroidU + upperAsymmetricWidthFactor*peakWidthU;
	  }
	  binLowForYieldArray[kEta][kPt] = binLowForYield;
	  binHighForYieldArray[kEta][kPt] = binHighForYield;
	  cout << "\n kEta " << kEta << ", kPt " << kPt << " limits before " << binLowForYieldArray[kEta][kPt] << " - " << binHighForYieldArray[kEta][kPt];
	  if(useHalfWidth) {
	    float differenceLowHigh = binHighForYieldArray[kEta][kPt] - binLowForYieldArray[kEta][kPt];
	    binHighForYieldArray[kEta][kPt] = binLowForYieldArray[kEta][kPt] + 0.5*differenceLowHigh;
	  }
	  cout << "; limits after " << binLowForYieldArray[kEta][kPt] << " - " << binHighForYieldArray[kEta][kPt];
					
	  for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	    c1->cd(kPhi + 1);
	    float fMaxHistValue = 1.30*pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinContent(pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximumBin());
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetMaximum(fMaxHistValue);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetStats(0);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetMarkerStyle(20);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetMarkerColor(2);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetMarkerSize(0.5);
					
	    float mixedEventYield = 0.0;
	    float sumSubtractedYield = 0.0;
	    float sumSubtractedError = 0.0;
	    for(int kBin=1; kBin<=nMassBins; kBin++) {
	      double binCenter = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinCenter(kBin);
	      if(binCenter >= binLowForYield && binCenter <= binHighForYield) {
		sumSubtractedYield += pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinContent(kBin);
		double binError = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinError(kBin);
		sumSubtractedError += binError*binError;
		mixedEventYield += pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(kBin);
	      } // check mass bin
	    } // sum over mass bins
	    sumSubtractedError = sqrt(sumSubtractedError);
	    subtractedYields[kEta][kPhi][kPt] = sumSubtractedYield;
	    float mixedEventYieldError = mixedEventNormalizationErrorFactor3DArray[kEta][kPhi][kPt]*
	      mixedEventNormalizationFactor3DArray[kEta][kPhi][kPt]*mixedEventYield;

	    subtractedYieldErrors[kEta][kPhi][kPt] = sqrt(sumSubtractedError*sumSubtractedError +
 							  mixedEventYieldError*mixedEventYieldError);
						
	    //
	    // Fit the background subtracted result
	    //
	    TF1 *fitFcn =  new TF1("fitFcn", gaussPeak, subtractedStart, subtractedEnd, 3);
	    fitFcn->SetParName(0, "peak Amplitude");
	    fitFcn->SetParName(1, "peak Centroid");
	    fitFcn->SetParName(2, "peak Sigma");
	    fitFcn->SetParameters(fMaxHistValue, 0.13, 0.02);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->Fit("fitFcn", "", "", subtractedStart, subtractedEnd);

	    float peakCentroid = fitFcn->GetParameter(1);
	    float peakCentroidError = fitFcn->GetParError(1);
	    float peakWidth = fabs(fitFcn->GetParameter(2));
	    float peakWidthError = fitFcn->GetParError(2);
						
	    char signalBuffer1[200];
	    sprintf(signalBuffer1, "Mass = %5.1f #pm %5.1f MeV", 1000.0*peakCentroid, 1000.0*peakCentroidError);
	    TLatex *tSB1 = new TLatex(0.014, 0.85*fMaxHistValue, signalBuffer1);
	    tSB1->SetTextColor(4);
	    tSB1->SetTextSize(0.035);
	    tSB1->Draw();
						
	    char signalBuffer2[200];
	    sprintf(signalBuffer2, "Width = %5.1f #pm %5.1f MeV", 1000.0*peakWidth, 1000.0*peakWidthError);
	    TLatex *tSB2 = new TLatex(0.014, 0.75*fMaxHistValue, signalBuffer2);
	    tSB2->SetTextColor(4);
	    tSB2->SetTextSize(0.035);
	    tSB2->Draw();
						
	    char signalBuffer3[200];
	    sprintf(signalBuffer3, "Yield = %d #pm %d", int(sumSubtractedYield), int(sumSubtractedError));
	    TLatex *tSB3 = new TLatex(0.175, 0.85*fMaxHistValue, signalBuffer3);
	    tSB3->SetTextColor(2);
	    tSB3->SetTextSize(0.050);
	    tSB3->Draw();

	    TLatex *tSB4 = new TLatex(0.175, 0.75*fMaxHistValue, "Used for v_{2} fitting");
	    tSB4->SetTextColor(2);
	    tSB4->SetTextSize(0.040);
	    tSB4->Draw();
						
	    baseLine->Draw();
			
	    float lowY = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMinimum();
	    float highY = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximum();
	    TLine *lowYieldCut = new TLine(binLowForYield, lowY, binLowForYield, highY);
	    lowYieldCut->SetLineColor(kMagenta);
	    lowYieldCut->SetLineWidth(1);
	    lowYieldCut->SetLineStyle(3);
	    lowYieldCut->Draw();
			
	    TLine * highYieldCut = new TLine(binHighForYield, lowY, binHighForYield, highY);
	    highYieldCut->SetLineColor(kMagenta);
	    highYieldCut->SetLineWidth(1);
	    highYieldCut->SetLineStyle(3);
	    highYieldCut->Draw();
			
	  } // loop over phi bins
				 
	  //
	  // Partitioned yields after background subtraction (nine panels of azimuth at this eta and pt bin)
	  //
	  sprintf(graphOutputFileName, "pi0FlowSubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // C macro
	  sprintf(graphOutputFileName, "pi0FlowSubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // gif file
	  sprintf(graphOutputFileName, "pi0FlowSubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // pdf file
				 
	  c1->Clear();
				 
	  //
	  // Plot of flow fit at this eta and pt bin (one panel)
	  //
				 
	  c1->cd(1);
	  float xPlot[NPHIBINS];
	  float yPlot[NPHIBINS];
	  float xPlotErrors[NPHIBINS];
	  float yPlotErrors[NPHIBINS];
	  float yMax = 0.0;
	  float yMin = 1.0e+30;
	  for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	    xPlot[kPhi] = 0.5*(lowPhiBin[kPhi] + highPhiBin[kPhi]);
	    xPlotErrors[kPhi] = 0.0;
	    yPlot[kPhi] = subtractedYields[kEta][kPhi][kPt];
	    if(yPlot[kPhi] > yMax)
	      yMax = yPlot[kPhi];
	    if(yPlot[kPhi] < yMin)
	      yMin = yPlot[kPhi];
	    yPlotErrors[kPhi] = subtractedYieldErrors[kEta][kPhi][kPt];
	  }
			
	  float yMinDefault = yMin/2.5;
	  float yMaxDefault = yMax*1.7;
 
	  int iMinY = yMin/100.0;
	  yMin = 100.0*(iMinY - 2);
	  if(yMin < 0.0)
	    yMin = 0.0;

	  if(yMin < yMinDefault)
	    yMin = yMinDefault;

	  int iMaxY = yMax/100.0;
	  if(iMaxY < 5)
	    yMax = 100.0*(iMaxY + 2);
	  else
	    yMax = 100.0*(iMaxY + 4);
				 
	  if(yMax > yMaxDefault)
	    yMax = yMaxDefault;

	  if(graphFlow)
	    delete graphFlow;
				 
	  graphFlow = new TGraphErrors(NPHIBINS, xPlot, yPlot, xPlotErrors, yPlotErrors);
	  graphFlow->SetLineColor(1);
	  graphFlow->SetLineWidth(2);
	  graphFlow->SetMarkerColor(4);
	  graphFlow->SetMarkerStyle(20);
	  graphFlow->SetMarkerSize(1.25);
	  char graphTitle[200];
	  if(toyModel) {
	    sprintf(graphTitle, "Toy Model #pi^{0} With v_{2} Flow: %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		    lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	  }
	  if(realData) {
	    sprintf(graphTitle, "#pi^{0} With v_{2} Flow: %d < Centrality < %d, %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		    lowCent, highCent, lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	  }
	  graphFlow->SetTitle(graphTitle);
	  graphFlow->GetXaxis()->SetTitle("#Phi_{Lab} _ #Phi_{RP} (radians)");	
	  graphFlow->GetYaxis()->SetTitle("Background Subtracted Yield");	
	  graphFlow->GetXaxis()->SetLimits(lowPhiBin[0], highPhiBin[NPHIBINS - 1]);
	  cout << "\n First: yMin " << yMin << " yMax " << yMax << " iMinY " << iMinY << " iMaxY " << iMaxY;
	  graphFlow->SetMinimum(yMin);
	  graphFlow->SetMaximum(yMax);										 
	  graphFlow->Draw("AP");
	  c1->SetGridx();
	  c1->SetGridy();

	  if(noFlowFitFcn)
	    delete noFlowFitFcn;
					
	  noFlowFitFcn = new TF1("noFlowFitFcn", constantBackground, 0.0, 2.0*TMath::Pi(), 2);
	  noFlowFitFcn->SetParName(1, "Constant");
	  noFlowFitFcn->SetParameter(0, 100.0);
	  graphFlow->Fit("noFlowFitFcn", "q0", "", 0.0, 2.0*TMath::Pi());
					
	  if(flowFitFcn)
	    delete flowFitFcn;
				 
	  flowFitFcn =  new TF1("flowFitFcn", v2SinglesFit, 0.0, 2.0*TMath::Pi(), 2);
	  flowFitFcn->SetParName(0, "Normalization");
	  flowFitFcn->SetParName(1, "v_{2}");
	  flowFitFcn->SetParameter(0, 0.5*(yMin + yMax));
	  flowFitFcn->SetParameter(1, 0.01);
	  graphFlow->Fit("flowFitFcn", "", "", 0.0, 2.0*TMath::Pi());
					
	  if(flowFitFcn2)
	    delete flowFitFcn2;
					
	  flowFitFcn2 = new TF1("flowFitFcn2", v2SinglesFit, 0.0, 2.0*TMath::Pi(), 2);
	  flowFitFcn2->SetParName(0, "Normalization");
	  flowFitFcn2->SetParName(1, "v_{2}");
	  flowFitFcn2->SetParameter(0, flowFitFcn->GetParameter(0));
	  flowFitFcn2->SetParameter(1, 0.15);
	  flowFitFcn2->SetLineColor(2);
	  flowFitFcn2->SetLineStyle(3);
	  if(!toyModel)
	    flowFitFcn2->Draw("same");
					
	  float sumChiSquareV2 = 0.0;
	  for(unsigned int kPhi=0.0; kPhi<NPHIBINS; kPhi++) {
	    if(yPlotErrors[kPhi] > 0.0) {
	      float diff = (yPlot[kPhi] - flowFitFcn2->Eval(xPlot[kPhi]))/yPlotErrors[kPhi];
	      sumChiSquareV2 += diff*diff;
	    }
	  }
					
	  if(toyModel) {
	    char toyRPBuffer[200];
	    if(useToyModelRPResolution) {
	      if(toyModelRPResolution >= 0.0) {
		sprintf(toyRPBuffer, "Assume a RP resolution parameter %4.2f radians", toyModelRPResolution);
	      }
	      else {
		sprintf(toyRPBuffer, "Assume a random Reaction Plane");
	      }
	    }
	    else {
	      sprintf(toyRPBuffer, "Assume a perfect RP resolution parameter");
	    }

	    TLatex *tRP = new TLatex(0.6, yMin + 0.7*(yMax - yMin), toyRPBuffer);
	    tRP->SetTextColor(4);
	    tRP->SetTextSize(0.030);
	    tRP->Draw();
	  }
				 
	  char eventsBuffer[200];
	  sprintf(eventsBuffer, "Events processed %d", useEventsProcessed);
	  TLatex *tEV = new TLatex(1.1, yMin + 0.075*(yMax - yMin), eventsBuffer);
	  tEV->SetTextColor(4);
	  tEV->SetTextSize(0.025);
	  tEV->Draw();
					
	  if(!toyModel) {
	    TLatex *tCO = new TLatex(0.1, yMin + 0.075*(yMax - yMin), "Dotted: compare with v_{2} = 0.15");
	    tCO->SetTextColor(2);
	    tCO->SetTextSize(0.025);
	    tCO->Draw();
					
	    char compareBuffer[200];
	    sprintf(compareBuffer, "Reduced #chi^{2} %4.2f", sumChiSquareV2/(NPHIBINS - 2));
	    TLatex *tCO2 = new TLatex(0.1, yMin + 0.040*(yMax - yMin), compareBuffer);
	    tCO2->SetTextColor(2);
	    tCO2->SetTextSize(0.025);
	    tCO2->Draw();
			
	    char choiceBuffer[200];
	    switch(reactionPlaneAngleChoice) {
	    case 1:
	      sprintf(choiceBuffer, "Reaction Plane Angle Choice: HF");
	      break;
	    case 9:
	      sprintf(choiceBuffer, "Reaction Plane Angle Choice: EtaGapPair");
	      break;
	    default:
	      cerr << "\n Undefined reaction plane angle choice" << endl;
	      return;
	    } // switch according to reaction plane choice
			
	    TLatex *tCH = new TLatex(0.2, yMin + 0.90*(yMax - yMin), choiceBuffer);
	    tCH->SetTextColor(1);
	    tCH->SetTextSize(0.025);
	    tCH->Draw();
			
	    char yieldCutBuffer[200];
	    sprintf(yieldCutBuffer, "Subtracted yield cut interval = %3.1f #sigma around unpartitioned mass centroid", subtractedYieldWidthFactor);
	    if(useAsymmetricMassCuts) {
	      sprintf(yieldCutBuffer, "Subtracted yield cut interval = -%3.1f to +%3.1f #sigma around mass centroid", lowerAsymmetricWidthFactor, upperAsymmetricWidthFactor);
	    }
	    TLatex *tCY = new TLatex(0.10, yMin + 0.83*(yMax - yMin), yieldCutBuffer);
	    tCY->SetTextColor(1);
	    tCY->SetTextSize(0.022);
	    tCY->Draw();
			
	  }
	  else {
	    TLatex *tCO = new TLatex(0.1, yMin + 0.075*(yMax - yMin), "Toy model v_{2} = 0.20");
	    tCO->SetTextColor(4);
	    tCO->SetTextSize(0.025);
	    tCO->Draw();
	  }
					
	  sprintf(graphOutputFileName, "pi0FlowFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // C macro
	  sprintf(graphOutputFileName, "pi0FlowFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // gif file
	  sprintf(graphOutputFileName, "pi0FlowFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // pdf file
				 
	}		
      } // loop over pt bins
    } // loop over eta bins
		
    c1->Clear();
    //
    // Unpartitioned yields before and after subtraction (3 pT bins at a given eta bin)
    //
    c1->Divide(3,2);
		
    TLine *baseLine = new TLine(0.0, 0.0, maximumPi0MassForHistogram, 0.0);
    baseLine->SetLineColor(kBlack);
    baseLine->SetLineWidth(2);
		
    for(unsigned int kEta=kEtaLow; kEta<kEtaHigh; kEta++) {
      for (unsigned int kPt=0; kPt<3; kPt++) {
	if(pi0MassEtaPtHistogram[kEta][kPt]->GetEntries() == 0.0)
	  continue;

	c1->cd(kPt+1);
	pi0MassEtaPtHistogram[kEta][kPt]->SetStats(0);
	pi0MassEtaPtHistogram[kEta][kPt]->Draw();

	if(pi0MassEtaPtHistogram[kEta][kPt]->GetEntries() > 0.0) {
	  pi0MassEtaPtHistogramCopyMixed[kEta][kPt]->SetFillColor(kYellow);
	  pi0MassEtaPtHistogramCopyMixed[kEta][kPt]->Draw("same");
	}
	pi0MassEtaPtHistogram[kEta][kPt]->SetLineColor(4);
	pi0MassEtaPtHistogram[kEta][kPt]->SetLineWidth(2);
	pi0MassEtaPtHistogram[kEta][kPt]->Draw("same");
	
	if(pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetEntries() <= 0.0)
	  continue;

	int sumSubtractedYield = 0;
	float sumSubtractedError = 0.0;
	float binLowForYield = 	binLowForYieldArray[kEta][kPt];
	float binHighForYield =	binHighForYieldArray[kEta][kPt];

	c1->cd(kPt+4);
	float mixedEventYield = 0.0;
	for(int kBin=1; kBin<=nMassBins; kBin++) {
	  double binCenter = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinCenter(kBin);
	  if(binCenter >= binLowForYield && binCenter <= binHighForYield) {
	    sumSubtractedYield += pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinContent(kBin);
	    mixedEventYield += pi0MassEtaPtHistogram[kEta][kPt]->GetBinContent(kBin);
	    double binError = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinError(kBin);
	    sumSubtractedError += binError*binError;
	  } // check mass bin
	} // sum over mass bins
	float mixedEventYieldError = mixedEventYield*mixedEventNormalizationFactor2DArray[kEta][kPt]*
	  mixedEventNormalizationErrorFactor2DArray[kEta][kPt];

	sumSubtractedError = sqrt(sumSubtractedError + mixedEventYieldError);
        float signalBackgroundRatio = sumSubtractedYield/mixedEventYield;
	float signalBackgroundRatioError = 0.0;
	if(sumSubtractedYield > 0.0)
	  signalBackgroundRatioError = signalBackgroundRatio*sumSubtractedError/sumSubtractedYield;
					
	float fMaxHistValue = 1.30*pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinContent(pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMaximumBin());
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMaximum(fMaxHistValue);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetStats(0);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMarkerStyle(20);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMarkerColor(2);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMarkerSize(0.5);
	//
	// Fit the background subtracted result
	//
	TF1 *fitFcn =  new TF1("fitFcn", gaussPeak, subtractedStart, subtractedEnd, 3);
	fitFcn->SetParName(0, "peak Amplitude");
	fitFcn->SetParName(1, "peak Centroid");
	fitFcn->SetParName(2, "peak Sigma");
	fitFcn->SetParameters(fMaxHistValue, 0.13, 0.02);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->Fit("fitFcn", "", "", subtractedStart, subtractedEnd);
	float peakCentroid = fitFcn->GetParameter(1);
	float peakCentroidError = fitFcn->GetParError(1);
	float peakWidth = fabs(fitFcn->GetParameter(2));
	float peakWidthError = fitFcn->GetParError(2);
				
	char signalBuffer1[200];
	sprintf(signalBuffer1, "Mass = %5.1f #pm %5.1f MeV", 1000.0*peakCentroid, 1000.0*peakCentroidError);
	TLatex *tSB1 = new TLatex(0.014, 0.85*fMaxHistValue, signalBuffer1);
	tSB1->SetTextColor(4);
	tSB1->SetTextSize(0.035);
	tSB1->Draw();
				
	char signalBuffer2[200];
	sprintf(signalBuffer2, "Width = %5.1f #pm %5.1f MeV", 1000.0*peakWidth, 1000.0*peakWidthError);
	TLatex *tSB2 = new TLatex(0.014, 0.75*fMaxHistValue, signalBuffer2);
	tSB2->SetTextColor(4);
	tSB2->SetTextSize(0.035);
	tSB2->Draw();
					
	char signalBuffer3[200];
	sprintf(signalBuffer3, "Yield = %d #pm %d", sumSubtractedYield, int(sumSubtractedError));
	TLatex *tSB3 = new TLatex(0.175, 0.85*fMaxHistValue, signalBuffer3);
	tSB3->SetTextColor(2);
	tSB3->SetTextSize(0.040);
	tSB3->Draw();
	
	char signalBuffer4[200];
	sprintf(signalBuffer4, "From %4.3f to %4.3f GeV", binLowForYield, binHighForYield);
	TLatex *tSB4 = new TLatex(0.175, 0.78*fMaxHistValue, signalBuffer4);
	tSB4->SetTextColor(2);
	tSB4->SetTextSize(0.030);
	tSB4->Draw();
			
	char signalBuffer5[200];
	sprintf(signalBuffer5, "S/B = %5.3f +/- %5.3f", signalBackgroundRatio, signalBackgroundRatioError);
	TLatex *tSB5 = new TLatex(0.175, 0.71*fMaxHistValue, signalBuffer5);
	tSB5->SetTextColor(2);
	tSB5->SetTextSize(0.030);
	tSB5->Draw();
			
	baseLine->Draw();
					
	float lowY = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMinimum();
	float highY = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMaximum();
	TLine *lowYieldCut = new TLine(binLowForYield, lowY, binLowForYield, highY);
	lowYieldCut->SetLineColor(kMagenta);
	lowYieldCut->SetLineWidth(1);
	lowYieldCut->SetLineStyle(3);
	lowYieldCut->Draw();
				
	TLine * highYieldCut = new TLine(binHighForYield, lowY, binHighForYield, highY);
	highYieldCut->SetLineColor(kMagenta);
	highYieldCut->SetLineWidth(1);
	highYieldCut->SetLineStyle(3);
	highYieldCut->Draw();
			
      } // loop over 3 pt bins
			
      int useRunNumber = runNumber;
      if(toyModel)
	useRunNumber = 0;
			
      char graphOutputFileName[200];
      sprintf(graphOutputFileName, "pi0UnpartitionedYields_Run%d_Centrality%d-%d_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowEtaBin[kEta], highEtaBin[kEta], date);
      c1->Print(graphOutputFileName);  // C macro
      sprintf(graphOutputFileName, "pi0UnpartitionedYields_Run%d_Centrality%d-%d_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowEtaBin[kEta], highEtaBin[kEta], date);
      c1->Print(graphOutputFileName);  // gif file
      sprintf(graphOutputFileName, "pi0UnpartitionedYields_Run%d_Centrality%d-%d_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowEtaBin[kEta], highEtaBin[kEta], date);
      c1->Print(graphOutputFileName);  // pdf fill
			
    } // loop over eta bins
		
    int sumAllYields = 0;
    float sumAllErrors = 0.0;
    cout << "\n                         Pt Bins";
    cout << "\n Eta Bins        ";
    for(unsigned int kPt=0; kPt<3; kPt++) {
      cout << lowPtBin[kPt] << " - " << highPtBin[kPt];
      cout << "         ";
    } // loop over pT bins for column header
    cout << endl;
    for(unsigned int kEta=kEtaLow; kEta<kEtaHigh; kEta++) {
      cout << "\n " << lowEtaBin[kEta] << " - " << highEtaBin[kEta];
      cout << ":   ";
      for(unsigned int kPt=0; kPt<3; kPt++) {
	int yieldThisEtaThisPt = 0.0;
	float errorThisEtaThisPt = 0.0;
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  yieldThisEtaThisPt += subtractedYields[kEta][kPhi][kPt];
	  errorThisEtaThisPt += float(subtractedYieldErrors[kEta][kPhi][kPt])*float(subtractedYieldErrors[kEta][kPhi][kPt]);
	} // loop over kPhi bins at this eta and pt
	cout << "  " << yieldThisEtaThisPt;
	cout << " +/- " << int(sqrt(errorThisEtaThisPt));
	cout << "  ";
	sumAllYields += yieldThisEtaThisPt;
	sumAllErrors += errorThisEtaThisPt;
      } // loop over kPt bins at this eta, moving horizontally
    } // loop over eta bins, moving vertically
    cout << "\n Sum of all yields " << sumAllYields << " +/- " << int(sqrt(sumAllErrors));
		
    float sumAllSameEvent = 0;
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  sumAllSameEvent += pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetEntries();
	} // loop over phi bins
      } // loop over pt
    } // loop over eta
    cout << "\n Entries in all partitioned same event histograms " << sumAllSameEvent;
    cout << ";  entries in unpartitioned same event histogram " << pi0MassHistogram->GetEntries();
    cout << ";  entries in unpartitioned copy of same event histogram " << pi0MassHistogramSameEvent->GetEntries();
    cout << endl;
		
		
  } // iOption = 1 to 5, plot the azimuthal distributions for a given eta and pt bin
	
  if(iOption == 6) { // mixed event histograms for the pt bins
		
    c1->Divide(2,2);
    unsigned int kPanel = 1;
    for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
			
      c1->cd(kPanel);
      pi0MassEtaPtHistogramMixed[0][kPt]->SetStats(0);
      pi0MassEtaPtHistogramMixed[0][kPt]->Draw();
			
      kPanel++;
			
    } // loop over pt bins	
		
  } // iOption = 6, mixed event histograms for the pt bins
	
  if(iOption == 7) { // draw reaction plane angle
    c1->Divide(1,2);
		
    c1->cd(1);
    eventAcceptedReactionPlaneAngleHistogram->SetMinimum(0);
    eventAcceptedReactionPlaneAngleHistogram->Draw();
		
    c1->cd(2);
    pi0AcceptedReactionPlaneAngleHistogram->SetMinimum(0);
    pi0AcceptedReactionPlaneAngleHistogram->Draw();
		
  } // iOption = 7, draw reaction plane angle

  if(iOption == 9) { // plot the azimuthal distribution in the lab
    c1->Divide(1,2);
    c1->cd(1);
    pi0PhiTrueHistogram->Draw();

    c1->cd(2);
    pi0PhiRPTrueHistogram->SetMinimum(0);
    pi0PhiRPTrueHistogram->Draw();

  } // kOption = 9 pi0 same events distribution

  if(iOption == -10 || iOption == 10 || iOption == 12) { // plot the mass spectrum for this centrality and pT cuts

    if(iOption == 10) {
      c1->Divide(1,3);
      c1->cd(1);
    }

    if(iOption == 12) {
      c1->Divide(1,2);
      c1->cd(1);
    }
	
    float fMaxHistValue1 = pi0MassHistogram->GetBinContent(pi0MassHistogram->GetMaximumBin());
    float fDivisor = 100000.0;
    if(fMaxHistValue1 < 50000.)
      fDivisor = 10000.0;
    if(fMaxHistValue1 < 5000.)
      fDivisor = 1000.0;
    if(fMaxHistValue1 < 500.)
      fDivisor = 100.0;
    if(fMaxHistValue1 < 100.0)
      fDivisor = 50.0;
		
    int iDivisor = fDivisor;
    int iMaxHistValue1 = fMaxHistValue1/fDivisor;
    iMaxHistValue1 = iDivisor*(iMaxHistValue1 + 3);
 
    cout << "\n fMaxHistValue1 " << fMaxHistValue1 << endl;

    char labelBuffer1[200];
    if(realData)
      sprintf(labelBuffer1, "Pb-Pb #sqrt{s} = 2.76 TeV");
    if(hydjetModel)
      sprintf(labelBuffer1, "HYDJET sim: Pb-Pb #sqrt{s} = 2.76 TeV");
    if(pythiaModel)
      sprintf(labelBuffer1, "Pythia sim: pp #sqrt{s} = 7.0 TeV");
    if(toyModel)
      sprintf(labelBuffer1, "Toy Model Simulation");
		
    if(iOption != 12) {

      TF1 *fitFcn1 = 0;
      TF1 *backgroundFcn1 = 0;

      if(iBackgroundOption == 0) {
	cout << "\n\n Fitting with one constant background function" << endl << endl;
	fitFcn1 = new TF1("fitFcn1",fitFunctionConstant, fitStart, fitEnd, 4);
	fitFcn1->SetParameters(1., 10., 0.134, 0.022);
	fitFcn1->SetParName(0, "constant bgrnd");
	fitFcn1->SetParName(1, "peak Amplitude");
	fitFcn1->SetParName(2, "peak Centroid"); 
	fitFcn1->SetParName(3, "peak Sigma"); 
	backgroundFcn1 = new TF1("backgroundFcn1",constantBackground, fitStart, fitEnd, 1);
      }

      if(iBackgroundOption == 1) {
	cout << "\n\n Fitting with two parameter background function" << endl << endl;
	fitFcn1 = new TF1("fitFcn1",fitFunctionLinear, fitStart, fitEnd, 5);
	fitFcn1->SetParameters(40, 1000, 2000., 0.133, 0.016);
	fitFcn1->SetParName(0, "constant bgrnd");
	fitFcn1->SetParName(1, "linear bgrnd");
	fitFcn1->SetParName(2, "peak Amplitude");
	fitFcn1->SetParName(3, "peak Centroid"); 
	fitFcn1->SetParName(4, "peak Sigma"); 
	backgroundFcn1 = new TF1("backgroundFcn1",linearBackground, fitStart, fitEnd, 2);
      }
	
      fitFcn1->SetNpx(500);
      fitFcn1->SetLineWidth(2);
      fitFcn1->SetLineColor(4);

      if(pythiaModel)
	pi0MassHistogram->SetTitle("#pi^{0} Peak in Pythia pp Events");

      if(toyModel)
	pi0MassHistogram->SetTitle("#pi^{0} Peak From Toy Model Simulation");
 
      pi0MassHistogram->SetMaximum(iMaxHistValue1);
      pi0MassHistogram->Fit("fitFcn1", "", "", fitStart, fitEnd);

      TF1 *peakFcn1 = new TF1("peakFcn1", gaussPeak, peakStart, peakEnd, 3);

      if(iBackgroundOption == 0) {
	peakFcn1->SetParameter(0, fitFcn1->GetParameter(1));
	peakFcn1->SetParameter(1, fitFcn1->GetParameter(2));
	peakFcn1->SetParameter(2, fitFcn1->GetParameter(3));
	backgroundFcn1->SetParameter(0, fitFcn1->GetParameter(0));
      }

      if(iBackgroundOption == 1) {
	peakFcn1->SetParameter(0, fitFcn1->GetParameter(2));
	peakFcn1->SetParameter(1, fitFcn1->GetParameter(3));
	peakFcn1->SetParameter(2, fitFcn1->GetParameter(4));
	backgroundFcn1->SetParameter(0, fitFcn1->GetParameter(0));
	backgroundFcn1->SetParameter(1, fitFcn1->GetParameter(1));
      }

      float sum1Total = 0;
      float sum1Peak = 0;
      float sum1Background = 0;
      float peakSumLow =  peakFcn1->GetParameter(1) - 3.0*fabs(peakFcn1->GetParameter(2));
      float peakSumHigh =  peakFcn1->GetParameter(1) + 3.0*fabs(peakFcn1->GetParameter(2));
      for(int iBin=1; iBin<nMassBins; iBin++) {
	float binCenter = pi0MassHistogram->GetBinCenter(iBin);
	if(binCenter>=peakSumLow && binCenter<=peakSumHigh) {
	  float binValue = pi0MassHistogram->GetBinContent(iBin);
	  sum1Total += binValue; 
	  double bgrnd = backgroundFcn1->Eval(binCenter);
	  sum1Peak += binValue - bgrnd;
	  sum1Background += bgrnd;
	} // check if within mass peak
      }
      float signal1Error = sqrt(sum1Total + sum1Background);
      float signal1FractionalError = 0.0;
      if(sum1Peak > 0.0)
	signal1FractionalError = signal1Error/sum1Peak;

      float background1Error = sqrt(sum1Background);
      float background1FractionalError = 0.0;
      if(sum1Background > 0.0)
	background1FractionalError = background1Error/sum1Background;   

      cout << "\n\n sum1Total = " << sum1Total;
      cout << "\n sum1Peak = " << int(sum1Peak) << " +/- " << int(signal1Error+1.);
      cout << "\n sum1Background = " << int(sum1Background) << " +/- " << int(background1Error+1.);

      float sbRatio1 = 0.0;
      float sbRatioError1 = 0.0;

      if(sum1Background > 0) {
	sbRatio1 =  sum1Peak/sum1Background;
	sbRatioError1 = sbRatio1*sqrt(signal1FractionalError*signal1FractionalError + background1FractionalError*background1FractionalError); 
	cout << "\n Signal/Background = " << sbRatio1 <<  " +/- " << sbRatioError1;
      }
      cout << endl;

      TLatex *lhcPbPb = new TLatex(0.014, 0.90*iMaxHistValue1, labelBuffer1);
      lhcPbPb->SetTextColor(4);
      lhcPbPb->SetTextSize(0.060);
      lhcPbPb->Draw();

      if(realData || hydjetModel) {
	char centBuffer1[200];
	sprintf (centBuffer1, "Centralities %d to %d", lowCent, highCent);
	TLatex *runB1 = new TLatex(0.014, 0.78*iMaxHistValue1, centBuffer1);
	runB1->SetTextColor(4);
	runB1->SetTextSize(0.050);
	runB1->Draw();
      }
						
      char sbBuffer1[200];
      sprintf (sbBuffer1, "S/B (3#sigma) = %5.3f +/- %5.3f", sbRatio1, sbRatioError1);
      TLatex *tSB1 = new TLatex(0.014, 0.66*iMaxHistValue1, sbBuffer1);
      tSB1->SetTextColor(4);
      tSB1->SetTextSize(0.050);
      tSB1->Draw();

      char etaBuffer1[200];
      sprintf(etaBuffer1, "%4.2f < #eta(#pi^{0}) < %4.2f", lowEtaLimit, highEtaLimit);
      TLatex *tSB2 = new TLatex(0.014, 0.54*iMaxHistValue1, etaBuffer1);
      tSB2->SetTextColor(4);
      tSB2->SetTextSize(0.050);
      tSB2->Draw();

      char ptBuffer1[200];
      sprintf(ptBuffer1, "%3.1f < p_{T} < %3.1f", lowPtCut, highPtCut);
      TLatex *tSB3 = new TLatex(0.014, 0.42*iMaxHistValue1, ptBuffer1);
      tSB3->SetTextColor(4);
      tSB3->SetTextSize(0.050);
      tSB3->Draw();

      char signalBuffer1[200];
      sprintf(signalBuffer1, "Signal = %d #pm %d", int(sum1Peak), int(signal1Error));
      TLatex *tSB4 = new TLatex(0.014, 0.30*iMaxHistValue1, signalBuffer1);
      tSB4->SetTextColor(4);
      tSB4->SetTextSize(0.050);
      tSB4->Draw();

      char backgroundBuffer1[200];
      sprintf(backgroundBuffer1, "Bgrnd = %d #pm %d", int(sum1Background), int(background1Error));
      TLatex *tSB5 = new TLatex(0.014, 0.18*iMaxHistValue1, backgroundBuffer1);
      tSB5->SetTextColor(4);
      tSB5->SetTextSize(0.050);
      tSB5->Draw();

      peakFcn1->SetLineColor(2);
      peakFcn1->Draw("same");

    } // check on iOption != 12
		
    if(iOption == 10 || iOption == 12) {
		
      (c1->cd(1))->SetGrid();

      if(iOption != 12) {
	c1->cd(2);
      }
      TH1D *pi0MassHistogramCopy = 0;
      pi0MassHistogramCopy = new TH1D("pi0MassHistogramCopy", "#pi^{0} Peak in Heavy Ion Events, With Mixed Event Normalized Background", nMassBins, 0.0, maximumPi0MassForHistogram);
      pi0MassHistogramCopy->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      pi0MassHistogramCopy->SetYTitle(countsPerBin);
      if(pythiaModel)
	pi0MassHistogramCopy->SetTitle("#pi^{0} Peak in Pythia pp Events, With Mixed Event Normalized Background");
      if(toyModel)
	pi0MassHistogramCopy->SetTitle("#pi^{0} Peak From Toy Model Simulation");
		
      TH1D *pi0MassHistogramSubtracted = 0;
      pi0MassHistogramSubtracted = new TH1D("pi0MassHistogramSubtracted", "Background-subtracted #pi^{0} Peak in Heavy Ion Events", nMassBins, 0.0, maximumPi0MassForHistogram);
      pi0MassHistogramSubtracted->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      pi0MassHistogramSubtracted->SetYTitle(countsPerBin);
      if(pythiaModel)
	pi0MassHistogramSubtracted->SetTitle("Background-subtracted #pi^{0} Peak in Pythia pp Events");
      if(toyModel)
	pi0MassHistogramSubtracted->SetTitle("Background-subtracted #pi^{0} Peak From Toy Model Simulation");
		
      //
      // Get normalization factor
      //
      double sameEventCount = 0.0;
      double mixedEventCount = 0.0;
      for(int kBin=1; kBin<nMassBins; kBin++) {
	double binCenter = pi0MassHistogramMixed->GetBinCenter(kBin);
	if(binCenter >= lowFalsePairMassCut && binCenter <= highFalsePairMassCut) {
	  sameEventCount += pi0MassHistogram->GetBinContent(kBin);
	  mixedEventCount += pi0MassHistogramMixed->GetBinContent(kBin);
	}
      }
      cout << "\n For normalization: same event count = " << sameEventCount << ", mixed event count " << mixedEventCount << endl;
		
      if(mixedEventCount > 0.0) {
		
	double mixedEventNormalizedYieldError = 0;
	double sameEventTotal = 0.0;
	double sameEventYield = 0.0;
	double sameEventYieldError = 0.0;
	double mixedEventNormalizedYield = 0.0;
	double normalizationFactorMixed = sameEventCount/mixedEventCount;
	for(int kBin=1; kBin<=nMassBins; kBin++) {
	  double sameEventContent = pi0MassHistogram->GetBinContent(kBin);
	  pi0MassHistogramCopy->SetBinContent(kBin,sameEventContent);
	  double mixedEventContent = pi0MassHistogramMixed->GetBinContent(kBin);
	  double mixedEventFractionalErrorSquared = 0.0;
	  if(mixedEventContent > 0.0)
	    mixedEventFractionalErrorSquared = 1.0/mixedEventContent;
	  double mixedEventNormalizedContent = normalizationFactorMixed*mixedEventContent;
	  pi0MassHistogramMixed->SetBinContent(kBin, mixedEventNormalizedContent);
	  double combinedErrorSquared = sameEventContent + mixedEventNormalizedContent*mixedEventNormalizedContent*mixedEventFractionalErrorSquared;
	  sameEventYieldError += combinedErrorSquared;
	  double binCenter = pi0MassHistogram->GetBinCenter(kBin);
	  double sameEventSubtracted = sameEventContent - mixedEventNormalizedContent;
	  double sameEventSubtractedError = sqrt(combinedErrorSquared);
				
	  if(binCenter >= subtractedStart && binCenter <= subtractedEnd) {
	    sameEventTotal += sameEventContent;
	    sameEventYield += sameEventSubtracted;
	    mixedEventNormalizedYield += mixedEventNormalizedContent;
	    mixedEventNormalizedYieldError += mixedEventNormalizedContent*mixedEventNormalizedContent*mixedEventFractionalErrorSquared;
	  }
	  if(sameEventContent > 0.0) {
	    pi0MassHistogramSubtracted->SetBinContent(kBin, sameEventSubtracted);
	    pi0MassHistogramSubtracted->SetBinError(kBin, sameEventSubtractedError);
	  }
	} // loop over mixed event histogram
	pi0MassHistogramCopy->SetStats(0);
	pi0MassHistogramCopy->SetLineColor(4);
	pi0MassHistogramCopy->SetLineWidth(2);
	pi0MassHistogramCopy->SetMaximum(iMaxHistValue1);
	pi0MassHistogramCopy->Draw();	
	pi0MassHistogramMixed->SetFillColor(kYellow);
	pi0MassHistogramMixed->Draw("same");
	pi0MassHistogramCopy->Draw("same");	
	cout << "\n Same event total = " << sameEventTotal;
	cout << ",  same event yield = " << sameEventYield;
	cout << ",  normalized background yield = " << mixedEventNormalizedYield;
	
	if(iOption != 12) {
	  char massBuffer2[200];
	  sprintf(massBuffer2, "Mass integration region from %3.2f to %3.2f GeV", subtractedStart, subtractedEnd);
	  TLatex *tMB2 = new TLatex(0.014, 0.74*iMaxHistValue1, massBuffer2);
	  tMB2->SetTextColor(4);
	  tMB2->SetTextSize(0.055);
	  tMB2->Draw();
		
	  char signalBuffer2[200];
	  sprintf(signalBuffer2, "Background subtracted yield = %d #pm %d", int(sameEventYield), int(sqrt(sameEventYieldError)));
	  TLatex *tSB42 = new TLatex(0.014, 0.62*iMaxHistValue1, signalBuffer2);
	  tSB42->SetTextColor(4);
	  tSB42->SetTextSize(0.055);
	  tSB42->Draw();
		
	  char bgrndBuffer2[200];
	  sprintf(bgrndBuffer2, "Background yield = %d #pm %d", int(mixedEventNormalizedYield), int(sqrt(mixedEventNormalizedYieldError)));
	  TLatex *tBG42 = new TLatex(0.014, 0.50*iMaxHistValue1, bgrndBuffer2);
	  tBG42->SetTextColor(4);
	  tBG42->SetTextSize(0.055);
	  tBG42->Draw();
	  (c1->cd(2))->SetGrid();
	  c1->cd(3);
	  pi0MassHistogramSubtracted->SetStats(111000);

	}
	else {

	  TLatex *lhcPbPb = new TLatex(0.014, 0.90*iMaxHistValue1, labelBuffer1);
	  lhcPbPb->SetTextColor(4);
	  lhcPbPb->SetTextSize(0.060);
	  lhcPbPb->Draw();

	  if(realData || hydjetModel) {
	    char centBuffer1[200];
	    sprintf (centBuffer1, "Centralities %d to %d", lowCent, highCent);
	    TLatex *runB1 = new TLatex(0.014, 0.78*iMaxHistValue1, centBuffer1);
	    runB1->SetTextColor(4);
	    runB1->SetTextSize(0.050);
	    runB1->Draw();
	  }

	  char etaBuffer1[200];
	  sprintf(etaBuffer1, "%4.2f < #eta(#pi^{0}) < %4.2f", lowEtaLimit, highEtaLimit);
	  TLatex *tSB2 = new TLatex(0.014, 0.66*iMaxHistValue1, etaBuffer1);
	  tSB2->SetTextColor(4);
	  tSB2->SetTextSize(0.050);
	  tSB2->Draw();

	  char ptBuffer1[200];
	  sprintf(ptBuffer1, "%3.1f < p_{T} < %3.1f GeV/c", lowPtCut, highPtCut);
	  TLatex *tSB3 = new TLatex(0.014, 0.54*iMaxHistValue1, ptBuffer1);
	  tSB3->SetTextColor(4);
	  tSB3->SetTextSize(0.050);
	  tSB3->Draw();
	
	  c1->cd(2);
	  pi0MassHistogramSubtracted->SetStats(0);
	}

	pi0MassHistogramSubtracted->SetMarkerStyle(20);
	pi0MassHistogramSubtracted->SetMarkerColor(2);
	pi0MassHistogramSubtracted->SetMarkerSize(1.0);
	pi0MassHistogramSubtracted->Fit("gaus", "", "", subtractedStart, subtractedEnd);
	TLine *baseLine = new TLine(0.0, 0.0, maximumPi0MassForHistogram, 0.0);
	baseLine->SetLineColor(kBlack);
	baseLine->SetLineWidth(2);
	baseLine->Draw();
	if(iOption != 12) {
	  (c1->cd(3))->SetGrid();
	}
	else {
	  (c1->cd(2))->SetGrid();
	}

	double integratedYield = 0.0;
	double integratedYieldError = 0.0;
	double centFit = 1000.0*(pi0MassHistogramSubtracted->GetFunction("gaus"))->GetParameter(1);
	double centFitError = 1000.0*(pi0MassHistogramSubtracted->GetFunction("gaus"))->GetParError(1);
	double sigmaFit = fabs((pi0MassHistogramSubtracted->GetFunction("gaus"))->GetParameter(2));
	double sigmaFitError = (pi0MassHistogramSubtracted->GetFunction("gaus"))->GetParError(2);
	double lowMassCut = (centFit - subtractedYieldWidthFactor*sigmaFit);
	double highMassCut = (centFit + subtractedYieldWidthFactor*sigmaFit);
	if(useAsymmetricMassCuts) {
	  lowMassCut = (centFit - lowerAsymmetricWidthFactor*sigmaFit);
	  highMassCut = (centFit + upperAsymmetricWidthFactor*sigmaFit);
	}
	for(int iBin=1; iBin<=nMassBins; iBin++) {
	  double binCenter = pi0MassHistogramSubtracted->GetBinCenter(iBin);
	  if(binCenter >= lowMassCut && binCenter <= highMassCut) {
	    integratedYield += pi0MassHistogramSubtracted->GetBinContent(iBin);
	    double binError = pi0MassHistogramSubtracted->GetBinError(iBin);
	    integratedYieldError += binError*binError;
	  } // check for mass window
	} // loop over mass bins
	cout << endl;
	integratedYieldError = sqrt(integratedYieldError);

	if(iOption != 12) {
	  char yieldBuffer1[200];
	  sprintf(yieldBuffer1, "Mass window sum = %d +/- %d", int(integratedYield), int(integratedYieldError));
	  TLatex *tYB = new TLatex(0.014, 0.75*pi0MassHistogramSubtracted->GetMaximum(), yieldBuffer1);
	  tYB->SetTextColor(4);
	  tYB->SetTextSize(0.050);
	  tYB->Draw();

	  char yieldBuffer2[200];
	  sprintf(yieldBuffer2, "Mass window from %3.2f to %3.2f GeV", lowMassCut, highMassCut);
	  TLatex *tYB2 = new TLatex(0.014, 0.65*pi0MassHistogramSubtracted->GetMaximum(), yieldBuffer2);
	  tYB2->SetTextColor(4);
	  tYB2->SetTextSize(0.050);
	  tYB2->Draw();

	  float lowY = pi0MassHistogramSubtracted->GetMinimum();
	  float highY = pi0MassHistogramSubtracted->GetMaximum();
				
	  TLine *lowYieldCut = new TLine(lowMassCut, lowY, lowMassCut, highY);
	  lowYieldCut->SetLineColor(kMagenta);
	  lowYieldCut->SetLineWidth(1);
	  lowYieldCut->SetLineStyle(3);
	  lowYieldCut->Draw();
				
	  TLine *highYieldCut = new TLine(highMassCut, lowY, highMassCut, highY);
	  highYieldCut->SetLineColor(kMagenta);
	  highYieldCut->SetLineWidth(1);
	  highYieldCut->SetLineStyle(3);
	  highYieldCut->Draw();		

	} // check on iOption != 12
	else {
	  char fitBuffer1[200];
	  sprintf(fitBuffer1, "Mass centroid = %5.2f +/- %5.2f MeV/c^{2}", centFit, centFitError);
	  TLatex *tFB1 = new TLatex(0.014, 0.75*pi0MassHistogramSubtracted->GetMaximum(), fitBuffer1);
	  tFB1->SetTextColor(4);
	  tFB1->SetTextSize(0.050);
	  tFB1->Draw();

	  char fitBuffer2[200];
	  sprintf(fitBuffer2, "Mass width = %5.2f +/- %5.2f MeV/c^{2}", 1000.0*sigmaFit, 1000.0*sigmaFitError);
	  TLatex *tFB2 = new TLatex(0.014, 0.60*pi0MassHistogramSubtracted->GetMaximum(), fitBuffer2);
	  tFB2->SetTextColor(4);
	  tFB2->SetTextSize(0.050);
	  tFB2->Draw();

	}

      } // check on mixed event count
 
      //int time = dateTime->GetTime();
      char graphOutputFileName[200];
      sprintf(graphOutputFileName, "pi0MassFit_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_EtaLimit%4.2f_%d.C", runNumber, lowCent, highCent, lowPtCut, highPtCut, highEtaLimit, date);
      c1->Print(graphOutputFileName);  // C macro
      sprintf(graphOutputFileName, "pi0MassFit_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_EtaLimit%4.2f_%d.gif", runNumber, lowCent, highCent, lowPtCut, highPtCut, highEtaLimit, date);
      c1->Print(graphOutputFileName);  // gif file
      sprintf(graphOutputFileName, "pi0MassFit_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_EtaLimit%4.2f_%d.pdf", runNumber, lowCent, highCent, lowPtCut, highPtCut, highEtaLimit, date);
      c1->Print(graphOutputFileName);  // pdf file
      delete dateTime;
			
    } // check on iOption = 10 or iOption = 12

  } // check on iOption = 10 or -10 or iOption = 12

  if(iOption >= 21 && iOption <= 25) { // Code to use the class decompositions for the same-event and mixed-event histograms

    unsigned int kEtaLow = 0;
    unsigned int kEtaHigh = NETABINS;

    unsigned int kPtLow = 0;
    unsigned int kPtHigh = NPTBINS;
    if(iOption == 22) {
      kPtLow = 1;
      kPtHigh = 2;
    }
    if(iOption == 23) {
      kPtLow = 2;
      kPtHigh = 3;
    }
    if(iOption == 24) {
      kPtLow = 3;
      kPtHigh = 4;
    }
    if(iOption == 25) {
      kPtLow = 0;
      kPtHigh = 3;
    }

    //
    // Stored histograms
    //
    // 	pi0MassEtaPtHistogram[kEta][kPt]            Same-event as a function of eta and pT binning
    //  pi0MassEtaPtHistogramMixed[kEta][kPt]       Mixed-event as a function of eta and pT binning
    // 
    //  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]   Same-event as a function of eta, pT, and phi binning (phi wrt reaction plane angle)

    //  pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]       Same-event as a function of eta, pT, and phi binning, decomposed into event classes
    //  pi0MassEtaPhiPtRPZVertCentHistogramMixed[kEta][kPhi][kPt][kRP][kZVert][kCent]  Mixed-event as a function of eta, pT, and phi binning, decomposed into event classes

    //
    // Unclassed approach
    //
    // 1) Normalize the yield in the pi0MassEtaPtHistogramMixed[kEta][kPt] histogram to the yield in the pi0MassEtaPtHistogram[kEta][kPt] in a "false" mass region, e.g. 200 - 250 MeV
    // 2) Make a copy of the pi0MassEtaPtHistogramMixed[kEta][kPt] histogram, with the counts normalized, and call this pi0MassEtaPtHistogramMixedCopy[kEta][kPt]
    // 3) Subtract this normalized copy from the pi0MassEtaPtHistogram[kEta][kPt] to make pi0MassEtaPtHistogramSubtracted[kEta][kPt]
    // 4) Fit the pi0MassEtaPtHistogramSubtracted[kEta][kPt] histogram in order to obtain the Gauss peak width, which establishes the mass integration window for this [kEta][kPt] bin
    // 5) Normalize the yield in the  pi0MassEtaPtHistogramMixed[kEta][kPt] histogram to the yield in each of the pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt] in a "false" mass region, e.g. 200 - 250 MeV
    // 6) Make a copy of the pi0MassEtaPtHistogramMixed[kEta][kPt] histogram, with the counts normalized, and call this pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt]
    // 7) Subtract this normalized copy from the pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt] to make pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]
    // 8) Integrate the counts in pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt] using the mass window found in step 4)
    //

    cout << "\n Test iOption " << iOption << endl;

    double mixedEventPreNormalizedYield[NETABINS][NPTBINS];
    float normFactorEtaPt[NETABINS][NPTBINS];
    TH1D *pi0MassEtaPtHistogramMixedCopy[NETABINS][NPTBINS];
    TH1D *pi0MassEtaPtHistogramSubtracted[NETABINS][NPTBINS];
    float lowMassEtaPt[NETABINS][NPTBINS];
    float highMassEtaPt[NETABINS][NPTBINS];
    float subtractedYieldEtaPt[NETABINS][NPTBINS];
    float subtractedYieldEtaPtError[NETABINS][NPTBINS];
    float normFactorEtaPhiPt[NETABINS][NPHIBINS][NPTBINS];
    TH1D *pi0MassEtaPhiPtHistogramMixedCopy[NETABINS][NPHIBINS][NPTBINS];
    TH1D *pi0MassEtaPhiPtHistogramSubtracted[NETABINS][NPHIBINS][NPTBINS];
    float subtractedYieldEtaPhiPt[NETABINS][NPHIBINS][NPTBINS];
    float subtractedYieldEtaPhiPtError[NETABINS][NPHIBINS][NPTBINS];
    float v2FitUnClassedEtaPt[NETABINS][NPTBINS];
    float v2FitErrorUnClassedEtaPt[NETABINS][NPTBINS];
		
    char histogramName[200];
    char histogramTitle[200];
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	sprintf(histogramName, "pi0MassSubtactedEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Background-subtracted (no classes) #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetYTitle(countsPerBin);
	sprintf(histogramName, "pi0MassMixedCopyEtaBin%dPtBin%d", kEta, kPt);
	sprintf(histogramTitle, "Copy of Mixed-Event #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f ",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	pi0MassEtaPtHistogramMixedCopy[kEta][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	pi0MassEtaPtHistogramMixedCopy[kEta][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	pi0MassEtaPtHistogramMixedCopy[kEta][kPt]->SetYTitle(countsPerBin);
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  sprintf(histogramName, "pi0MassSubtactedEtaBin%dPhiBin%dPtBin%d", kEta, kPhi, kPt);
	  sprintf(histogramTitle, "Background-subtracted (no classes) #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt]);
	  pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	  pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	  pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetYTitle(countsPerBin);

	  sprintf(histogramName, "pi0MassMixedCopyEtaBin%dPhiBin%dPtBin%d", kEta, kPhi, kPt);
	  sprintf(histogramTitle, "MixedCopy #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPt], highPhiBin[kPt], lowPtBin[kPt], highPtBin[kPt]);
	  pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	  pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	  pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt]->SetYTitle(countsPerBin);

	} // loop over phi bins
      } // loop over pT bins
    } // loop over eta Bins

    //
    // Obtain the background-subtracted yields
    //

    for(unsigned int kEta=kEtaLow; kEta<kEtaHigh; kEta++) {
      for(unsigned int kPt=kPtLow; kPt<kPtHigh; kPt++) {

	//
	// Obtain the unpartitioned normalization factor for this (eta, pt) bin
	//

	double sameEventSum = 0;
	double mixedEventSum = 0;

	for(int iBin=1; iBin<nMassBins; iBin++) {
	  double binCenter = pi0MassEtaPtHistogramMixed[kEta][kPt] ->GetBinCenter(iBin);
	  if(binCenter >= lowFalsePairMassCut && binCenter <= highFalsePairMassCut) {
	    sameEventSum +=  pi0MassEtaPtHistogram[kEta][kPt]->GetBinContent(iBin);
	    mixedEventSum += pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(iBin);
	  }
	} // loop over all mass bins

	mixedEventPreNormalizedYield[kEta][kPt] = mixedEventSum;
	if(mixedEventSum > 0.0) {
	  normFactorEtaPt[kEta][kPt] = sameEventSum/mixedEventSum;
	}
	else {
	  cout << "\n Skipping kEta " << kEta << ", kPt " << kPt << " bin" << endl;
	  continue; // skip this kEta, kPt bin
	}

	//
	// Make the normalized copy mixed event histogram and the subtracted same event histogram for this (eta, pt) bin
	//
	double subtractedYield = 0;
	double subtractedYieldError = 0;
	for(int iBin=1; iBin<nMassBins; iBin++) {
	  double mixedEventContent =  pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(iBin);
	  double mixedEventContentNormalized = mixedEventContent*normFactorEtaPt[kEta][kPt];
	  pi0MassEtaPtHistogramMixedCopy[kEta][kPt]->SetBinContent(iBin, mixedEventContentNormalized);
	  double mixedEventContentNormalizedError = 0.0;
	  if(mixedEventContent > 0.0)
	    mixedEventContentNormalizedError = mixedEventContentNormalized/sqrt(mixedEventContent);
	  pi0MassEtaPtHistogramMixedCopy[kEta][kPt]->SetBinError(iBin, mixedEventContentNormalizedError);

	  double sameEventContent =  pi0MassEtaPtHistogram[kEta][kPt]->GetBinContent(iBin);
	  double subtractedContent = sameEventContent - mixedEventContentNormalized;

	  double binCenter = pi0MassEtaPtHistogram[kEta][kPt]->GetBinCenter(iBin);
	  if(binCenter > 0.10 && binCenter < 0.20) {
	    subtractedYield += subtractedContent;
	    subtractedYieldError += sameEventContent + mixedEventContentNormalizedError;
	  }

	  double subtractedContentError = sqrt(sameEventContent + mixedEventContentNormalizedError);
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetBinContent(iBin, subtractedContent);
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetBinError(iBin, subtractedContentError);

	} // loop over all mass bins

	cout << "\n For kEta " << kEta << ", kPt " << kPt;
	cout << " norm factor = " << normFactorEtaPt[kEta][kPt];
	cout << ",  mixed event yield = " << pi0MassEtaPtHistogramMixed[kEta][kPt]->GetSum();
	cout << ",  same event yield = " <<  pi0MassEtaPtHistogram[kEta][kPt]->GetSum();
	cout << ",  subtracted yield total = " << subtractedYield << " +/- " <<  sqrt(subtractedYieldError);
	cout << endl;

	lowMassEtaPt[kEta][kPt] = 0.0;
	highMassEtaPt[kEta][kPt] = -1.0;

	//
	// Fit the unpartitioned subtracted yield to obtain the mass window parameters
	//
	if(subtractedYield > 10.0) {

	  char graphOutputFileName[200];
	  int useRunNumber = runNumber;
	  if(toyModel)
	    useRunNumber = 0;		
		
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->Fit("gaus", "", "", subtractedStart, subtractedEnd);
	  TF1 *fitFcn = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetFunction("gaus");
	  lowMassEtaPt[kEta][kPt] =  fitFcn->GetParameter(1) - subtractedYieldWidthFactor*fabs(fitFcn->GetParameter(2));
	  highMassEtaPt[kEta][kPt] = fitFcn->GetParameter(1) + subtractedYieldWidthFactor*fabs(fitFcn->GetParameter(2));
	  if(useAsymmetricMassCuts) {
	    lowMassEtaPt[kEta][kPt] =  fitFcn->GetParameter(1) - lowerAsymmetricWidthFactor*fabs(fitFcn->GetParameter(2));
	    highMassEtaPt[kEta][kPt] = fitFcn->GetParameter(1) + upperAsymmetricWidthFactor*fabs(fitFcn->GetParameter(2));
	  }
	  cout << "\n Parameter 0 " << fitFcn->GetParameter(0);
	  cout << ",  parameter 1 " << fitFcn->GetParameter(1);
	  cout << ",  parameter 2 " << fitFcn->GetParameter(2);
	  cout << "\n Low mass cut = " <<  lowMassEtaPt[kEta][kPt];
	  cout << ",  high mass cut = " << highMassEtaPt[kEta][kPt];

	  double integratedYield = 0;
	  double integratedYieldError = 0;
	  double lowMassCut = lowMassEtaPt[kEta][kPt];
	  double highMassCut = highMassEtaPt[kEta][kPt];
		
	  double lowMassCut2[NPHIBINS];
	  double highMassCut2[NPHIBINS];
	  for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	    lowMassCut2[kPhi] = lowMassCut;
	    highMassCut2[kPhi] = highMassCut;
	  }
		
	  if(useHalfWidth) {
	    cout << "\n kEta " << kEta << ", kPt " << kPt << " limits before " << lowMassCut << " - " << highMassCut;
	    float differenceLowHigh = highMassCut - lowMassCut;
	    highMassCut = lowMassCut + 0.5*differenceLowHigh;
	    cout << "; limits after " << lowMassCut << " - " << highMassCut;
	  }
			
	  c1->Clear();

	  if(maximumPi0MassForHistogram > 0.30) {
	    pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetStats(0);
	  }
		
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMarkerStyle(20);
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMarkerStyle(20);
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMarkerColor(2);
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->SetMarkerSize(1.0);
	  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->Draw();

	  TLine *baseLine = new TLine(0.0, 0.0, maximumPi0MassForHistogram, 0.0);
	  baseLine->SetLineColor(kBlack);
	  baseLine->SetLineWidth(2);
	  baseLine->Draw();
		
	  for(int iBin=1; iBin<=nMassBins; iBin++) {
	    double binCenter = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinCenter(iBin);
	    if(subtractedYieldMinimumFactor <= 0.0 && binCenter >= lowMassCut && binCenter <= highMassCut) {
	      integratedYield +=  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinContent(iBin);
	      double binError =  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinError(iBin);
	      integratedYieldError += binError*binError;
	    }
					
	  } // loop over mass bins
		
	  subtractedYieldEtaPt[kEta][kPt] = integratedYield;
	  subtractedYieldEtaPtError[kEta][kPt] = sqrt(integratedYieldError);
	  cout << "\n Integrated yield = " << integratedYield << " +/- " <<  sqrt(integratedYieldError);
	  cout << endl;
		
	  char yieldBuffer[200];
	  sprintf(yieldBuffer, "Sum = %d +/- %d", int(subtractedYieldEtaPt[kEta][kPt]), int(subtractedYieldEtaPtError[kEta][kPt]));
	  float tYP_xPlot = 0.014;
	  if(maximumPi0MassForHistogram > 0.30) {
	    tYP_xPlot = 0.20;
	  }
	  TLatex *tYB = new TLatex(tYP_xPlot, 0.70*pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMaximum(), yieldBuffer);
	  tYB->SetTextColor(4);
	  tYB->SetTextSize(0.033);
	  tYB->Draw();
				
	  float lowY = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMinimum();
	  float highY =  pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMaximum();
		
	  TLine *lowYieldCut = new TLine(lowMassCut, lowY, lowMassCut, highY);
	  lowYieldCut->SetLineColor(kMagenta);
	  lowYieldCut->SetLineWidth(1);
	  lowYieldCut->SetLineStyle(3);
	  lowYieldCut->Draw();
		
	  TLine *highYieldCut = new TLine(highMassCut, lowY, highMassCut, highY);
	  highYieldCut->SetLineColor(kMagenta);
	  highYieldCut->SetLineWidth(1);
	  highYieldCut->SetLineStyle(3);
	  highYieldCut->Draw();

	  if(maximumPi0MassForHistogram > 0.30) {
	    double countHighBinsYield = 0.0;
	    double countHighBinsError = 0.0;
	    for(int kBin=0; kBin<nMassBins; kBin++) {
	      if(pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinCenter(kBin) > 0.30) {
		countHighBinsYield += pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinContent(kBin);
		double thisError = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinError(kBin);
		countHighBinsError += thisError*thisError; 
	      } // check for mass bin above 0.30 GeV/c^2
	    } // loop over mass bins
	    char highYieldBuffer[200];
	    cout << "\n For kPt " << kPt << " sum above 300 MeV = " << int(countHighBinsYield) << " +/- " << int(sqrt(countHighBinsError)) << endl;
	    sprintf(highYieldBuffer, "Sum above 300 MeV/c^{2} = %d +/- %d", int(countHighBinsYield), int(sqrt(countHighBinsError)));
	    TLatex *hYB = new TLatex(0.20, 0.40*pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMaximum(), highYieldBuffer);
	    hYB->SetTextColor(4);
	    hYB->SetTextSize(0.033);
	    hYB->Draw();
	    c1->SetGridx();
	    c1->SetGridy();
	  }  // check for high mass plot
		
	  sprintf(graphOutputFileName, "pi0UnClassedUnpartionedYield_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // C macro
	  sprintf(graphOutputFileName, "pi0UnClassedUnpartionedYield_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // pdf
	  sprintf(graphOutputFileName, "pi0UnClassedUnpartionedYield_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // gif
		
	  //
	  // Obtain and plot the partitioned yields using this these mass window parameters
	  //

	  c1->Clear();
	  c1->Divide(NPHIBINS/3,3);
	  float subtractedFitCentroid[NPHIBINS];
	  float subtractedFitSigma[NPHIBINS];
	  for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	    double sameEventPartitionedYield = 0;
	    double subtractedPartitionedYield = 0;
	    double subtractedPartitionedYieldError = 0;
	    subtractedFitCentroid[kPhi] = 0.0;
	    subtractedFitSigma[kPhi] = 0.0;
			
	    for(int iBin=1; iBin<nMassBins; iBin++) {
	      double binCenter = pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetBinCenter(iBin);
	      if(binCenter >= lowFalsePairMassCut && binCenter <= highFalsePairMassCut) {
		sameEventPartitionedYield +=  pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetBinContent(iBin);
	      }
	    } // loop over mass bins
	    normFactorEtaPhiPt[kEta][kPhi][kPt] = sameEventPartitionedYield/mixedEventSum;
	    double thisNormFactor =  normFactorEtaPhiPt[kEta][kPhi][kPt];
	    pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt]->Clear();
	    for(int iBin=1; iBin<nMassBins; iBin++) {
	      double mixedEventContent = pi0MassEtaPtHistogramMixed[kEta][kPt]->GetBinContent(iBin);
	      double mixedEventContentNormalized = thisNormFactor*mixedEventContent;
	      pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt]->SetBinContent(iBin, mixedEventContentNormalized);
	      double mixedEventContentNormalizedError = 0.0;
	      if(mixedEventContent>0.0)
		mixedEventContentNormalizedError = mixedEventContentNormalized/sqrt(mixedEventContent);
	      double sameEventContent = pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->GetBinContent(iBin);
	      double subtractedContent = sameEventContent - mixedEventContentNormalized;
	      double subtractedContentError = sqrt(sameEventContent + mixedEventContentNormalizedError);
	      pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetBinContent(iBin, subtractedContent);
	      pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetBinError(iBin, subtractedContentError);
	      double binCenter = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinCenter(iBin);
	      if(subtractedYieldMinimumFactor <= 0.0 && binCenter >= lowMassCut && binCenter <= highMassCut) {
		subtractedPartitionedYield += subtractedContent;
		subtractedPartitionedYieldError += subtractedContentError*subtractedContentError;
	      }
	    } // loop over mass bins
			
	    if(subtractedYieldMinimumFactor > 0.0) {
	      lowMassCut2[kPhi] = 0.0;
	      highMassCut2[kPhi] = 0.0;
	      double maximumCountThisHistogram = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinContent(pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximumBin());
	      double minimumYieldForCount = subtractedYieldMinimumFactor*maximumCountThisHistogram;
	      for(int iBin=1; iBin<nMassBins; iBin++) {
		double binCenter = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinCenter(iBin);
		double subtractedContent = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinContent(iBin);
		double subtractedContentError = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetBinError(iBin); 
		if(lowMassCut2[kPhi] == 0.0 && subtractedContent >= minimumYieldForCount) {
		  //
		  // Set the low mass cut bin and count this bin
		  //
		  lowMassCut2[kPhi] = binCenter;
		  subtractedPartitionedYield += subtractedContent;
		  subtractedPartitionedYieldError += subtractedContentError*subtractedContentError;
		} // check on reaching the low mass cut
					
		if(binCenter > lowMassCut2[kPhi] && subtractedContent >= minimumYieldForCount) {
		  //
		  // Continue counting until below the minimum threshold
		  //
		  highMassCut2[kPhi] = binCenter;
		  subtractedPartitionedYield += subtractedContent;
		  subtractedPartitionedYieldError += subtractedContentError*subtractedContentError;		
		} // check on bin being above the low mass cut
					
		if(lowMassCut2[kPhi] > 0.0 && highMassCut2[kPhi] > 0.0 && subtractedContent < minimumYieldForCount) {
		  //
		  // Have reached the end of the integration region
		  //
		  break;
		} // check if the lowMassCut and highMass cut have been set, but the current yield is below the minimum threshold
					
	      } // loop over mass bins

	    } // check on doing a minimum threshold yield summation
				
	    c1->cd(kPhi + 1);

	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->Fit("gaus", "", "", lowMassCut2[kPhi], highMassCut2[kPhi]);
	    TF1 *fitPhiFcn = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetFunction("gaus");
	    subtractedFitCentroid[kPhi] = fitPhiFcn->GetParameter(1);
	    subtractedFitSigma[kPhi] = fitPhiFcn->GetParameter(2);		
			
	    pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetStats(0);
	    pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->SetLineWidth(2);
	    pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->Draw();
	    pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt]->SetFillColor(kYellow);
	    pi0MassEtaPhiPtHistogramMixedCopy[kEta][kPhi][kPt]->Draw("same");
	    pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt]->Draw("same");
	    subtractedYieldEtaPhiPt[kEta][kPhi][kPt] = subtractedPartitionedYield;
	    subtractedYieldEtaPhiPtError[kEta][kPhi][kPt] = sqrt(subtractedPartitionedYieldError);
	  } // loop over phi bins
		
	  sprintf(graphOutputFileName, "pi0Yields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // C macro
	  sprintf(graphOutputFileName, "pi0Yields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // gif file
	  sprintf(graphOutputFileName, "pi0Yields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // pdf file

	  c1->Clear();
	  c1->Divide(NPHIBINS/3,3);
	  for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	    c1->cd(kPhi + 1);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetStats(0);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetMarkerStyle(20);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetMarkerColor(2);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->SetMarkerSize(1.0);
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->Draw();
	    pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->Draw();
	    TLine *baseLine = new TLine(0.0, 0.0, maximumPi0MassForHistogram, 0.0);
	    baseLine->SetLineColor(kBlack);
	    baseLine->SetLineWidth(2);
	    baseLine->Draw();
			
	    char yieldBuffer[200];
	    sprintf(yieldBuffer, "Sum = %d +/- %d", int(subtractedYieldEtaPhiPt[kEta][kPhi][kPt]), int(subtractedYieldEtaPhiPtError[kEta][kPhi][kPt]));
	    TLatex *tYB = new TLatex(0.014, 0.70*pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximum(), yieldBuffer);
	    tYB->SetTextColor(4);
	    tYB->SetTextSize(0.050);
	    tYB->Draw();
			
	    char yieldBuffer2[200];
	    if(subtractedYieldMinimumFactor <= 0.0) {
	      sprintf(yieldBuffer2, "Sigma width factor %3.1f", subtractedYieldWidthFactor);
	      if(useAsymmetricMassCuts) {
		sprintf(yieldBuffer2, "Asymmetric width factors -%3.1f to +%3.1f", lowerAsymmetricWidthFactor, upperAsymmetricWidthFactor);
	      }
	    }
	    else {
	      sprintf(yieldBuffer2, "Yield minimum factor %4.2f", subtractedYieldMinimumFactor);
	    }
	    TLatex *tYB2 = new TLatex(0.014, 0.60*pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximum(), yieldBuffer2);
	    tYB2->SetTextColor(4);
	    tYB2->SetTextSize(0.045);
	    tYB2->Draw();

	    char fitBuffer1[200];
	    sprintf(fitBuffer1, "Centroid fit = %6.4f", subtractedFitCentroid[kPhi]);
	    TLatex *tFB1 = new TLatex(0.180, 0.70*pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximum(), fitBuffer1);
	    tFB1->SetTextColor(4);
	    tFB1->SetTextSize(0.050);
	    tFB1->Draw();
			
	    char fitBuffer2[200];
	    sprintf(fitBuffer2, "Sigma fit = %6.4f", subtractedFitSigma[kPhi]);
	    TLatex *tFB2 = new TLatex(0.180, 0.60*pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximum(), fitBuffer2);
	    tFB2->SetTextColor(4);
	    tFB2->SetTextSize(0.050);
	    tFB2->Draw();
			
	    cout << "\n kPt, kPhi " << kPt << ", " << kPhi << " :  centroid fit " << subtractedFitCentroid[kPhi] << ",  sigma fit " << subtractedFitSigma[kPhi] << endl;

	    float lowY = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMinimum();
	    float highY = pi0MassEtaPhiPtHistogramSubtracted[kEta][kPhi][kPt]->GetMaximum();

	    float lowX = lowMassCut2[kPhi];
	    float highX = highMassCut2[kPhi];
	    TLine *lowYieldCut = new TLine(lowX, lowY, lowX, highY);
	    lowYieldCut->SetLineColor(kMagenta);
	    lowYieldCut->SetLineWidth(1);
	    lowYieldCut->SetLineStyle(3);
	    lowYieldCut->Draw();

	    TLine *highYieldCut = new TLine(highX, lowY, highX, highY);
	    highYieldCut->SetLineColor(kMagenta);
	    highYieldCut->SetLineWidth(1);
	    highYieldCut->SetLineStyle(3);
	    highYieldCut->Draw();

	  } // loop over phi bins
		
	  sprintf(graphOutputFileName, "pi0SubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // C macro
	  sprintf(graphOutputFileName, "pi0SubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // gif file
	  sprintf(graphOutputFileName, "pi0SubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // pdf file
		
	  //
	  // Obtain the flow fit for this eta and pt bin
	  //
	  c1->Clear();
	  float xPlot[NPHIBINS];
	  float yPlot[NPHIBINS];
	  float xPlotErrors[NPHIBINS];
	  float yPlotErrors[NPHIBINS];
	  float yMax = 0.0;
	  float yMin = 1.0e+30;
	  for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	    xPlot[kPhi] = 0.5*(lowPhiBin[kPhi] + highPhiBin[kPhi]);
	    xPlotErrors[kPhi] = 0.0;
	    yPlot[kPhi] = subtractedYieldEtaPhiPt[kEta][kPhi][kPt];
	    if(yPlot[kPhi] > yMax)
	      yMax = yPlot[kPhi];
	    if(yPlot[kPhi] < yMin)
	      yMin = yPlot[kPhi];
	    yPlotErrors[kPhi] = subtractedYieldEtaPhiPtError[kEta][kPhi][kPt];
	  }
		
	  float yMinDefault = yMin/2.5;
	  float yMaxDefault = yMax*1.7;
		
	  int iMinY = yMin/100.0;
	  yMin = 100.0*(iMinY - 2);
	  if(yMin < 0.0)
	    yMin = 0.0;
		
	  if(yMin < yMinDefault)
	    yMin = yMinDefault;
		
	  int iMaxY = yMax/100.0;
	  if(iMaxY < 5)
	    yMax = 100.0*(iMaxY + 2);
	  else
	    yMax = 100.0*(iMaxY + 4);
		
	  if(yMax > yMaxDefault)
	    yMax = yMaxDefault;
		
	  if(graphFlow)
	    delete graphFlow;
		
	  graphFlow = new TGraphErrors(NPHIBINS, xPlot, yPlot, xPlotErrors, yPlotErrors);
	  graphFlow->SetLineColor(1);
	  graphFlow->SetLineWidth(2);
	  graphFlow->SetMarkerColor(4);
	  graphFlow->SetMarkerStyle(20);
	  graphFlow->SetMarkerSize(1.25);
	  char graphTitle[200];
	  if(toyModel) {
	    sprintf(graphTitle, "Toy Model #pi^{0} With v_{2} Flow: %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		    lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	  }
	  if(realData) {
	    sprintf(graphTitle, "#pi^{0} With v_{2} Flow: %d < Centrality < %d, %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		    lowCent, highCent, lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	  }
	  graphFlow->SetTitle(graphTitle);
	  graphFlow->GetXaxis()->SetTitle("#Phi_{Lab} _ #Phi_{RP} (radians)");	
	  graphFlow->GetYaxis()->SetTitle("Background Subtracted Yield");	
	  graphFlow->GetXaxis()->SetLimits(lowPhiBin[0], highPhiBin[NPHIBINS - 1]);
	  cout << "\n First: yMin " << yMin << " yMax " << yMax << " iMinY " << iMinY << " iMaxY " << iMaxY;
	  graphFlow->SetMinimum(yMin);
	  graphFlow->SetMaximum(yMax);										 
	  graphFlow->Draw("AP");
	  c1->SetGridx();
	  c1->SetGridy();
		
	  if(noFlowFitFcn)
	    delete noFlowFitFcn;
		
	  noFlowFitFcn = new TF1("noFlowFitFcn", constantBackground, 0.0, 2.0*TMath::Pi(), 2);
	  noFlowFitFcn->SetParName(1, "Constant");
	  noFlowFitFcn->SetParameter(0, 100.0);
	  graphFlow->Fit("noFlowFitFcn", "q0", "", 0.0, 2.0*TMath::Pi());
		
	  if(flowFitFcn)
	    delete flowFitFcn;
		
	  flowFitFcn =  new TF1("flowFitFcn", v2SinglesFit, 0.0, 2.0*TMath::Pi(), 2);
	  flowFitFcn->SetParName(0, "Normalization");
	  flowFitFcn->SetParName(1, "v_{2}");
	  flowFitFcn->SetParameter(0, 0.5*(yMin + yMax));
	  flowFitFcn->SetParameter(1, 0.01);
	  graphFlow->Fit("flowFitFcn", "", "", 0.0, 2.0*TMath::Pi());
	  v2FitUnClassedEtaPt[kEta][kPt] = flowFitFcn->GetParameter(1);
	  v2FitErrorUnClassedEtaPt[kEta][kPt] = flowFitFcn->GetParError(1);
						
	  if(toyModel) {
	    char toyRPBuffer[200];
	    if(useToyModelRPResolution) {
	      if(toyModelRPResolution >= 0.0) {
		sprintf(toyRPBuffer, "Assume a RP resolution parameter %4.2f radians", toyModelRPResolution);
	      }
	      else {
		sprintf(toyRPBuffer, "Assume a random Reaction Plane");
	      }
	    }
	    else {
	      sprintf(toyRPBuffer, "Assume a perfect RP resolution parameter");
	    }
			
	    TLatex *tRP = new TLatex(0.6, yMin + 0.7*(yMax - yMin), toyRPBuffer);
	    tRP->SetTextColor(4);
	    tRP->SetTextSize(0.030);
	    tRP->Draw();
	  }
		
	  char eventsBuffer[200];
	  sprintf(eventsBuffer, "Events processed %d", useEventsProcessed);
	  TLatex *tEV = new TLatex(1.1, yMin + 0.075*(yMax - yMin), eventsBuffer);
	  tEV->SetTextColor(4);
	  tEV->SetTextSize(0.025);
	  tEV->Draw();
		
	  if(!toyModel) {			
	    TLatex *tUnClass = new TLatex(0.1, yMin + 0.075*(yMax - yMin), "Fit sans event classes");
	    tUnClass->SetTextColor(2);
	    tUnClass->SetTextSize(0.025);
	    tUnClass->Draw();
			
	    char choiceBuffer[200];
	    switch(reactionPlaneAngleChoice) {
	    case 1:
	      sprintf(choiceBuffer, "Reaction Plane Angle Choice: HF");
	      break;
	    case 9:
	      sprintf(choiceBuffer, "Reaction Plane Angle Choice: EtaGapPair");
	      break;
	    default:
	      cerr << "\n Undefined reaction plane angle choice" << endl;
	      return;
	    } // switch according to reaction plane choice
			
	    TLatex *tCH = new TLatex(0.2, yMin + 0.90*(yMax - yMin), choiceBuffer);
	    tCH->SetTextColor(1);
	    tCH->SetTextSize(0.025);
	    tCH->Draw();
			
	    char yieldCutBuffer[200];
	    sprintf(yieldCutBuffer, "Cut interval = %3.1f #sigma,  S4/S9 cut %4.2f", subtractedYieldWidthFactor, clustS49Cut);
	    if(useAsymmetricMassCuts) {
	      sprintf(yieldCutBuffer, "Aymmetric cut = -%3.1f to +%3.1f #sigma,  S4/S9 cut %4.2f",lowerAsymmetricWidthFactor, upperAsymmetricWidthFactor, clustS49Cut);
	    }
	    TLatex *tCY = new TLatex(0.10, yMin + 0.83*(yMax - yMin), yieldCutBuffer);
	    tCY->SetTextColor(1);
	    tCY->SetTextSize(0.022);
	    tCY->Draw();
			
	  }
	  else {
	    TLatex *tCO = new TLatex(0.1, yMin + 0.075*(yMax - yMin), "Toy model v_{2} = 0.20");
	    tCO->SetTextColor(4);
	    tCO->SetTextSize(0.025);
	    tCO->Draw();
	  }
		
	  sprintf(graphOutputFileName, "pi0FlowUnClassedFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // C macro
	  sprintf(graphOutputFileName, "pi0FlowUnClassedFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // gif file
	  sprintf(graphOutputFileName, "pi0FlowUnClassedFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	  c1->Print(graphOutputFileName);  // pdf file
		
	} // check for subtracted yield > 10 for a given eta and pt bin

      } // loop over pt bins

    } // loop over eta bins

    //
    // Class decomposition approach:
    //                               same as unclassed approach except pi0MassEtaPtHistogramMixed[kEta][kPt] is replaced by  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] ,
    //                               pi0MassEtaPtHistogram[kEta][kPt] is replaced by pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent] , and
    //                               pi0MassEtaPhiPtHistogram[kEta][kPhi][kPt] is replaced by pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]
    //
    // 1) Normalize the yield in the pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] histogram to the yield in the pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent] in a "false" mass region, e.g. 200 - 250 MeV
    // 2) Make a copy of the pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] histogram, with the counts normalized, and call this pi0MassEtaPtRPZVertCentHistogramMixedCopy[kEta][kPt][kRP][kZVert][kCent]
    // 3) Subtract this normalized copy from the pi0MassEtaPtHistogram[kEta][kPt][kRP][kZVert][kCent] to make pi0MassEtaPtRPZVertCentHistogramSubtracted[kEta][kPt][kRP][kZVert][kCent]
    // 4) Fit the pi0MassEtaPtRPZVertCentHistogramSubtracted[kEta][kPt][kRP][kZVert][kCent] histogram in order to obtain the Gauss peak width, which establishes the mass integration window for this [kEta][kPt][kRP][kZVert][kCent] bin
    // 5) Normalize the yield in the  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] histogram to the yield in each of the pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent] in a "false" mass region, e.g. 200 - 250 MeV
    // 6) Make a copy of the pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent] histogram, with the counts normalized, and call this pi0MassEtaPhiPtRPZVertCentHistogramMixedCopy[kEta][kPhi][kPt][kRP][kZVert][kCent]
    // 7) Subtract this normalized copy from the pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent] to make pi0MassEtaPhiPtRPZVertCentHistogramSubtracted[kEta][kPhi][kPt][kRP][kZVert][kCent]
    // 8) Integrate the counts in pi0MassEtaPhiPtRPZVertCentHistogramSubtracted[kEta][kPhi][kPt][kRP][kZVert][kCent] using the mass window found in step 4)
    // 9) Sum the integrated counts over the RPClass, ZVClass, and CentClass divisions for each [kEta][kPt] bin
    //

    double mixedEventPreNormalizedYieldClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float normFactorEtaPtClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    TH1D *pi0MassEtaPtHistogramMixedCopyClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    TH1D *pi0MassEtaPtHistogramSubtractedClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float lowMassEtaPtClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float highMassEtaPtClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float subtractedYieldEtaPtClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float subtractedYieldEtaPtErrorClass[NETABINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float normFactorEtaPhiPtClass[NETABINS][NPHIBINS][NPTBINS][RPClass][ZVertClass][CentClass];
    TH1D *pi0MassEtaPhiPtHistogramMixedCopyClass[NETABINS][NPHIBINS][NPTBINS][RPClass][ZVertClass][CentClass];
    TH1D *pi0MassEtaPhiPtHistogramSubtractedClass[NETABINS][NPHIBINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float subtractedYieldEtaPhiPtClass[NETABINS][NPHIBINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float subtractedYieldEtaPhiPtErrorClass[NETABINS][NPHIBINS][NPTBINS][RPClass][ZVertClass][CentClass];
    float sumSubtractedYieldEtaPhiPtClass[NETABINS][NPHIBINS][NPTBINS];
    float sumSubtractedYieldEtaPhiPtErrorClass[NETABINS][NPHIBINS][NPTBINS];
    float v2FitClassedEtaPt[NETABINS][NPTBINS];
    float v2FitErrorClassedEtaPt[NETABINS][NPTBINS];
    TH1D *pi0MassEtaPtHistogramSubtractedClassSummed[NETABINS][NPTBINS];

    //
    // Construct utility histograms
    //
    for(unsigned int kRP=0; kRP<RPClass; kRP++) {
      for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	for(unsigned int kCent=0; kCent<CentClass; kCent++) {
	  for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
	    for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	      if(kRP==0 && kZVert==0 && kCent==0) {
		sprintf(histogramName, "pi0MassSubtactedClassSummedEtaBin%dPtBin%d", kEta, kPt);
		sprintf(histogramTitle, "Class summed background-subtracted #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f",
			lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
		pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
		pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
		pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetYTitle(countsPerBin);
		pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->Clear();
	      } // first class pass check
	      sprintf(histogramName, "pi0MassSubtactedEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
	      sprintf(histogramTitle, "Background-subtracted #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
		      lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
	      pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	      pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	      pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->SetYTitle(countsPerBin);
	      sprintf(histogramName, "pi0MassMixedCopyEtaBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPt, kRP, kZVert, kCent);
	      sprintf(histogramTitle, "Copy of Mixed-Event #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
		      lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
	      pi0MassEtaPtHistogramMixedCopyClass[kEta][kPt][kRP][kZVert][kCent] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
	      pi0MassEtaPtHistogramMixedCopyClass[kEta][kPt][kRP][kZVert][kCent]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	      pi0MassEtaPtHistogramMixedCopyClass[kEta][kPt][kRP][kZVert][kCent]->SetYTitle(countsPerBin);
	      for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
		sprintf(histogramName, "pi0MassSubtactedEtaBin%dPhiBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPhi, kPt, kRP, kZVert, kCent);
		sprintf(histogramTitle, "Background-subtracted #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPhi], highPhiBin[kPhi], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
		pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
		pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetYTitle(countsPerBin);

		sprintf(histogramName, "pi0MassMixedCopyEtaBin%dPhiBin%dPtBin%dRPClass%dZVertClass%dCentClass%d", kEta, kPhi, kPt, kRP, kZVert, kCent);
		sprintf(histogramTitle, "MixedCopy #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < #phi < %5.2f, %5.2f < p_{T} < %5.2f, RP%d, ZV%d",
			lowEtaBin[kEta], highEtaBin[kEta], lowPhiBin[kPt], highPhiBin[kPt], lowPtBin[kPt], highPtBin[kPt], kRP, kZVert);
		pi0MassEtaPhiPtHistogramMixedCopyClass[kEta][kPhi][kPt][kRP][kZVert][kCent] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, maximumPi0MassForHistogram);
		pi0MassEtaPhiPtHistogramMixedCopyClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
		pi0MassEtaPhiPtHistogramMixedCopyClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetYTitle(countsPerBin);

	      } // loop over phi bins
	    } // loop over pT bins
	  } // loop over eta bins
	} // loop over Cent Class
      } // loop over ZVert Class
    } // loop over RP Class

    //
    // initialize the sums over the classes
    //
    for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
      for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  sumSubtractedYieldEtaPhiPtClass[kEta][kPhi][kPt] = 0.0;
	  sumSubtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt] = 0.0;
	} // loop over phi bins
      } // loop over eta bins
    } // loop over pT bins

    for(unsigned int kRP=0; kRP<RPClass; kRP++) {
      for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	for(unsigned int kCent=0; kCent<CentClass; kCent++) {

	  for(unsigned int kEta=kEtaLow; kEta<kEtaHigh; kEta++) {

	    for(unsigned int kPt=kPtLow; kPt<kPtHigh; kPt++) {

	      //
	      // Obtain the background-subtracted yields for this event class
	      //

	      double sameEventSum = 0;
	      double mixedEventSum = 0;

	      for(int iBin=1; iBin<nMassBins; iBin++) {
		double binCenter = pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->GetBinCenter(iBin);
		if(binCenter >= lowFalsePairMassCut && binCenter <= highFalsePairMassCut) {
		  sameEventSum +=  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		  mixedEventSum += pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		}
	      } // loop over all mass bins

	      mixedEventPreNormalizedYieldClass[kEta][kPt][kRP][kZVert][kCent] = mixedEventSum;
	      if(mixedEventSum > 0.0) {
		normFactorEtaPtClass[kEta][kPt][kRP][kZVert][kCent] = sameEventSum/mixedEventSum;
	      }
	      else {
		cout << "\n Class skipping kEta " << kEta << ", kPt " << kPt << " bin" << endl;
		continue; // skip this kEta, kPt bin
	      }

	      //
	      // Make the normalized copy mixed event histogram and the subtracted same event histogram for this (eta, pt) bin, in this event class
	      //
	      double subtractedYield = 0;
	      double subtractedYieldError = 0;

	      for(int iBin=1; iBin<nMassBins; iBin++) {
		double mixedEventContent =  pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		double mixedEventContentNormalized = mixedEventContent*normFactorEtaPtClass[kEta][kPt][kRP][kZVert][kCent];
		pi0MassEtaPtHistogramMixedCopyClass[kEta][kPt][kRP][kZVert][kCent]->SetBinContent(iBin, mixedEventContentNormalized);
		double mixedEventContentNormalizedError = 0.0;
		if(mixedEventContent > 0.0)
		  mixedEventContentNormalizedError = mixedEventContentNormalized/sqrt(mixedEventContent);
		pi0MassEtaPtHistogramMixedCopyClass[kEta][kPt][kRP][kZVert][kCent]->SetBinError(iBin, mixedEventContentNormalizedError);

		double sameEventContent =  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		double subtractedContent = sameEventContent - mixedEventContentNormalized;

		double binCenter = pi0MassEtaPtHistogram[kEta][kPt]->GetBinCenter(iBin);
		if(binCenter > 0.10 && binCenter < 0.20) {
		  subtractedYield += subtractedContent;
		  subtractedYieldError += sameEventContent + mixedEventContentNormalizedError;
		}

		double subtractedContentError = sqrt(sameEventContent + mixedEventContentNormalizedError);
		pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->SetBinContent(iBin, subtractedContent);
		pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->SetBinError(iBin, subtractedContentError);
		double classSummedContent = pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->GetBinContent(iBin);
		double classSummedError = pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->GetBinError(iBin);  // this error will be in quadrature during the summing loop
		pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetBinContent(iBin, classSummedContent + subtractedContent);	
		pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetBinError(iBin, classSummedError + subtractedContentError*subtractedContentError);	 // this error will be in quadrature during the summing loop
					
	      } // loop over all mass bins

	      cout << "\n For kEta " << kEta << ", kPt " << kPt << ", kRP " << kRP << ", kZVert " << kZVert << ", kCent " << kCent;
	      cout << "\n   norm factor = " << normFactorEtaPtClass[kEta][kPt][kRP][kZVert][kCent];
	      cout << ",  mixed event yield = " << pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->GetSum();
	      cout << ",  same event yield = " <<  pi0MassEtaPtRPZVertCentHistogram[kEta][kPt][kRP][kZVert][kCent]->GetSum();
	      cout << ",  subtracted yield total = " << subtractedYield << " +/- " <<  sqrt(subtractedYieldError);
	      cout << endl;
				
	      lowMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent] = 0.0;
	      highMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent] = -1.0;
				
	      //
	      // Fit the unpartitioned subtracted yield to obtain the mass window parameters for this event class
	      //
	      if(subtractedYield > 10.0) {
					
		pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->Fit("gaus", "", "", subtractedStart, subtractedEnd);
		TF1 *fitFcn = pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->GetFunction("gaus");
		lowMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent] =  fitFcn->GetParameter(1) - subtractedYieldWidthFactor*fabs(fitFcn->GetParameter(2));
		highMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent] = fitFcn->GetParameter(1) + subtractedYieldWidthFactor*fabs(fitFcn->GetParameter(2));
		if(useAsymmetricMassCuts) {
		  lowMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent] =  fitFcn->GetParameter(1) - lowerAsymmetricWidthFactor*fabs(fitFcn->GetParameter(2));
		  highMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent] = fitFcn->GetParameter(1) + upperAsymmetricWidthFactor*fabs(fitFcn->GetParameter(2));
		}
		cout << "\n Parameter 0 " << fitFcn->GetParameter(0);
		cout << ",  parameter 1 " << fitFcn->GetParameter(1);
		cout << ",  parameter 2 " << fitFcn->GetParameter(2);
		cout << "\n Low mass cut = " <<  lowMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent];
		cout << ",  high mass cut = " << highMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent];
					
		double integratedYield = 0;
		double integratedYieldError = 0;
		double lowMassCut = lowMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent];
		double highMassCut = highMassEtaPtClass[kEta][kPt][kRP][kZVert][kCent];
		if(useUnClassedMassWindow) {
		  lowMassCut = lowMassEtaPt[kEta][kPt];
		  highMassCut = highMassEtaPt[kEta][kPt];
		}
					
		for(int iBin=1; iBin<nMassBins; iBin++) {
		  double binCenter = pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->GetBinCenter(iBin);
		  if(binCenter >= lowMassCut && binCenter <= highMassCut) {
		    integratedYield +=  pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		    double binError =  pi0MassEtaPtHistogramSubtractedClass[kEta][kPt][kRP][kZVert][kCent]->GetBinError(iBin);
		    integratedYieldError += binError*binError;
		  } // check on mass bin in pi0 mass window
		} // loop over mass bins
					
		subtractedYieldEtaPtClass[kEta][kPt][kRP][kZVert][kCent] = integratedYield;
		subtractedYieldEtaPtErrorClass[kEta][kPt][kRP][kZVert][kCent] = sqrt(integratedYieldError);
		cout << "\n Integrated yield = " << integratedYield << " +/- " <<  sqrt(integratedYieldError);
		cout << endl;
					
		//
		// Obtain and plot the partitioned yields using this these mass window parameters
		//
					
		char graphOutputFileName[200];
		int useRunNumber = runNumber;
		if(toyModel)
		  useRunNumber = 0;
					
		c1->Clear();
		c1->Divide(NPHIBINS/3,3);
		for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
		  double sameEventPartitionedYield = 0;
		  double subtractedPartitionedYield = 0;
		  double subtractedPartitionedYieldError = 0;
		  for(int iBin=1; iBin<nMassBins; iBin++) {
		    double binCenter = pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->GetBinCenter(iBin);
		    if(binCenter >= lowFalsePairMassCut && binCenter <= highFalsePairMassCut) {
		      sameEventPartitionedYield +=  pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		    }
		  } // loop over mass bins
						
		  normFactorEtaPhiPtClass[kEta][kPhi][kPt][kRP][kZVert][kCent] = sameEventPartitionedYield/mixedEventSum;
		  double thisNormFactor =  normFactorEtaPhiPtClass[kEta][kPhi][kPt][kRP][kZVert][kCent];
		  pi0MassEtaPhiPtHistogramMixedCopyClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->Clear();
						
		  for(int iBin=1; iBin<nMassBins; iBin++) {
		    double mixedEventContent = pi0MassEtaPtRPZVertCentHistogramMixed[kEta][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		    double mixedEventContentNormalized = thisNormFactor*mixedEventContent;
		    pi0MassEtaPhiPtHistogramMixedCopyClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetBinContent(iBin, mixedEventContentNormalized);
		    double mixedEventContentNormalizedError = 0.0;
		    if(mixedEventContent>0.0)
		      mixedEventContentNormalizedError = mixedEventContentNormalized/sqrt(mixedEventContent);
		    double sameEventContent = pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->GetBinContent(iBin);
		    double subtractedContent = sameEventContent - mixedEventContentNormalized;
		    double subtractedContentError = sqrt(sameEventContent + mixedEventContentNormalizedError);
		    pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetBinContent(iBin, subtractedContent);
		    pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetBinError(iBin, subtractedContentError);
		    double binCenter = pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->GetBinCenter(iBin);
		    if(binCenter >= lowMassCut && binCenter <= highMassCut) {
		      subtractedPartitionedYield += subtractedContent;
		      subtractedPartitionedYieldError += subtractedContentError*subtractedContentError;
		    }
		  } // loop over mass bins
						
		  c1->cd(kPhi + 1);
						
		  pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetStats(0);
		  pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetLineWidth(2);
		  pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->Draw();
		  pi0MassEtaPhiPtHistogramMixedCopyClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetFillColor(kYellow);
		  pi0MassEtaPhiPtHistogramMixedCopyClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->Draw("same");
		  pi0MassEtaPhiPtRPZVertCentHistogram[kEta][kPhi][kPt][kRP][kZVert][kCent]->Draw("same");
		  subtractedYieldEtaPhiPtClass[kEta][kPhi][kPt][kRP][kZVert][kCent] = subtractedPartitionedYield;
		  subtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt][kRP][kZVert][kCent] = sqrt(subtractedPartitionedYieldError);
						
		} // loop over phi bins
					
		sprintf(graphOutputFileName, "pi0Yields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d_RP%d_ZV%d_Cent%d.C",
			useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date, kRP, kZVert, kCent);
		c1->Print(graphOutputFileName);  // C macro
		sprintf(graphOutputFileName, "pi0Yields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d_RP%d_ZV%d_Cent%d.gif",
			useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date, kRP, kZVert, kCent);	
		c1->Print(graphOutputFileName);  // gif file
		sprintf(graphOutputFileName, "pi0Yields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d_RP%d_ZV%d_Cent%d.pdf",
			useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date, kRP, kZVert, kCent);									
		c1->Print(graphOutputFileName);  // pdf file

		c1->Clear();
		c1->Divide(NPHIBINS/3,3);
		for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
		  c1->cd(kPhi + 1);
		  pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetStats(0);
		  pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetMarkerStyle(20);
		  pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetMarkerColor(2);
		  pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->SetMarkerSize(1.0);
		  pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->Draw();
		  TLine *baseLine = new TLine(0.0, 0.0, maximumPi0MassForHistogram, 0.0);
		  baseLine->SetLineColor(kBlack);
		  baseLine->SetLineWidth(2);
		  baseLine->Draw();
		  char yieldBuffer[200];
		  sprintf(yieldBuffer, "Sum = %d +/- %d", int(subtractedYieldEtaPhiPtClass[kEta][kPhi][kPt][kRP][kZVert][kCent]), int(subtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt][kRP][kZVert][kCent]));
		  TLatex *tYB = new TLatex(0.014, 0.70*pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->GetMaximum(), yieldBuffer);
		  tYB->SetTextColor(4);
		  tYB->SetTextSize(0.050);
		  tYB->Draw();

		  float lowY = pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->GetMinimum();
		  float highY =  pi0MassEtaPhiPtHistogramSubtractedClass[kEta][kPhi][kPt][kRP][kZVert][kCent]->GetMaximum();

		  TLine *lowYieldCut = new TLine(lowMassCut, lowY, lowMassCut, highY);
		  lowYieldCut->SetLineColor(kMagenta);
		  lowYieldCut->SetLineWidth(1);
		  lowYieldCut->SetLineStyle(3);
		  lowYieldCut->Draw();

		  TLine *highYieldCut = new TLine(highMassCut, lowY, highMassCut, highY);
		  highYieldCut->SetLineColor(kMagenta);
		  highYieldCut->SetLineWidth(1);
		  highYieldCut->SetLineStyle(3);
		  highYieldCut->Draw();

		} // loop over phi bins

		sprintf(graphOutputFileName, "pi0SubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d_RP%d_ZV%d_Cent%d.C",
			useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date, kRP, kZVert, kCent);
		c1->Print(graphOutputFileName);  // C macro
		sprintf(graphOutputFileName, "pi0SubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d_RP%d_ZV%d_Cent%d.gif",
			useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date, kRP, kZVert, kCent);	
		c1->Print(graphOutputFileName);  // gif file
		sprintf(graphOutputFileName, "pi0SubtractedYields_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d_RP%d_ZV%d_Cent%d.pdf",
			useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date, kRP, kZVert, kCent);									
		c1->Print(graphOutputFileName);  // pdf file
		
	      } // check on subtractedYield > 10.0

	    } // loop over pT bins

	  } // loop over eta bins

	} // loop over Cent Class
      } // loop over ZVert Class
    } // loop over RP Class

    //
    // Sum the subtracted yields in each event class for each (eta, pt) bin
    //
    //
    for(unsigned int kRP=0; kRP<RPClass; kRP++) {
      for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
	for(unsigned int kCent=0; kCent<CentClass; kCent++) {
	  for(unsigned int kEta=0; kEta<NETABINS; kEta++) {
	    for(unsigned int kPt=0; kPt<NPTBINS; kPt++) {
	      for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
		sumSubtractedYieldEtaPhiPtClass[kEta][kPhi][kPt] += subtractedYieldEtaPhiPtClass[kEta][kPhi][kPt][kRP][kZVert][kCent];
		double errorSum = subtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt][kRP][kZVert][kCent];
		sumSubtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt] += errorSum*errorSum;  // add errors in quadrature, square root is taken in the kPhi loop below
	      } // loop over phi bins
	    } // loop over pT bins
	  } // loop over eta bins
	} // loop over Cent Class
      } // loop over ZVert Class
    } // loop over RP Class

    bool printSumResults = true;

    for(unsigned int kEta=kEtaLow; kEta<kEtaHigh; kEta++) {
      for(unsigned int kPt=kPtLow; kPt<kPtHigh; kPt++) {
	double integratedYield = 0.0;
	double integratedYieldError = 0.0;
	double lowMassCut = lowMassEtaPt[kEta][kPt];
	double highMassCut = highMassEtaPt[kEta][kPt];
	for(int iBin=1; iBin<=nMassBins; iBin++) {
	  double classSummedError = pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->GetBinError(iBin);
	  if(classSummedError > 0.0) {
	    pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetBinError(iBin, sqrt(classSummedError));
	  }
	  double binCenter = pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetBinCenter(iBin);
	  if(binCenter >= lowMassCut && binCenter <= highMassCut) {
	    integratedYield += pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->GetBinContent(iBin);
	    integratedYieldError += classSummedError;  // still in quadrature
	  }
	} // loop over mass bins
	c1->Clear();
	//
	// Re-do the title??
	//
	char newTitle[200];
	sprintf(newTitle, "Class summed background-subtracted #pi^{0} for %5.2f < #eta < %5.2f, %5.2f < p_{T} < %5.2f",
		lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	cout << "\n New Title " << newTitle << endl;
	pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetTitle(newTitle);
	pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetStats(0);
	pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetMarkerStyle(20);
	pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetMarkerStyle(20);
	pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetMarkerColor(2);
	pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->SetMarkerSize(1.0);
	pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->Draw();
				
	TLine *baseLine = new TLine(0.0, 0.0, maximumPi0MassForHistogram, 0.0);
	baseLine->SetLineColor(kBlack);
	baseLine->SetLineWidth(2);
	baseLine->Draw();				
				
	char yieldBuffer[200];
	sprintf(yieldBuffer, "Sum = %d +/- %d", int(integratedYield), int(sqrt(integratedYieldError)));
	TLatex *tYB = new TLatex(0.014, 0.70*pi0MassEtaPtHistogramSubtracted[kEta][kPt]->GetMaximum(), yieldBuffer);
	tYB->SetTextColor(4);
	tYB->SetTextSize(0.033);
	tYB->Draw();
				
	float lowY = pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->GetMinimum();
	float highY = pi0MassEtaPtHistogramSubtractedClassSummed[kEta][kPt]->GetMaximum();
				
	TLine *lowYieldCut = new TLine(lowMassCut, lowY, lowMassCut, highY);
	lowYieldCut->SetLineColor(kMagenta);
	lowYieldCut->SetLineWidth(1);
	lowYieldCut->SetLineStyle(3);
	lowYieldCut->Draw();
				
	TLine *highYieldCut = new TLine(highMassCut, lowY, highMassCut, highY);
	highYieldCut->SetLineColor(kMagenta);
	highYieldCut->SetLineWidth(1);
	highYieldCut->SetLineStyle(3);
	highYieldCut->Draw();
				
	char graphOutputFileName[200];
	int useRunNumber = runNumber;
	if(toyModel)
	  useRunNumber = 0;		
				
	sprintf(graphOutputFileName, "pi0ClassedUnpartionedYield_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	c1->Print(graphOutputFileName);  // C macro
	sprintf(graphOutputFileName, "pi0ClassedUnpartionedYield_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	c1->Print(graphOutputFileName);  // pdf
	sprintf(graphOutputFileName, "pi0ClassedUnpartionedYield_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	c1->Print(graphOutputFileName);  // gif
				 
	//
	// Obtain the flow fit for this eta and pt bin using the summed class yields
	//
	c1->Clear();
	float xPlot[NPHIBINS];
	float yPlot[NPHIBINS];
	float xPlotErrors[NPHIBINS];
	float yPlotErrors[NPHIBINS];
	float yMax = 0.0;
	float yMin = 1.0e+30;
	if(printSumResults)
	  cout << "\n\n Summed results for kEta = " << kEta << " and kPt = " << kPt;
	for(unsigned int kPhi=0; kPhi<NPHIBINS; kPhi++) {
	  if(sumSubtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt] > 0.0)
	    sumSubtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt] = sqrt(sumSubtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt]);  // take square root of quadrature errors
	  if(printSumResults) {
	    cout << "\n kPhi = " << kPhi << "  Unclassed = " << subtractedYieldEtaPhiPt[kEta][kPhi][kPt] << " +/- " << subtractedYieldEtaPhiPtError[kEta][kPhi][kPt];
	    cout << ";  Classed = " <<  sumSubtractedYieldEtaPhiPtClass[kEta][kPhi][kPt] << " +/- " << sumSubtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt];
            cout << endl;
	    for(unsigned int kRP=0; kRP<RPClass; kRP++) {
	      for(unsigned int kZVert=0; kZVert<ZVertClass; kZVert++) {
		cout << "  " <<  subtractedYieldEtaPhiPtClass[kEta][kPhi][kPt][kRP][kZVert][0] << " +/- " <<  subtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt][kRP][kZVert][0] << ", ";
	      } // sum over ZVERT classes
	    } // sum over RP classes
	  } // check on printing intermediate results
	  xPlot[kPhi] = 0.5*(lowPhiBin[kPhi] + highPhiBin[kPhi]);
	  xPlotErrors[kPhi] = 0.0;
	  yPlot[kPhi] = sumSubtractedYieldEtaPhiPtClass[kEta][kPhi][kPt];
	  if(yPlot[kPhi] > yMax)
	    yMax = yPlot[kPhi];
	  if(yPlot[kPhi] < yMin)
	    yMin = yPlot[kPhi];
	  yPlotErrors[kPhi] = sumSubtractedYieldEtaPhiPtErrorClass[kEta][kPhi][kPt];
	}
	if(printSumResults)
	  cout << endl << endl;
       
	float yMinDefault = yMin/2.5;
	float yMaxDefault = yMax*1.7;
		
	int iMinY = yMin/100.0;
	yMin = 100.0*(iMinY - 2);
	if(yMin < 0.0)
	  yMin = 0.0;
		
	if(yMin < yMinDefault)
	  yMin = yMinDefault;
		
	int iMaxY = yMax/100.0;
	if(iMaxY < 5)
	  yMax = 100.0*(iMaxY + 2);
	else
	  yMax = 100.0*(iMaxY + 4);
		
	if(yMax > yMaxDefault)
	  yMax = yMaxDefault;
		
	if(graphFlow)
	  delete graphFlow;
		
	graphFlow = new TGraphErrors(NPHIBINS, xPlot, yPlot, xPlotErrors, yPlotErrors);
	graphFlow->SetLineColor(1);
	graphFlow->SetLineWidth(2);
	graphFlow->SetMarkerColor(4);
	graphFlow->SetMarkerStyle(20);
	graphFlow->SetMarkerSize(1.25);
	char graphTitle[200];
	if(toyModel) {
	  sprintf(graphTitle, "Toy Model #pi^{0} With v_{2} Flow: %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	}
	if(realData) {
	  sprintf(graphTitle, "#pi^{0} With v_{2} Flow: %d < Centrality < %d, %5.2f < |#eta| < %5.2f, %5.2f < p_{T} < %5.2f ",
		  lowCent, highCent, lowEtaBin[kEta], highEtaBin[kEta], lowPtBin[kPt], highPtBin[kPt]);
	}
	graphFlow->SetTitle(graphTitle);
	graphFlow->GetXaxis()->SetTitle("#Phi_{Lab} _ #Phi_{RP} (radians)");	
	graphFlow->GetYaxis()->SetTitle("Background Subtracted Yield");	
	graphFlow->GetXaxis()->SetLimits(lowPhiBin[0], highPhiBin[NPHIBINS - 1]);
	cout << "\n First: yMin " << yMin << " yMax " << yMax << " iMinY " << iMinY << " iMaxY " << iMaxY;
	graphFlow->SetMinimum(yMin);
	graphFlow->SetMaximum(yMax);										 
	graphFlow->Draw("AP");
	c1->SetGridx();
	c1->SetGridy();
		
	if(noFlowFitFcn)
	  delete noFlowFitFcn;
		
	noFlowFitFcn = new TF1("noFlowFitFcn", constantBackground, 0.0, 2.0*TMath::Pi(), 2);
	noFlowFitFcn->SetParName(1, "Constant");
	noFlowFitFcn->SetParameter(0, 100.0);
	graphFlow->Fit("noFlowFitFcn", "q0", "", 0.0, 2.0*TMath::Pi());
		
	if(flowFitFcn)
	  delete flowFitFcn;
		
	flowFitFcn =  new TF1("flowFitFcn", v2SinglesFit, 0.0, 2.0*TMath::Pi(), 2);
	flowFitFcn->SetParName(0, "Normalization");
	flowFitFcn->SetParName(1, "v_{2}");
	flowFitFcn->SetParameter(0, 0.5*(yMin + yMax));
	flowFitFcn->SetParameter(1, 0.01);
	graphFlow->Fit("flowFitFcn", "", "", 0.0, 2.0*TMath::Pi());
	v2FitClassedEtaPt[kEta][kPt] = flowFitFcn->GetParameter(1);
	v2FitErrorClassedEtaPt[kEta][kPt] = flowFitFcn->GetParError(1);
						
	if(toyModel) {
	  char toyRPBuffer[200];
	  if(useToyModelRPResolution) {
	    if(toyModelRPResolution >= 0.0) {
	      sprintf(toyRPBuffer, "Assume a RP resolution parameter %4.2f radians", toyModelRPResolution);
	    }
	    else {
	      sprintf(toyRPBuffer, "Assume a random Reaction Plane");
	    }
	  }
	  else {
	    sprintf(toyRPBuffer, "Assume a perfect RP resolution parameter");
	  }
			
	  TLatex *tRP = new TLatex(0.6, yMin + 0.7*(yMax - yMin), toyRPBuffer);
	  tRP->SetTextColor(4);
	  tRP->SetTextSize(0.030);
	  tRP->Draw();
	}
		
	char eventsBuffer[200];
	sprintf(eventsBuffer, "Events processed %d", useEventsProcessed);
	TLatex *tEV = new TLatex(1.1, yMin + 0.075*(yMax - yMin), eventsBuffer);
	tEV->SetTextColor(4);
	tEV->SetTextSize(0.025);
	tEV->Draw();
		
	if(!toyModel) {
			
	  char classBuffer[200];
	  sprintf(classBuffer, "Fit with %d RP Classes and %d ZVert Classes", RPClass, ZVertClass);
	  TLatex *tClass = new TLatex(0.1, yMin + 0.075*(yMax - yMin), classBuffer);
	  tClass->SetTextColor(2);
	  tClass->SetTextSize(0.025);
	  tClass->Draw();
			
	  char choiceBuffer[200];
	  switch(reactionPlaneAngleChoice) {
	  case 1:
	    sprintf(choiceBuffer, "Reaction Plane Angle Choice: HF");
	    break;
	  case 9:
	    sprintf(choiceBuffer, "Reaction Plane Angle Choice: EtaGapPair");
	    break;
	  default:
	    cerr << "\n Undefined reaction plane angle choice" << endl;
	    return;
	  } // switch according to reaction plane choice
			
	  TLatex *tCH = new TLatex(0.2, yMin + 0.90*(yMax - yMin), choiceBuffer);
	  tCH->SetTextColor(1);
	  tCH->SetTextSize(0.025);
	  tCH->Draw();
			
	  char yieldCutBuffer[200];
	  sprintf(yieldCutBuffer, "Cut interval = %3.1f #sigma,  S4/S9 cut %4.2f", subtractedYieldWidthFactor, clustS49Cut);
	  if(useAsymmetricMassCuts) {
	    sprintf(yieldBuffer, "Asymmetric width factors -%3.1f to +%3.1f", lowerAsymmetricWidthFactor, upperAsymmetricWidthFactor);
	  }
	  TLatex *tCY = new TLatex(0.10, yMin + 0.83*(yMax - yMin), yieldCutBuffer);
	  tCY->SetTextColor(1);
	  tCY->SetTextSize(0.022);
	  tCY->Draw();

	  char yieldCutBuffer2[200];
	  if(useUnClassedMassWindow)
	    sprintf(yieldCutBuffer2, "Using the same mass window as the unclassed events");
	  else
	    sprintf(yieldCutBuffer2, "Using different mass window for each event class");

	  TLatex *tCY2 = new TLatex(0.10, yMin + 0.78*(yMax - yMin), yieldCutBuffer2);
	  tCY2->SetTextColor(1);
	  tCY2->SetTextSize(0.020);
	  tCY2->Draw();
			
	}
	else {
	  TLatex *tCO = new TLatex(0.1, yMin + 0.075*(yMax - yMin), "Toy model v_{2} = 0.20");
	  tCO->SetTextColor(4);
	  tCO->SetTextSize(0.025);
	  tCO->Draw();
	}

	sprintf(graphOutputFileName, "pi0FlowClassedFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.C", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	c1->Print(graphOutputFileName);  // C macro
	sprintf(graphOutputFileName, "pi0FlowClassedFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.gif", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	c1->Print(graphOutputFileName);  // gif file
	sprintf(graphOutputFileName, "pi0FlowClassedFits_Run%d_Centrality%d-%d_Pt%3.1f-%3.1f_Eta%4.2f-%4.2f_%d.pdf", useRunNumber, lowCent, highCent, lowPtBin[kPt], highPtBin[kPt], lowEtaBin[kEta], highEtaBin[kEta], date);
	c1->Print(graphOutputFileName);  // pdf file

      } // loop over pT bins
    } // loop over eta bins

    cout << "\n For " << useEventsProcessed << " events in centralities " << lowCent << "-" << highCent << "% the UnClassed and Classed v2 results for S49 cut " << clustS49Cut;
    if(!useAsymmetricMassCuts) {
      cout << ", mass width window " << subtractedYieldWidthFactor << " sigma about centroid";
    }
    else {
      cout << ", asymmetric mass width window " << -lowerAsymmetricWidthFactor << " to +" << upperAsymmetricWidthFactor << " sigma about centroid";
    }
    for(unsigned int kEta=kEtaLow; kEta<kEtaHigh; kEta++) {
      for (unsigned int kPt=kPtLow; kPt<kPtHigh; kPt++) {
	cout << "\n For " <<  lowEtaBin[kEta] << " < eta < " << highEtaBin[kEta] << " and ";
	cout << lowPtBin[kPt] << " < pT < " << highPtBin[kPt] << "  the unclassed fit result v2 = " << v2FitUnClassedEtaPt[kEta][kPt];
	cout << " +/- " <<  v2FitErrorUnClassedEtaPt[kEta][kPt];
	cout <<" ;  the classed fit result v2 = " << v2FitClassedEtaPt[kEta][kPt];
	cout << " +/- " <<  v2FitErrorClassedEtaPt[kEta][kPt];
      } // loop over pT bins
    } // loop over eta bins
    cout << endl;

  } //  iOption from 21 to 26, looking at the unclassed and classed decompositions.

  cout << "\n Macro is exiting " << endl;
  return;

}
