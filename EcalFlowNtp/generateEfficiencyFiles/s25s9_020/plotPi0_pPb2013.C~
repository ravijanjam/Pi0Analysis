#ifndef PLOTPI0
#define PLOTPI0

//
// ROOT macro for making plots from 2013 pPb, pp, and MC analysis for the pi0 and for the eta-meson
//
// Usage with a single integer input option, assumes a first.root exists in working directory (a second.root is necessary only for iOption=0)
//
//          .L plotPi0_pP2013.C++             
//          plotPi0_pPb2013(iOption)
//
// The option choices for plotPi0_pPb2013
// The first set of choices iOption = 0 -> 5  replot the one-dimensional mass histograms stored by the EcalFlowNtp analyzer,
// and sometimes generate background subtracted mass histograms with fits. Most of the options require only one input file,
// with the generic name first.root, although iOption = 0 compares to input files
//
// The iOption choices 10 and above loop over the h/Tree entries, which enables more sophisticated logic control.
// Only one input file first.root is required for these options
//
//  Options 0 - 5 to look at pair mass histograms originally produced by the EcalFlowNtp analyzer
//  0 -> Compare pi0 mass plots for two cluster eta limits from two different ROOT input files
//       First input file has name "first.root" (can be a softlink) which has the eta < 1.49 limit
//       Second input file has name "second.root" which has eta < 1.30 limit
//
//  2 -> Uses only one input file ("first.root"), this is the default
//       This option was used to show the high mass plots up to 0.800 GeV/c^2
//
//  1 -> Uses only one input file ("first.root")
//       Does mixed-event background subtraction for the pi0 mass peaks
//       The mixed-event normalization region is given by the lowMassBackground and highMassBackground values
//
//  3 -> Shows eta-meson mass region, with foreground and normalized, mixed-event background
//
//  4 -> Does simultaneous foreground+background fitting for the eta-meson mass region
//       Plots subtracted mass histograms and integrated yields for each pT bin (2 x 4 panel figure)
//
//  5 -> Same as option 4 except only the 4 highest pT bins are plotted (2 x 2 panel figure)
//
//  6 -> Fitting to derive the energy correction function in terms of the inverse ptEcal values
//
//
//  Options 10 - 13  look at charged particle track matching with ECAL clusters
//  iOption = 10 Produces a 6-panel figure for the azimuthal residuals of the tracking-ECAL matching
//
//  iOption = 11 Projects into TH1D dPhi1 for the Delta-phi residual of secondary tracks matched to ECAL clusters
//               TH1D dTheta1 for the Delta-theta residual of these secondary tracks, TH1D dPhi0 for the
//               Delta-phi of the primary tracks, and TH1D Delta-theta of the primary tracks. A 4-panel figure is produced.
//
//  iOption = 12 Produces a 2-panel figure with Delta-Theta residuals as a function of the Dz of the track vertex displacement
//
//  iOption = 13 Produces a 2-panel figure with the Deltah-Thetar residuals as a function of the primary vertex Z value
//
//  iOption = 14 Looks at the particle ID variable E/p as a function of the tracking-ECAL matching residual
//
//  iOption = 15 Looks at the Delta-Theta residual as a function of the Cluster-Z value, for primaries and secondaries
//               The histograms are generated by direct projection from the hTree
//
//  iOption = 16 Does the same as iOption = 15 except it uses a loop over the hTree entries instead of direct projection (loop may be faster)
//
//  iOption = 17 Looks at E/P matching result as a function of ptClu and the outerPtTrackMatch check
//
//
//  Options 18 - 19 Look at photon conversion effects
//
//  iOption = 18 Looks at the primary photon conversion history, producing a 2-panel plot according to the eta and the pT values
//               The photons are identified in the mergedTrackingTruth collection
//
//  iOption = 19  Produces a 4-panel figure looking at the tracking-ECAL residuals for unconverted photons
//  iOption = -19 Produces a similar 4-panel figure for the photons which had a conversion
//
//  iOption = 20 Produces a 4-panel figure which looks at the pT reconstruction errors for unconverted and converted photons
//
//  iOption = 21 Produces a 6-panel figure which looks at the pi0 mass reconstruction from ECAL clusters produced by primary
//               unconverted photons before and after an energy reconstruction
//
//  iOption =  22 Produces a 6-panel figure which looks at the pi0 mass reconstruction from all ECAL clusters, before and after an energy correction
//  iOption = -22 Produces a 6-panel figure which looks at the pi0 mass reconsruction form ECAL clusters which are not matched to a charged track,
//                also comparing before and after energy correction
//
//  iOption = 23 Produces a 4-panel figure which looks at the pi0 reconstruction efficiency in two dimensions: eta and p_T
//  iOption = -23 The same except that decays with subsequent conversions of either photon are excluded
//  iOption = 231 Produces a 1-panel figure which looks at the pi0 reconstruction efficiency in two dimensions: eta and p_t
//  iOption = -231 The same 1-panel figure except that decays with subsequent conversions of either photon are excluded
//  iOption = 232 Produces a 2-panel figure which looks at the pi0 reconstruction efficiency in two dimensions: eta and p_T
//  iOption = -232 The same 2-panel figure except that decays with subsequent conversions of either photon are excluded
//  iOption = 233 MC: Produce a 4-panel figure looking at the reconstructed eta for a given generator meson in four low pT bins
//  iOption = 234 MC: Produce a 1-panel surface plot of the foreground pi0-charged particles pairs correlations
//  iOption = 235 MC: Produce a 1-panel surface plot of the mixed-event pi0-charged particles pairs correlations
//  iOption = 236 MC: Produce a 1-panel surface plot of the foreground divided by mixed-event pi0-charged particles pairs correlations
//  iOption = 237 MC: Produce a 7-panel with 1D histograms containing fits to the azimuthal correlation distribution
//
//  iOption = 24 Produces a 4-panel figure which looks at the pi0 reconstruction efficiency in one dimension (eta or p_T),
//               integrating over the other dimension
//  iOption = -24 Same as iOption = 24, except the conversion cases are omitted
//
//  iOption = 25, 26 Same as iOption 23, 24 except that the eta-meson choice is used
//                   eta-meson mass = 547.51 MeV with several decay modes: 39% into 2-gamma, 32% into 3-pi0, 23% into pi+pi-pi-0, 5% into pi+pi-gamma
//                   Only eta-mesons with the 2-gamma branch are selected for plotting
//
//  iOption = 27 Produces a 2x2 panel figure looking at the generator pT spectrum for pi0 and eta, before and after 300 MeV/c cut on decay photons
//
//  iOption = 28 (-28) Produces a 2x1 panel figure for the pi0 (eta) decay photon conversion spectra using photon variables
//
//  iOption = 29 (-29) Produces a 2x4 panel mass figure for the pT-binned pi0 (eta) yields
//
//  iOption = 30 (-30) Produces a 2x4 panel pT resolution figure for the pT-binned pi0 (eta) yields
//
//  iOption = 31, 32, 33  Produce a 2x2 panel of the mass spectra for pT bins 0.7-1.0, 1.0-1.5, 1.5-2.0, and 2.0-2.5
//                including mixed-event backgrounds
//
//  iOption = 34 (-34) Check energy asymmetery cut for pi0 (eta-meson)
//
//  iOption = 35, same as iOption = 33 but for the generator mesons
//
//  iOption= -35, same as iOption = 35 but randomizing photon azimuthal angles
//
//  iOption = 36, plot azimuthal angles of single mesons and pairs of mesons, with the decay photons
//
//  iOption = -36, plot the eta distribution of single mesons in different pT bins
//
//  iOption = 37, plot contour of E1 vs E2 of decay photons
//
//  iOption = 38, look at pi0 pairs and triplets
//
//  iOption = 39, check pi0 pT spectra according to parent
//
//  iOption = 40, 41 look at correlations between resonant decay particles, and between no-parent pizero using generator meson collection
//
//  iOption = 42 look at K0-short decay pizero in the simTracks collection
//
//  iOption = 43 Produce single histograms for use in the toy model macro
//
//  iOption = 44 Study the conversion daughters
//
//  iOption = 45 Produce the normalized HBT pair correlations
//
//  iOption = 46 Produce the foreground HBT pair correlations
//
//  iOption = 47 Produce the background HBT pair correlations
//
//  iOption = 53
//
//  iOption = 54 to 60
//
//  iOption = 61 Produce eta distributions in 4 low pT bins: foreground and conversion suppressed
//
//  iOption = 70 to 72

//  iOption = 334 RECO: Produce a 1-panel surface plot of the foreground pi0-charged particles pairs correlations
//  iOption = 335 RECO: Produce a 1-panel surface plot of the mixed-event pi0-charged particles pairs correlations
//  iOption = 336 RECO: Produce a 1-panel surface plot of the foreground divided by mixed-event pi0-charged particles pairs correlations
//  iOption = 337 RECO: Produce a 7-panel with 1D histograms containing fits to the azimuthal correlation distribution

#include  <iostream>
#include <fstream>
#include <math.h>

#include <TROOT.h>
#include <TFile.h>
#include <TSystem.h>
#include <TStyle.h>
#include <TNtuple.h>
#include <TCanvas.h>
#include <TH1F.h>
#include <TH2F.h>
#include <TGaxis.h>
#include <TMath.h>
#include <TRandom3.h>
#include <TLatex.h>
#include <TF1.h>
#include <TMultiGraph.h>
#include <TGraphErrors.h>
#include <TAxis.h>
#include <TLine.h>
#include <TDatime.h>
#include <TLegend.h>

#include <DataFormats/Math/interface/deltaPhi.h>

#endif

using namespace std;

//
// Function definitions for fitting the mass spectra
//

// two-parameter correction function
Double_t quadraticFunction(Double_t *x, Double_t *par) {
  return par[0]*x[0] + par[1]*x[0]*x[0];
}

// three-parameter correction function
Double_t correctionFunction(Double_t *x, Double_t *par) {
  return par[0]*x[0] + par[1]*x[0]*x[0] + par[2]*pow(x[0],3);
}

// two-parameter linear background function
Double_t linearBackground(Double_t *x, Double_t *par) {
  return par[0] + par[1]*x[0];
}

// Quadratic background function
Double_t quadraticBackground(Double_t *x, Double_t *par) {
  return par[0] + par[1]*x[0] + par[2]*x[0]*x[0];
}

// Square root background function
Double_t squareRootBackground(Double_t *x, Double_t *par) {
  return par[0] + par[1]*x[0] + par[2]*sqrt(fabs(x[0]));
}


// Gauss peak function
Double_t gaussPeak(Double_t *x, Double_t *par) {
  if(par[2] != 0.0) {
    double arg = x[0] - par[1];
    return par[0]*exp(-arg*arg/(2.0*par[2]*par[2]));
  }
  return 0.0;
}

// Double Gauss peak function
Double_t doubleGaussPeak(Double_t *x, Double_t *par) {
  if(par[2] != 0.0 && par[5] !=0) {
    double arg1 = x[0] - par[1];
    double arg2 = x[0] - par[4];
    return par[0]*exp(-arg1*arg1/(2.0*par[2]*par[2])) + par[3]*exp(-arg2*arg2/(2.0*par[5]*par[5]));
  }
  
  return 0.0;
  
}

// Double Gauss peak function, fix centroid of second peak at 0.0
Double_t doubleGaussPeakFixed(Double_t *x, Double_t *par) {
  if(par[2] != 0.0 && par[4] !=0) {
    double arg1 = x[0] - par[1];
    double arg2 = x[0];
    return par[0]*exp(-arg1*arg1/(2.0*par[2]*par[2])) + par[3]*exp(-arg2*arg2/(2.0*par[4]*par[4]));
  }
  
  return 0.0;
  
}

// sum of two-parameter linear background and a Gaussian peak function
Double_t fitFunctionLinear(Double_t *x, Double_t *par) {
  return linearBackground(x,par) + gaussPeak(x,&par[2]);
}

// sum of quadratic background and peak function
Double_t fitFunctionQuadratic(Double_t *x, Double_t *par) {return quadraticBackground(x,par) + gaussPeak(x,&par[3]);
}

// sum of square root background and peak function
Double_t fitFunctionSquareRoot(Double_t *x, Double_t *par) {return squareRootBackground(x,par) + gaussPeak(x,&par[3]);
}

Float_t crystalCorrectionFunction(Int_t indexCrystal, Float_t ecalEnergy) {
	
  //
  // Energy correction factors according to number of crystals in the cluster
  //
  const float crystalEnergyCorrection[9] = {0.283, 0.154, 0.0766, 0.0547, 0.0605, 0.0669, 0.05556, 0.0413, 0.0165};
	
  const float singleCrystalIntercept = 0.341838;
  const float singleCrystalSlope = -0.091967;
	
  const float doubleCrystalIntercept = 0.13094;
  const float doubleCrystalSlope = 0.042173;
	
  const float secondOrderEnergyCorrection = 1.007;
  
  if(indexCrystal == 0)
    return secondOrderEnergyCorrection*ecalEnergy*(1.0 + singleCrystalIntercept + singleCrystalSlope*ecalEnergy);
  
  if(indexCrystal == 1)
    return secondOrderEnergyCorrection*ecalEnergy*(1.0 + doubleCrystalIntercept + doubleCrystalSlope*ecalEnergy);
  
  if(indexCrystal > 1 && indexCrystal < 9)
    return  secondOrderEnergyCorrection*ecalEnergy*(1.0 + crystalEnergyCorrection[indexCrystal]);
  
  return 0.0; // default error value
  
}

// Gaussian correlation for HBT pairs in a single momentum coordinate
const double inverseFermiToGeV = 0.19733;
Double_t gausCorrelation(Double_t *x, Double_t *par) {
  double arg = x[0]*par[0]/inverseFermiToGeV;
  return 1.0 + par[1]*exp(-arg*arg);
}

// Gaussian correlation for HBT pairs in a three dimensional momentum coordinates, units of GeV/c and Fermi
const double fixedRLong = 5.5;
const double fixedROut = 5.5;
const double fixedRSide = 5.5;

Double_t gaus3DCorrelation(double qLong, double qOut, double qSide, double lambda) {
  double argLong = qLong*fixedRLong/inverseFermiToGeV;
  double argOut = qOut*fixedROut/inverseFermiToGeV;
  double argSide = qSide*fixedRSide/inverseFermiToGeV;
  return 1.0 + lambda*exp(-(argLong*argLong + argOut*argOut + argSide*argSide));
}

double FourierFunction(double *x, double *par) {
  double sig = par[0]*(1.0 + 2*par[1]*TMath::Cos(x[0]) + 2*par[2]*TMath::Cos(2.0*x[0]) + 2*par[3]*TMath::Cos(3.0*x[0]));
  return sig;
}

Double_t v1v2Fit(Double_t *x, Double_t *par) {
  return par[0]*(1.0 + 2.0*par[1]*cos(x[0]) + 2.0*par[2]*cos(2.0*x[0]));
}

Double_t v2Fit(Double_t *x, Double_t *par) {
  return par[0]*(1.0 + 2.0*par[1]*cos(2.0*x[0]));
}

// End of function definitions

const double rECal = 1.29;                         // radial distance of ECAL

const bool printPairContributors = false;
int countPairContributors_ = 0;

void plotPi0_pPb2013(const int iOption = 33,        // default plotting of two pT bins of background-subtracted pair mass spectra
		     const Long64_t maxEntries = -1,        // scan over all events in tree
		     const int pTQuartile = 1,              // which pair of the 8 pT bins (1 is the first pair, 2 the second pair, 3 the third pair, 4 the fourth pair)
                     const int kPtBinEDM = 1,               // default to pT = 1.0 - 1.5 GeV/c bin for EDM pair mass spectrum choice
		     const float paramWidthScale = 4.0,     // parameterized background fitting at =/- paramWidthScale*sigma about centroid
		     const int iMultOption = 4,             // use 120-160 track multiplicity bin
                     const bool simRun = true,             // denotes that first.root is from a simulation analysis
		     const bool monikaFile = false,          // no hTree in these files
                     const bool ppRun = false,              // denotes that first.root is from pp data
                     const bool pPbRunNormal = false,        // denotes that first.root is from the first set of pPb data
                     const bool pPbRunReverse = false,      // denotes that first.root is from the reverse (second set) of pPb data
                     const bool useTrackMatchSuppression = false, // suppress use of ECAL clusters which have a track match
                     const float lowEnergyCutParameter = 0.30,  // minimum ECAL energy for an accepted cluster
                     const int simulationTruthChoice = 2,     // Use of mergedTrackTruth or simTracks for checking the MC truth (e.g. conversions)
                     const bool useConversionSuppression = false, // suppress converted photons for MC input
		     const float clustS25Cut = 0.2,          // default = 1.0, Monika was using 0.2
		     const float widthForEfficiency = 0.015,  // for the 331 efficiency option, the accepted reco are within +/- widthForEfficiency (GeV/c^2) of the 0.134976 MeV pi0 value
		     const bool useTrackEfficiencyTable = false,     // using external efficiency root file for charged track losses
                     const bool usePi0EfficiencyTable = false,     // using external efficiency root file for pi0 losses
                     const bool useClusterCrystalLimit = true, // using a range of crystal numbers in the energy correction determination
                     const int lowCrystalLimit = 1,         // lower limit for the crystals numbers
                     const int highCrystalLimit = 1,        // upper limit for the crystal numbers
                     const bool useClusterPairCrystalSumLimit = false,
                     const int lowClusterPairCrystalSumLimit = 2,       // lower limit on the sum of the crystals in a cluster pair
                     const int highClusterPairCrystalSumLimit = 2,      // upper limit on the sum of the crystals in a cluster pair
		     const bool useClusterCrystalLimitLowPtOnly = true,  // using the cluster crystal limits only on low pT pi0
		     const float clusterCrystalLimitLowPtOnly = 1.5,  // low pT pi0 cut for using cluster crystal limits
		     const bool useHighPurityTracks = true,           // using high purity tracks
                     const int lowTracksLimit = 120,         // low limit for the number of tracks in the event (either NHITracks or high purity tracks)
                     const int highTracksLimit = 260,      // high limit for the number of tracks in the event (either NHITracks or high purity tracks)
		     const bool useAverageNormalization = false, // using an average of the lower and the upper regions for the background normalization
                     const bool useDoubleNormalization = true,  // using both a lower and and upper region for the background normalization
                     const bool useFixedOpeningAngleCut = true, // pT-dependent opening angle cut for pi0
                     const bool recoTrackStore = false,
                     const bool clusterStore = true,
                     const bool clusterRecoTrackStore = false,
                     const bool pairCorrTracksStore = true,
                     const bool mesonStore = true,
		     const bool chmesonStore = false,
                     const bool photonStore = false) {

  //
  // Event counts in tracking bins for set of 525,804 minimum bias events
  // nHITracks 1 - 24 =    108,027
  // nHITracks 25 - 49 =    91,989
  // nHITracks 50 - 89 =   118,470
  // nHITracks 90 - 129 =   99,119
  // nHITracks 130 - 499 = 108,199
  //

  const bool printKaonResiduals = false;
  const bool plotKaonResiduals = false;
  // const bool plotNoConvResiduals = true; // for future use
  const bool useNoRecalRenorm = false;
  const float noRecalRenormFactor = 1.023;

  TDatime *dateTime = new TDatime;
  dateTime->Set();     // set to system date/time
  int date = dateTime->GetDate();

  char *asciiDate = new char[50];
  dateTime->AsString(asciiDate);
  cout << "\n Date " << asciiDate << endl;

  if(iMultOption >= 0 && iMultOption <=3 && !useHighPurityTracks) {
    cout << "\n Requesting a highPt triggered sample but not using high purity tracks" << endl;
    return;
  }

  char *multText = new char[100];

  int lowMultiplicity = lowTracksLimit;
  int highMultiplicity = highTracksLimit;
  char *multiplicityText = new char[200];
  bool goodMultOption = false;

  if(iMultOption == 4) {
    sprintf(multText, "EcalFlowNtp/NeutralPions/");
    goodMultOption = true;
    sprintf(multiplicityText, "%d < #leq N_{track}^{offline} < %d", lowMultiplicity, highMultiplicity);
  }

  if(iMultOption == 0) {
    sprintf(multText, "EcalFlowNtpMult100/NeutralPions/");
    lowMultiplicity = 120;
    highMultiplicity = 150;
    goodMultOption = true;
    sprintf(multiplicityText, "120 #leq N_{track}^{offline} < 150");
  }

  if(iMultOption == 1) {
    sprintf(multText, "EcalFlowNtpMult130/NeutralPions/");
    lowMultiplicity = 150;
    highMultiplicity = 185;
    goodMultOption = true;
    sprintf(multiplicityText, "150 #leq N_{track}^{offline} < 185");
  }

  if(iMultOption == 2) {
    sprintf(multText, "EcalFlowNtpMult160/NeutralPions/");
    lowMultiplicity = 185;
    highMultiplicity = 220;
    goodMultOption = true;
    sprintf(multiplicityText, "185 #leq N_{track}^{offline} < 220");
  }

  if(iMultOption == 3) {
    sprintf(multText, "EcalFlowNtpMult190/NeutralPions/");
    lowMultiplicity = 220;
    highMultiplicity = 260;
    goodMultOption = true;
    sprintf(multiplicityText, "220 #leq N_{track}^{offline} < 260");
  }

  if(!goodMultOption) {
   cerr << "\n Multiplicity option " << iMultOption << " is not valid" << endl;
    return;
  } // safety check

  //
  // Additions for making 2-D pair correlations plots
  //

  const bool simTrackStore = true;
  if(simTrackStore && !simRun) {
    cerr << "\n Cannot have simTrackStore as true while simRun is false" << endl;
    return;
  } // safety check

  const bool simSlimTrackStore = true;
  const bool useDeltaPhiCMS = true;
  const bool usePtDependentSeparation = false;  // original (pre-May 15) analysis
  const double lowMassBackground = 0.220;   // Monika's number 0.200, was originally 0.225 for single normalization, current best choice is 0.220 for double normalization
  const double highMassBackground = 0.270;  // Monika's number 0.250, was originally 0.275 for single normalization, current best choice is 0.270 for double normalization

  if(useDoubleNormalization && useAverageNormalization) {
    cerr << "\n Cannot set useDoubleNormalization  and  useAverageNormalization both as true" << endl;
    return;
  } // safety check

  bool useSingleNormalization = true;
  if(useDoubleNormalization || useAverageNormalization)
    useSingleNormalization = false;

  const bool useRotatedBackground = false;  // using rotated cluster method to do the background in iOptions 32, 33, ...
  const float conversionSuppressionFraction = 1.0; // if there is a conversion, then probability that this conversion is suppressed

  const double lowMassBackgroundDouble = 0.045;    // if a double normalization is being used, 0.03
  const double highMassBackgroundDouble = 0.085;   // if a double normalization is being used, 0.08

  double lowMidMassBackgroundDouble = 0.5*(highMassBackgroundDouble + lowMassBackgroundDouble);  // mid-mass for first (lower) normalization interval
  double highMidMassBackgroundDouble = 0.5*(highMassBackground + lowMassBackground);             // mid-mass for second(higher) normalization interval
  double backgroundInverseDenominatorDouble = 1.0/(highMidMassBackgroundDouble - lowMidMassBackgroundDouble);

  const bool useOnlyNonDecay = false;     // use only mesons which do not have mother particles
  const bool useOnlyDecay = false;        // use only mesons which are decays from mother particles

  const bool useOnlyNoMother = false;      // use primary photons only
  const bool excludeNoMother = false;     // exclude the primary photons

  const bool useOnlyPdg111 = false;        // use only pi0 for the iOption = 20 energy correction diagnosis, or pi0 mothers
  const bool excludePdg111 = false;       // exclude pi0 mothers

  const bool useOnlyPdg221 = false;       // use only eta for the iOption = 20 energy correction diagnosis

  const bool useOnlyPdg221GParent = false;   // use only the eta(547) as a grandparent
  const bool excludePdg221GParent = false;  // exclude the eta(547) as a grandparent

  const bool useOnlyKaonGParent = false;   // use only the kaons as a grandparent
  const bool excludeKaonGParent = false;  // exclude the kaons as a grandparent
  const bool checkKaon = useOnlyKaonGParent || excludeKaonGParent;

  const bool useOnlyValidGParent = false;   // use an valid grandparent (eta, eta-prime, rho, omega, kaon) 
  const bool excludeValidGParent = false;  // exclude the above grandparents

  if(excludePdg111 && useOnlyPdg111) {
    cerr << "\n Cannot require pi0 parents and exclude pi0 parents simultaneously\n";
    return;
  }  // safety check

  if(excludeKaonGParent && useOnlyKaonGParent) {
    cerr << "\n Cannot require kaon grandparents and exclude kaon grandparents simultaneously\n";
    return;
  }  // safety check

  if(excludePdg221GParent && useOnlyPdg221GParent) {
    cerr << "\n Cannot require eta grandparents and exclude eta grandparents simultaneously\n";
    return;
  }  // safety check

  if(useOnlyValidGParent && useOnlyKaonGParent) {
    cerr << "\n Cannot have any valid grandparent and only the kaon grandparent\n";
    return;
  } // safety check

  if(useOnlyValidGParent && useOnlyPdg221GParent) {
    cerr << "\n Cannot have any valid grandparent and only the eta grandparent\n";
    return;
  } // safety check

  if(excludeValidGParent && useOnlyPdg221GParent) {
    cerr << "\n Cannot exclude valid grandparent and include the eta grandparent\n";
    return;
  } // safety check

  if(excludeValidGParent && useOnlyKaonGParent) {
    cerr << "\n Cannot exclude valid grandparent and include the kaon grandparent\n";
    return;
  } // safety check

  if(simSlimTrackStore && (useOnlyKaonGParent || useOnlyPdg221GParent ||  excludeKaonGParent || excludePdg221GParent || useOnlyValidGParent || excludeValidGParent) ){
    cerr <<"\n Cannot check grandparents if simSlimTrackStore is false" << endl;
    return;
  } // safety check


  const Long64_t skipEntries = 0;
  if(skipEntries > 0) {
    cout << "\n The initial set of " << skipEntries << " events will be skipped" << endl;
  }

  const bool useHijing = false;
  const bool useEPOS = true;

  if(useHijing && useEPOS) {
    cerr << "\n Cannot set simultaneously useHijing as true and set useEPOS as true as true" << endl;
    return;
  }

  const bool selectSameParentClusters = false;        // the parent ID is determined only for non-converted photons
  const bool selectDifferentParentClusters = false;  // the parent ID is determined only for non-converted photons
  if(selectSameParentClusters && selectDifferentParentClusters) {
    cerr << "\n Cannot set selectSameParentClusters  and  selectDifferentParentClusters both as true" << endl;
    return;
  } // safety check

  if((selectSameParentClusters || selectDifferentParentClusters) && !simTrackStore) {
    cerr << "\n Cannot set selectSameParentClusters  or selectDifferentParentClusters as true unless simTrackStore is also true" << endl;
  } // safety check

  const bool selectConversionMixed = false;
  const bool selectConversionOnly = false;
  const bool selectNonConversionOnly = false;

  if(selectConversionOnly && selectNonConversionOnly) {
    cerr << "\n Cannot set  selectConversionOnly  and  selectNonConversionOnly both as true" << endl;
    return;
  } // safety check

  if(selectConversionMixed && selectNonConversionOnly) {
    cerr << "\n Cannot set  selectConversionMixed  and  selectNonConversionOnly  both as true" << endl;
    return;
  } // safety check

  if(selectConversionOnly && selectConversionMixed) {
    cerr << "\n Cannot set  selectConversionOnly  and  selectConversionMixed  both as true" << endl;
    return;
  }

  if(useConversionSuppression && (selectConversionOnly || selectNonConversionOnly || selectConversionMixed)) {
    cerr << "\n Cannot set  useConversionSuppression  as true  and then have either  selectConversionOnly  or  selectNonConversionOnly  or  selectConversionMixed  as true" << endl;
    return;
  } // safety check

  const bool testConversion = selectSameParentClusters || selectDifferentParentClusters|| useConversionSuppression || selectConversionOnly || selectNonConversionOnly || selectConversionMixed;

  if(testConversion && !simTrackStore) {
    cerr << "\n Cannot have an option to check photon conversion unless simTrackStore is true" << endl;
    return;
  } // safety check

  const bool useEtaSymmetry = true;
  const bool useRecoEta = false;    // using reco eta in MC check
  const bool useRecoPt = false;    // using reco pT in MC check
  const bool checkRecoMass = false;  // check the reco mass in the MC
  const bool checkDecayEnergy = false; // check the decay energies of the two photons in the MC

  //
  // Only one of the following can be true, and one must be true if iOption == 33
  //
  const bool useTwoSideBands = false;
  const bool usePeakRegion = true;
  const bool useLowSideBand = false;
  const bool useHighSideBand = false;

  int countTrueValues = 0;
  if(useTwoSideBands) {
    cout << "\n Using two sidebands mass regions for the mass background v2";
    countTrueValues++;
  }
  if(usePeakRegion) {
    cout << "\n Using the pi0 mass window for the observed v2 region";
    countTrueValues++;
  }
  if(useLowSideBand) {
    cout << "\n Using one sideband below the pi0 for the background v2";
    countTrueValues++;
  }
  if(useHighSideBand) {
    cout << "\n Using one sideband above the pi0 for the background v2";
    countTrueValues++;
  }

  if(countTrueValues > 1) {
    cerr << "\n Too many mass regions are set for calculating a pair correlations value" << endl;
    return;
  } // safety check
  cout << endl;

  if(countTrueValues == 0 && iOption == 337) {
    cerr << "\n No mass regions is set for calculating a pair correlations value" << endl;
    return;
  } // safety check

  if(checkDecayEnergy && usePi0EfficiencyTable) {
    cerr << "\n Cannot set simulataneously checkDecayEnergy as true and set usePi0EfficencyTable as true" << endl;
    return;
  } // safety check

  if(checkRecoMass && usePi0EfficiencyTable) {
    cerr << "\n Cannot set simulataneously checkRecoMass as true and set usePi0EfficencyTable as true" << endl;
    return;
  } // safety check

  if(useTwoSideBands && usePeakRegion) {
    cerr << "\n Cannot request peak region and dual sideband regions simultaneously" << endl;
    return;
  }

  float lowLimitPi0Mass = 0.105;  // true value at 0.095, side band at 0.210
  float highLimitPi0Mass = 0.165; // true value at 0.175, side band at 0.290

  float lowLimitSideBandMass = 0.190;  // second side band low edge
  float highLimitSideBandMass = 0.250; // second side band high edge

  if(useHighSideBand) {
    //
    // upper and lower edges of high side band
    //
    lowLimitPi0Mass = 0.190;  // true value at 0.095, side band at 0.210
    highLimitPi0Mass = 0.260; // true value at 0.175, side band at 0.290
  }

  if(useLowSideBand || useTwoSideBands) {
    //
    // upper and lower edges of high side band
    //
    lowLimitPi0Mass = 0.030;  // true value at 0.095, side band at 0.210
    highLimitPi0Mass = 0.090; // true value at 0.175, side band at 0.290
   }

  const bool useMCTracks = false;
  if(useMCTracks && (iOption < 334 || iOption > 337)) {
    cerr << "\n iOption = " << iOption << ", but setting useMCTracks to be true is only valid when 334 <= iOption <= 337" << endl; 
    return;
  } // consistency check for iOption and useMCTracks

  if(iOption >= 334 && iOption <= 337) {
    if(useMCTracks)
      cout << "\n Using MC charged particles instead of reconstructed tracks for pair correlations study" << endl;
    else
      cout << "\n Using reconstructed tracks for pair correlations study" << endl;
  }

  if(!pairCorrTracksStore && iOption >= 334 && iOption <= 337) {
    cerr << "\n Cannot request iOption = 334 to 337 when pairCorrTracksStore is set to false" << endl;
    return;
  }

  if(useConversionSuppression && usePi0EfficiencyTable) {
    cerr << "\n Cannot have useConversionSuppression and usePi0EfficiencyTable both set to be true" << endl << endl;
    return;
  } // safety check

  // const int nMult_trgAllEvents = 2725614;
  const int nMult_trgAllEventsPt[8] = {315803, 215026, 76638, 30042, 13334, 6185, 3163, 2351};

  const int nPtBinsComplete = 8;
  const float lowPtBinCompleteLimit[8] =  {0.8, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0};
  const float highPtBinCompleteLimit[8] = {1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0};
  int nTriggers_PtBin[8] = {0, 0, 0, 0, 0, 0, 0, 0};

  float v2FitValue[nPtBinsComplete];
  float v2FitError[nPtBinsComplete];

  const bool useV1V2Fit = true;
  const bool useV2FitOnly = false;

  if(useV1V2Fit && useV2FitOnly) {
    cerr << "\n Cannot set simultaneously us2V1V2Fit as true and useV2FitOnly as true" << endl;
    return;
  } // safety check

  const float ptMin_trg = 0.70;  // minimum pT for pi0 trigger particle in a pair
  const float ptMax_trg = 5.0;   // maximum pT for pi0 trigger particle in a pair
  const float ptMin_ass = 0.30;  // minimum pT for an associated charged particle in a pair
  const float ptMax_ass = 3.0;   // maximum pT for an associated charged particle in a pair
  const int NBUFFERDEPTH = 10;

  const bool useTripleRecoDepth = true;

  const float recoPtChange = 1.00;

  const bool mcParticleStore = false;
  const bool mergedTrackTruthStore = false;
  if(!simRun && mergedTrackTruthStore) {
    cerr << "\n Cannot have a data run with mergedTrackTruthStore as true" << endl;
    return;
  } // safety check

  if(iOption == 231 && (!mesonStore || !mergedTrackTruthStore)) {
    //
    // mergedTrackTruth is needed in EDM analyzer to compute the reco mass
    //
    cerr << "\n Cannot have iOption = 231 for static pi0 efficiency with mesonStore as false" << endl;
    return;
  } // safety check

  if(iOption == 331 && (!simTrackStore || !selectSameParentClusters)) {
    cerr << "\n Cannot have iOption = 331 for dynamic pi0 efficiency with simTrackStore as false or selectSameParentClusters as false" << endl;
    return;
  } // safety check

  const bool useClusterShapeCuts = false;
  const bool useClusterShapeVariables = true;

  if(useClusterShapeCuts && !useClusterShapeVariables) {
    cerr <<"\n\n  Cannot have useClusterShapeCuts set to true and useClusterShapeVariables set to false" << endl << endl;
    return;
  }  // safety check

  const double etaLowLimit = -1.50;       // accept  etaLowLimit <= |eta| <= etaHighLimit
  const double etaHighLimit = 1.50;       // accept  etaLowLimit <= |eta| <= etaHighLimit

  const float shapeCutValue = 0.50;
  int totalShapeExaminePhotons = 0;
  int totalShapeCutPhotons = 0;

  const bool useHBT = false;             // do weighting according to an HBT pairs correlation function
  const float lambdaHBT = 1.0;           // lambda value in HBT pairs correlation function


  const int nMassBins = 75;
  const float highMass = 0.30;
  const float clustS49Cut = 0.74;
  const float clustS1Cut = 0.2;

  const bool useEnergyVsTimingCut = false;  // two-dimensional energy-dependent timing cut
  const float seedTimeCut = 0.0;           // fixed-size cut on time of the seed crystal (0 means no cut)

  const bool useEnergyCorrection = false;     // use the ECAL energy correction parameters
  bool useWrongPt = false;
  float sigFactor = 2.0;

  bool useSeedTimeCut = false;
  if(seedTimeCut > 0.0) {
    useSeedTimeCut = true;
  }

  const bool genParticleStore = false;

  TRandom3 *randomValue = new TRandom3();
  const bool randomRotate = false;
  const bool crystalStore = false;
  const float zVertexLowLimit = -15.0;
  const float zVertexHighLimit = 15.0;

  const double lowPi0PtCut = 0.7;
  const double highPi0PtCut = 8.0;

  if(useOnlyNonDecay && useOnlyDecay) {
    cerr << "\n\n  Error: cannot have both  useOnlyNonDecay  and  useOnlyDecay  set as true" << endl << endl;
    return;
  } // safety check
	
  if(testConversion && !simRun) {
    cerr << "\n\n Cannot test for conversions in a data input set" << endl << endl;
    return;
  } // safety check
	
  if(testConversion && simulationTruthChoice != 1 && simulationTruthChoice != 2) {
    cerr << "\n\n Cannot request conversion suppression without specifying a choce for the simulation truth" << endl << endl;
    return;
  } // safety check
	
  if(testConversion) {
    cout << "\n\n Conversion checking requested";

    if(simulationTruthChoice == 1) {
      cout << ", truth information from mergedTrackTruth";
    }
    else {
      cout << ", truth information from simTracks";
    }
    cout << endl;

    if(selectConversionOnly)
      cout << "\n Clusters will be selected as tagged with conversion" << endl;
  
    if(selectNonConversionOnly)
      cout << "\n Clusters will be selected as tagged without conversion" << endl;

    if(selectSameParentClusters) 
      cout << "\n Only same parent clusters will be combined for reco" << endl;

    if(selectDifferentParentClusters) 
      cout << "\n Only different parent clusters will be combined for reco" << endl;
  }
  else {
    if(simRun)
      cout << "\n\n Conversion checking was NOT requested" << endl;
  }

  TFile *efficiencyPi0File = 0;
  TH2D *efficiencyPi0YieldsRead = 0;
  if(usePi0EfficiencyTable) {
    cout << "\n The use of the pi0 efficiency table was requested" << endl;
    TFile f("efficiencyPi0.root");
    if(f.IsZombie()) {
      cerr << "\n\n Unable to open efficiencyPi0.root input file" << endl << endl;
      return;
    }
    f.Close();
    cout << "\n Found the pi0 efficiency table ROOT file" << endl;

    efficiencyPi0File = new TFile("efficiencyPi0.root", "READ");
 
    efficiencyPi0YieldsRead = (TH2D*)efficiencyPi0File->Get("efficiencyPi0Yields");
    if(!efficiencyPi0YieldsRead) {
      cerr << "\n Unable to find efficiencyPi0Yields histogram in input file" << endl << endl;
      return;
    }
  } // check for using pi0 efficiency table
  else {
   cout << "\n The use of the pi0 efficiency table was not requested" << endl;
  }
  
  TFile *efficiencyTrackFile = 0;
  TH2D *efficiencyTrackYieldsRead = 0;
  if(useTrackEfficiencyTable) {
    cout << "\n The use of the track efficiency table was requested" << endl;
    TFile f("efficiencyTrack.root");
    if(f.IsZombie()) {
      cerr << "\n\n Unable to open efficiencyTrack.root input file" << endl << endl;
      return;
    }
    f.Close();
    cout << "\n Found the charged particle efficiency table ROOT file" << endl;

    efficiencyTrackFile = new TFile("efficiencyTrack.root", "READ");
 
    efficiencyTrackYieldsRead = (TH2D*)efficiencyTrackFile->Get("rTotalEff3D");
    if(!efficiencyTrackYieldsRead) {
      cerr << "\n Unable to find rTotalEff3d histogram in input file" << endl << endl;
      return;
    }
  } // check for using efficiency table
  else {
   cout << "\n The use of the charged particle efficiency table was not requested" << endl;
  }

  const int multiplicityBin = -1;        // default to minimum bias data sets
  const bool doCorrectionFit = false;      // determine the correction fit parameters
  
  const bool useClusterEnergyAsymmetryCut = false; // cut on cluster energy aysmmetry cut as used by PHENIX
  const double clusterEnergyAsymmetryCutSize = 2.0; // cut in terms of cluster energies fabs(E1 - E2)/(E1 + E2)
	
  const bool useClusterIsolationCut = false; // using cluster isolation cut for low pT pairs,
  const float clusterIsolationCutSize = 0.10; // minimum distance to the closest adjacent cluster
  float clusterIsolationCutSizeSquared = clusterIsolationCutSize*clusterIsolationCutSize;
  
  const float aOpenAngleCutParameter = 0.1699;
  const float bOpenAngleCutParameter = -0.1115;
  
  float fitStart = 0.100;   // 0.070 for parametrized background fit, 0.11 for mixed-event
  float fitEnd = 0.170;     // 0.220 for parametrized background, 0.159 for mixed-event
  const float peakStart = 0.08;
  const float peakEnd = 0.17;
  
  const bool useBothPi0Eta = false;       // use both pi0 and eta for the iOption = 20 energy correction diagnosis
  const bool resumMassPlots = true;
  const bool etaSumForPt = false;
  
  char *rootInputFile_1 =  new char[50];
  sprintf(rootInputFile_1, "first.root");
  char *rootInputFile_2 = new char[50];
  sprintf(rootInputFile_2, "second.root");
  
  const float lowMassPlotLimit = 0.30;
  const float highMassPlotLimit = 0.70;

  
  const bool simRunV1 = false;           // using the first version of the simulation output
  const bool simRunV2 = false;           // using the second version of the simulation output
  const bool simRunEPOS = true;          // using EPOS pPb instead of HIJING pPb

  const float minimumSeparationPi0 = 0.0;  // minimum distance between pi0 in the foreground and the mixed-events
  const float minimumSeparation = 0.05;  // minimum distance between clusters in the foreground and the mixed-events

 
  const float aSeparationCoefficient = 35.657;
  const float bSeparationCoefficient = -4.1995;
  const float rescaleSeparationFactor = 0.70;
  
  //
  // Multiplicity bins for the prompt skim data sets
  //
  const int lowMultiplicityLimit[4] = {120, 150, 185, 220};
  const int highMultiplicityLimit[4] = {150, 185, 225, 1000};
  
  //
  // pT bins
  //
  int nBinsPt = 13;
  const float lowPtBin[13] =  {0.7, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0, 6.0, 8.0,  10.0, 12.0};
  const float highPtBin[13] = {1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0, 6.0, 8.0, 10.0, 12.0, 14.0};
	
  char *mainPlotLabel = new char[200];
  if(multiplicityBin < -1 || multiplicityBin > 3) {
    cerr << "\n Unallowed value for multiplicityBin " << multiplicityBin << endl;
    return;
  }
  else {
    if(multiplicityBin == -1) {
      cout << "\n Minimum Bias data sets are used" << endl;
      sprintf(mainPlotLabel, "CMS pPb #sqrt{s_{NN}} = 5.02 TeV, Minimum Bias data");
    } // check on minimum bias selection
    else {
      sprintf(mainPlotLabel, "CMS pPb #sqrt{s_{NN}} = 5.02 TeV, Prompt Skim with %d #leq N_{track}^{offline} < %d", lowMultiplicityLimit[multiplicityBin], highMultiplicityLimit[multiplicityBin]);
      cout << "\n " << mainPlotLabel << endl;
    } // check on prompt skim
  } // check on valid multiplicity bin selection
  
  TCanvas *c1 = new TCanvas("c1", "Plotting Single Pi0", 200, 10, 950, 500);
  //
  // Use ROOT's gStyle function to set up plot options
  //
  gStyle->SetOptStat(1110);
  gStyle->SetStatTextColor(kBlue);
  gStyle->SetFuncColor(kBlue);
  gStyle->SetFuncWidth(2);
  gStyle->SetOptFit(1111);
  gStyle->SetFitFormat("6.5g");
  gStyle->SetPalette(1);
	
  c1->SetFillColor(kWhite);
  
  TFile *inputFile_1 = new TFile(rootInputFile_1);
  if(!inputFile_1) {
    cerr << "\n Unable to find first input file " << rootInputFile_1 << endl;
    return;
  }
  
  if(abs(iOption) >= 10) { // using hTree to produce figures
    
    char *hTreePath = new char[200];
    sprintf(hTreePath, "%shTree", multText);
    TTree *hTree = (TTree*)inputFile_1->Get(hTreePath);
    
    Long64_t nEntries;
    
    if(hTree) {
      cout << "\n\n Found hTree in input file " << rootInputFile_1;
      nEntries = hTree->GetEntries();
      cout << "\n The tree contains " << nEntries << " entries";
    }
    else {
      cerr << "\n Unable to find hTree in input file " << rootInputFile_1 << endl;
      return;
    }
    
    Long64_t entriesToProcess = nEntries;
    if(maxEntries > -1 && nEntries > maxEntries)
      entriesToProcess = maxEntries;
    
    cout << "\n The tree will be processed for " << entriesToProcess << " entries" << endl << endl;
    
    Long64_t nEntries10 = entriesToProcess/10;
    
    const double zEcalCut = 60.0;  // Delta-Theta grows linearly as a function of zEcal until this value, reaching a saturation value
    const bool usezEcalCorrection = true;
    const double zEcalSaturationValue = 0.01;
    const double zEcalCorrectionFactor = zEcalSaturationValue/zEcalCut;
    
    //Declaration of leaves types
    
    //
    // Global event variables
    //
    Int_t           Run;
    Int_t           Event;
    Int_t           LumiSection;
    Float_t         xPrimaryVtx;
    Float_t         yPrimaryVtx;
    Float_t         zPrimaryVtx;
    Int_t           nCry;
    Int_t           nClu;
    Int_t           nHITracks;
    Int_t           nHighPurityTracks;
    Int_t           nMC;
    Int_t           genSize;
    Int_t           njSim;
    Int_t           nSimTracks;
    Int_t           lowestDaughterSimTrack;
    Int_t           highestMatchedGenSimTrack;
    Int_t           mergedTrackTruthSize;
    Int_t           nChMesonSize;
    Int_t           nMesonSize;
    Int_t           nPhotonSize;
    Int_t           nPairTracksSize;

    //
    // ECAL crystal variables
    //
    const int CRYARRAY = 2000;
    Int_t           kCry[CRYARRAY];
    Float_t         eCry[CRYARRAY];
    Float_t         ptCry[CRYARRAY];
    Float_t         timeCry[CRYARRAY];
    Int_t           flagCry[CRYARRAY];
    Int_t           ietaCry[CRYARRAY];
    Int_t           iphiCry[CRYARRAY];
    Int_t           iCry[CRYARRAY];
    Int_t           iSM[CRYARRAY];
    
    //
    // ECAL cluster variables
    //
    const int CLUARRAY = 600;
    Int_t           indexCluCry[CLUARRAY];
    Int_t           kClu[CLUARRAY];
    Float_t         ptClu[CLUARRAY];
    Float_t         etaClu[CLUARRAY];
    Float_t         phiClu[CLUARRAY];
    Float_t         S1Clu[CLUARRAY];
    Float_t         S4Clu[CLUARRAY];
    Float_t         S9Clu[CLUARRAY];
    Float_t         S25Clu[CLUARRAY];
    Float_t         timeClu[CLUARRAY];
    Int_t           nCryClu[CLUARRAY];
    Int_t           indexCryClu[CLUARRAY][9];
    Int_t           nGoodRecoMatches[CLUARRAY];
    Int_t           indexBestRecoMatch[CLUARRAY];
    Float_t         valueBestAngleMatch[CLUARRAY];
    Float_t         momentumBestTrackMatch[CLUARRAY];
    Float_t         dxyVertexBestTrackMatch[CLUARRAY];
    Float_t         dzVertexBestTrackMatch[CLUARRAY];
    Float_t         sdxyVertexBestTrackMatch[CLUARRAY];
    Float_t         sdzVertexBestTrackMatch[CLUARRAY];
    Float_t         dPhiBestAngleMatch[CLUARRAY];
    Float_t         dThetaBestAngleMatch[CLUARRAY];
    Float_t         zClu[CLUARRAY];
    Float_t         outerPtTrackMatch[CLUARRAY];
    Int_t           bestNoConvertSimIndexEcal[CLUARRAY];
    Int_t           countNoConvertSimMatchEcal[CLUARRAY];
    Float_t         bestNoConvertSimAngleEcal[CLUARRAY];
    Float_t         seedTimeClu[CLUARRAY];
    Float_t         seedEnergyClu[CLUARRAY];
    Float_t         recEnergySum[CLUARRAY];
    Float_t         weightedTimeClu[CLUARRAY];

    Float_t         s9WidthX[CLUARRAY];
    Float_t         s9WidthY[CLUARRAY];
    Float_t         s25WidthX[CLUARRAY];
    Float_t         s25WidthY[CLUARRAY];

    //
    // Pair track variables
    //
    const int PAIRTRACKARRAY = 600;
    Int_t pairTrack[PAIRTRACKARRAY];
    Float_t recoPairPtTrack[PAIRTRACKARRAY];
    Float_t recoPairEtaTrack[PAIRTRACKARRAY];
    Float_t recoPairPhiTrack[PAIRTRACKARRAY];

    //
    // Reco Track variables
    //
    const int RECOTRACKARRAY = 1200;
    Int_t           mTrack[RECOTRACKARRAY];
    Int_t           recoPurityTrack[RECOTRACKARRAY];
    Float_t         recoPhiDTrack[RECOTRACKARRAY];
    Float_t         recoPtTrack[RECOTRACKARRAY];
    Float_t         recoEtaTrack[RECOTRACKARRAY];
    Float_t         recoPhiTrack[RECOTRACKARRAY];
    Float_t         recoThetaTrack[RECOTRACKARRAY];
    Float_t         recoVxTrack[RECOTRACKARRAY];
    Float_t         recoVyTrack[RECOTRACKARRAY];
    Float_t         recoVzTrack[RECOTRACKARRAY];
    Float_t         recoDxyTrack[RECOTRACKARRAY];
    Float_t         recoDzTrack[RECOTRACKARRAY];
    Float_t         recoSdxyTrack[RECOTRACKARRAY];
    Float_t         recoSdzTrack[RECOTRACKARRAY];
    Int_t           recoChargeTrack[RECOTRACKARRAY];
    
    //
    // MC array variables
    //
    const int MCARRAY = 2000;
    Int_t           kMC[MCARRAY];
    Int_t           pdgIdMC[MCARRAY];
    Int_t           motherIDMC[MCARRAY];
    Int_t           motherIndexMC[MCARRAY];
    Int_t           statusMC[MCARRAY];
    Float_t         ptMC[MCARRAY];
    Float_t         eMC[MCARRAY];
    Float_t         etaMC[MCARRAY];
    Float_t         phiMC[MCARRAY];
    
    //
    // mergedTruthTrack variables
    //
    const int MERGETRUTHARRAY = 3000;
    Int_t           kMerge[MERGETRUTHARRAY];
    Int_t           numberDecayVerticesMerge[MERGETRUTHARRAY];
    Int_t           numberEarlyDecayMerge[MERGETRUTHARRAY];
    Int_t           pdgIdMerge[MERGETRUTHARRAY];
    Int_t           primaryTrackMerge[MERGETRUTHARRAY];
    Float_t         xParentVertexMerge[MERGETRUTHARRAY];
    Float_t         yParentVertexMerge[MERGETRUTHARRAY];
    Float_t         rParentVertexMerge[MERGETRUTHARRAY];
    Float_t         zParentVertexMerge[MERGETRUTHARRAY];
    Float_t         ptMerge[MERGETRUTHARRAY];
    Float_t         etaMerge[MERGETRUTHARRAY];
    Float_t         phiMerge[MERGETRUTHARRAY];
    Float_t         xDecayVertexMerge[MERGETRUTHARRAY];
    Float_t         yDecayVertexMerge[MERGETRUTHARRAY];
    Float_t         rDecayVertexMerge[MERGETRUTHARRAY];
    Float_t         zDecayVertexMerge[MERGETRUTHARRAY];
    Float_t         bestAngleMatchMerge[MERGETRUTHARRAY];
    Float_t         bestPtMatchMerge[MERGETRUTHARRAY];
    Float_t         bestEtaMatchMerge[MERGETRUTHARRAY];
    Float_t         bestPhiMatchMerge[MERGETRUTHARRAY];
    Int_t           bestPdgIdMatchMerge[MERGETRUTHARRAY];
    Int_t           bestGenIndexMatchMerge[MERGETRUTHARRAY];
    Int_t           bestEcalIndexMatch[MERGETRUTHARRAY];
    Float_t         bestEcalAngleMatch[MERGETRUTHARRAY];
    Float_t         bestEcalPhiMatch[MERGETRUTHARRAY];
    Float_t         bestEcalDPhiMatch[MERGETRUTHARRAY];
    Float_t         bestEcalDEtaMatch[MERGETRUTHARRAY];
    Float_t         bestEcalPtMatch[MERGETRUTHARRAY];

    //
    // charged particle generator information
    //
    const int CHMESONARRAY = 500;
    Int_t           kChMeson[CHMESONARRAY];
    Int_t           pdgIdChMeson[CHMESONARRAY];
    Int_t           statusChMeson[CHMESONARRAY];
    Int_t           motherIdChMeson[CHMESONARRAY];
    Float_t         ptChMeson[CHMESONARRAY];
    Float_t         etaChMeson[CHMESONARRAY];
    Float_t         phiChMeson[CHMESONARRAY];
  
    //
    // meson reco and truth
    //
    const int MESONARRAY = 500;
    Int_t           kMeson[MESONARRAY];
    Int_t           pdgIdMeson[MESONARRAY];
    Int_t           statusMeson[MESONARRAY];
    Int_t           motherIdMeson[MESONARRAY];
    Float_t         ptMeson[MESONARRAY];
    Float_t         etaMeson[MESONARRAY];
    Float_t         phiMeson[MESONARRAY];
    Int_t           daughtersFromMeson[MESONARRAY];
    Int_t           pdgIdDecay1Meson[MESONARRAY];
    Float_t         ptDecay1Meson[MESONARRAY];
    Float_t         etaDecay1Meson[MESONARRAY];
    Float_t         phiDecay1Meson[MESONARRAY];
    Int_t           mergeDecay1Meson[MESONARRAY];
    Int_t           convertDecay1Meson[MESONARRAY];
    Float_t         mergeDecay1Angle[MESONARRAY];
    Int_t           pdgIdDecay2Meson[MESONARRAY];
    Float_t         ptDecay2Meson[MESONARRAY];
    Float_t         etaDecay2Meson[MESONARRAY];
    Float_t         phiDecay2Meson[MESONARRAY];
    Int_t           mergeDecay2Meson[MESONARRAY];
    Int_t           convertDecay2Meson[MESONARRAY];
    Float_t         mergeDecay2Angle[MESONARRAY];
    Int_t           pdgIdDecay3Meson[MESONARRAY];
    Float_t         ptDecay3Meson[MESONARRAY];
    Float_t         etaDecay3Meson[MESONARRAY];
    Float_t         phiDecay3Meson[MESONARRAY];
    Int_t           mergeDecay3Meson[MESONARRAY];
    Int_t           convertDecay3Meson[MESONARRAY];
    Float_t         mergeDecay3Angle[MESONARRAY];
    Float_t         massRecoMeson[MESONARRAY];
    Float_t         ptRecoMeson[MESONARRAY];
    Float_t         etaRecoMeson[MESONARRAY];
    Float_t         phiRecoMeson[MESONARRAY];

    //
    // simTrack variables
    //
    const int SIMTRACKARRAY = 8500;
    Int_t           kSim[SIMTRACKARRAY];
    Int_t           noVertexSim[SIMTRACKARRAY];
    Int_t           pdgIdSim[SIMTRACKARRAY];
    Float_t         ptSim[SIMTRACKARRAY];
    Float_t         eSim[SIMTRACKARRAY];
    Float_t         etaSim[SIMTRACKARRAY];
    Float_t         phiSim[SIMTRACKARRAY];
    Int_t           trackIdSim[SIMTRACKARRAY];
    Int_t           parentKSim[SIMTRACKARRAY];
    Int_t           parentIdSim[SIMTRACKARRAY];
    Int_t           parentTrackSim[SIMTRACKARRAY];
    Int_t           gParentKSim[SIMTRACKARRAY];
    Int_t           gParentIdSim[SIMTRACKARRAY];
    Int_t           gParentTrackSim[SIMTRACKARRAY];
    Int_t           nDaughtersSim[SIMTRACKARRAY];
    Int_t           kDaughtersSim[SIMTRACKARRAY][3];
    Float_t         rSim[SIMTRACKARRAY];
    Float_t         zSim[SIMTRACKARRAY];
    Int_t           genPartIndexSim[SIMTRACKARRAY];
    Int_t           genPartPdgIdSim[SIMTRACKARRAY];
    Float_t         bestAngleMatchGenSim[SIMTRACKARRAY];
    Float_t         bestPtMatchGenSim[SIMTRACKARRAY];
    Float_t         bestEtaMatchGenSim[SIMTRACKARRAY];
    Float_t         bestPhiMatchGenSim[SIMTRACKARRAY];
    Int_t           motherGenIndexSim[SIMTRACKARRAY];
    Int_t           motherGenIdSim[SIMTRACKARRAY];
    Int_t           gMotherGenIdSim[SIMTRACKARRAY];
    Int_t           bestNoConvertEcalIndexSim[SIMTRACKARRAY];
    Float_t         bestNoConvertEcalAngleSim[SIMTRACKARRAY];
    Float_t         bestNoConvertEcalPtSim[SIMTRACKARRAY];

    //
    // photon reco and truth
    //
    const int PHOTONGENARRAY = 500;
    Int_t           kPhotonGen[PHOTONGENARRAY];
    Int_t           motherPdgIdPhotonGen[PHOTONGENARRAY];
    Float_t         ptMotherPhotonGen[PHOTONGENARRAY];
    Float_t         ptPhotonGen[PHOTONGENARRAY];
    Float_t         etaPhotonGen[PHOTONGENARRAY];
    Float_t         phiPhotonGen[PHOTONGENARRAY];
    Int_t           mergeIndexPhotonGen[PHOTONGENARRAY];
    Int_t           clusterIndexPhotonGen[PHOTONGENARRAY];
    Int_t           convertPhotonGen[PHOTONGENARRAY];
    Float_t         angleRecoPhotonGen[PHOTONGENARRAY];
    Float_t         ptRecoPhotonGen[PHOTONGENARRAY];
    Float_t         etaRecoPhotonGen[PHOTONGENARRAY];
    Float_t         phiRecoPhotonGen[PHOTONGENARRAY];
    
    // Set branch addresses
    
    // Global event variables are always stored
    hTree->SetBranchAddress("Run",&Run);
    hTree->SetBranchAddress("Event",&Event);
    hTree->SetBranchAddress("LumiSection",&LumiSection);
    hTree->SetBranchAddress("xPrimaryVtx",&xPrimaryVtx);
    hTree->SetBranchAddress("yPrimaryVtx",&yPrimaryVtx);
    hTree->SetBranchAddress("zPrimaryVtx",&zPrimaryVtx);
    hTree->SetBranchAddress("nCry",&nCry);
    hTree->SetBranchAddress("nClu",&nClu);
    hTree->SetBranchAddress("nHITracks",&nHITracks);
    hTree->SetBranchAddress("nHighPurityTracks",&nHighPurityTracks);
    hTree->SetBranchAddress("nMC",&nMC);
    hTree->SetBranchAddress("mergedTrackTruthSize",&mergedTrackTruthSize);
    hTree->SetBranchAddress("genSize",&genSize);
    hTree->SetBranchAddress("njSim",&njSim);
    hTree->SetBranchAddress("lowestDaughterSimTrack",&lowestDaughterSimTrack);
    hTree->SetBranchAddress("highestMatchedGenSimTrack",&highestMatchedGenSimTrack);
    hTree->SetBranchAddress("nSimTracks",&nSimTracks);
    hTree->SetBranchAddress("nChMesonSize",&nChMesonSize);
    hTree->SetBranchAddress("nMesonSize",&nMesonSize);
    hTree->SetBranchAddress("nPhotonSize",&nPhotonSize);
    hTree->SetBranchAddress("nPairTracksSize",&nPairTracksSize);
   
    if(crystalStore) {
      hTree->SetBranchAddress("kCry",kCry);
      hTree->SetBranchAddress("eCry",eCry);
      hTree->SetBranchAddress("ptCry",ptCry);
      hTree->SetBranchAddress("timeCry",timeCry);
      hTree->SetBranchAddress("flagCry",flagCry);
      hTree->SetBranchAddress("ietaCry",ietaCry);
      hTree->SetBranchAddress("iphiCry",iphiCry);
      hTree->SetBranchAddress("iCry",iCry);
      hTree->SetBranchAddress("iSM",iSM);
      hTree->SetBranchAddress("indexCluCry",indexCluCry);
    }
		
    if(clusterStore) {
      hTree->SetBranchAddress("kClu",kClu);
      hTree->SetBranchAddress("ptClu",ptClu);
      hTree->SetBranchAddress("etaClu",etaClu);
      hTree->SetBranchAddress("phiClu",phiClu);
      hTree->SetBranchAddress("S4Clu",S4Clu);
      hTree->SetBranchAddress("S9Clu",S9Clu);
      hTree->SetBranchAddress("S25Clu",S25Clu);
      hTree->SetBranchAddress("nGoodRecoMatches",nGoodRecoMatches);
      hTree->SetBranchAddress("zClu",zClu);
      hTree->SetBranchAddress("S1Clu",S1Clu);
      hTree->SetBranchAddress("timeClu",timeClu);
      hTree->SetBranchAddress("nCryClu",nCryClu);
      hTree->SetBranchAddress("indexCryClu",indexCryClu);
      hTree->SetBranchAddress("bestNoConvertSimIndexEcal",bestNoConvertSimIndexEcal);
      hTree->SetBranchAddress("countNoConvertSimMatchEcal",countNoConvertSimMatchEcal);
      hTree->SetBranchAddress("bestNoConvertSimAngleEcal",bestNoConvertSimAngleEcal);
      hTree->SetBranchAddress("seedTimeClu",seedTimeClu);
      hTree->SetBranchAddress("seedEnergyClu",seedEnergyClu);
      hTree->SetBranchAddress("recEnergySum",recEnergySum);
      hTree->SetBranchAddress("weightedTimeClu",weightedTimeClu);

      if(useClusterShapeVariables) {
	hTree->SetBranchAddress("s9WidthX",s9WidthX);
	hTree->SetBranchAddress("s9WidthY",s9WidthY);
	hTree->SetBranchAddress("s25WidthX",s25WidthX);
	hTree->SetBranchAddress("s25WidthY",s25WidthY);
      }
    }    

    if(clusterRecoTrackStore) {
      hTree->SetBranchAddress("zClu",zClu);
      hTree->SetBranchAddress("S1Clu",S1Clu);
      hTree->SetBranchAddress("timeClu",timeClu);
      hTree->SetBranchAddress("nCryClu",nCryClu);
      hTree->SetBranchAddress("indexCryClu",indexCryClu);
      hTree->SetBranchAddress("indexBestRecoMatch",indexBestRecoMatch);
      hTree->SetBranchAddress("valueBestAngleMatch",valueBestAngleMatch);
      hTree->SetBranchAddress("momentumBestTrackMatch",momentumBestTrackMatch);
      hTree->SetBranchAddress("dxyVertexBestTrackMatch",dxyVertexBestTrackMatch);
      hTree->SetBranchAddress("dzVertexBestTrackMatch",dzVertexBestTrackMatch);
      hTree->SetBranchAddress("sdxyVertexBestTrackMatch",sdxyVertexBestTrackMatch);
      hTree->SetBranchAddress("sdzVertexBestTrackMatch",sdzVertexBestTrackMatch);
      hTree->SetBranchAddress("dPhiBestAngleMatch",dPhiBestAngleMatch);
      hTree->SetBranchAddress("dThetaBestAngleMatch",dThetaBestAngleMatch);
      hTree->SetBranchAddress("outerPtTrackMatch",outerPtTrackMatch);
    }

    if(pairCorrTracksStore) {
      hTree->SetBranchAddress("pairTrack",pairTrack);
      hTree->SetBranchAddress("recoPairPtTrack",recoPairPtTrack);
      hTree->SetBranchAddress("recoPairEtaTrack",recoPairEtaTrack);
      hTree->SetBranchAddress("recoPairPhiTrack",recoPairPhiTrack);
    }
		
    if(recoTrackStore) {
      hTree->SetBranchAddress("mTrack",mTrack);
      hTree->SetBranchAddress("recoPurityTrack",recoPurityTrack);
      hTree->SetBranchAddress("recoPhiDTrack",recoPhiDTrack);
      hTree->SetBranchAddress("recoPtTrack",recoPtTrack);
      hTree->SetBranchAddress("recoEtaTrack",recoEtaTrack);
      hTree->SetBranchAddress("recoPhiTrack",recoPhiTrack);
      hTree->SetBranchAddress("recoThetaTrack",recoThetaTrack);
      hTree->SetBranchAddress("recoVxTrack",recoVxTrack);
      hTree->SetBranchAddress("recoVyTrack",recoVyTrack);
      hTree->SetBranchAddress("recoVzTrack",recoVzTrack);
      hTree->SetBranchAddress("recoDxyTrack",recoDxyTrack);
      hTree->SetBranchAddress("recoDzTrack",recoDzTrack);
      hTree->SetBranchAddress("recoSdxyTrack",recoSdxyTrack);
      hTree->SetBranchAddress("recoSdzTrack",recoSdzTrack);
      hTree->SetBranchAddress("recoChargeTrack",recoChargeTrack);
    }
		
    if(mcParticleStore) {
      hTree->SetBranchAddress("kMC",kMC);
      hTree->SetBranchAddress("pdgIdMC",pdgIdMC);
      hTree->SetBranchAddress("motherIDMC",motherIDMC);
      hTree->SetBranchAddress("motherIndexMC",motherIndexMC);
      hTree->SetBranchAddress("statusMC",statusMC);
      hTree->SetBranchAddress("ptMC",ptMC);
      hTree->SetBranchAddress("eMC",eMC);
      hTree->SetBranchAddress("etaMC",etaMC);
      hTree->SetBranchAddress("phiMC",phiMC);
      
    }
    
    if(mergedTrackTruthStore) {
      hTree->SetBranchAddress("kMerge",kMerge);
      hTree->SetBranchAddress("numberDecayVerticesMerge",numberDecayVerticesMerge);
      hTree->SetBranchAddress("numberEarlyDecayMerge",numberEarlyDecayMerge);
      hTree->SetBranchAddress("pdgIdMerge",pdgIdMerge);
      hTree->SetBranchAddress("primaryTrackMerge",primaryTrackMerge);
      hTree->SetBranchAddress("xParentVertexMerge",xParentVertexMerge);
      hTree->SetBranchAddress("yParentVertexMerge",yParentVertexMerge);
      hTree->SetBranchAddress("rParentVertexMerge",rParentVertexMerge);
      hTree->SetBranchAddress("zParentVertexMerge",zParentVertexMerge);
      hTree->SetBranchAddress("ptMerge",ptMerge);
      hTree->SetBranchAddress("etaMerge",etaMerge);
      hTree->SetBranchAddress("phiMerge",phiMerge);
      hTree->SetBranchAddress("xDecayVertexMerge",xDecayVertexMerge);
      hTree->SetBranchAddress("yDecayVertexMerge",yDecayVertexMerge);
      hTree->SetBranchAddress("rDecayVertexMerge",rDecayVertexMerge);
      hTree->SetBranchAddress("zDecayVertexMerge",zDecayVertexMerge);
      hTree->SetBranchAddress("bestAngleMatchMerge",bestAngleMatchMerge);
      hTree->SetBranchAddress("bestPtMatchMerge",bestPtMatchMerge);
      hTree->SetBranchAddress("bestEtaMatchMerge",bestEtaMatchMerge);
      hTree->SetBranchAddress("bestPhiMatchMerge",bestPhiMatchMerge);
      hTree->SetBranchAddress("bestPdgIdMatchMerge",bestPdgIdMatchMerge);
      hTree->SetBranchAddress("bestGenIndexMatchMerge",bestGenIndexMatchMerge);
      hTree->SetBranchAddress("bestEcalIndexMatch",bestEcalIndexMatch);
      hTree->SetBranchAddress("bestEcalAngleMatch",bestEcalAngleMatch);
      hTree->SetBranchAddress("bestEcalPhiMatch",bestEcalPhiMatch);
      hTree->SetBranchAddress("bestEcalDPhiMatch",bestEcalDPhiMatch);
      hTree->SetBranchAddress("bestEcalDEtaMatch",bestEcalDEtaMatch);
      hTree->SetBranchAddress("bestEcalPtMatch",bestEcalPtMatch);
    }
    
    if(simTrackStore) {
      hTree->SetBranchAddress("kSim",kSim);
      hTree->SetBranchAddress("gMotherGenIdSim",gMotherGenIdSim); 
      hTree->SetBranchAddress("motherGenIndexSim",motherGenIndexSim);
      hTree->SetBranchAddress("motherGenIdSim",motherGenIdSim);
      hTree->SetBranchAddress("pdgIdSim",pdgIdSim);
      if(!simSlimTrackStore) {  // extended output for the simTrack branch
	hTree->SetBranchAddress("noVertexSim",noVertexSim);
	hTree->SetBranchAddress("ptSim",ptSim);
	hTree->SetBranchAddress("eSim",eSim);
	hTree->SetBranchAddress("etaSim",etaSim);
	hTree->SetBranchAddress("phiSim",phiSim);
	hTree->SetBranchAddress("trackIdSim",trackIdSim);
	hTree->SetBranchAddress("parentKSim",parentKSim);
	hTree->SetBranchAddress("parentIdSim",parentIdSim);
	hTree->SetBranchAddress("parentTrackSim",parentTrackSim);
	hTree->SetBranchAddress("gParentKSim",gParentKSim);
	hTree->SetBranchAddress("gParentIdSim",gParentIdSim);
	hTree->SetBranchAddress("gParentTrackSim",gParentTrackSim);
	hTree->SetBranchAddress("nDaughtersSim",nDaughtersSim);
	hTree->SetBranchAddress("kDaughtersSim",kDaughtersSim);
	hTree->SetBranchAddress("rSim",rSim);
	hTree->SetBranchAddress("zSim",zSim);
	hTree->SetBranchAddress("genPartIndexSim",genPartIndexSim);
	hTree->SetBranchAddress("genPartPdgIdSim",genPartPdgIdSim);
	hTree->SetBranchAddress("bestAngleMatchGenSim",bestAngleMatchGenSim);
	hTree->SetBranchAddress("bestPtMatchGenSim",bestPtMatchGenSim);
	hTree->SetBranchAddress("bestEtaMatchGenSim",bestEtaMatchGenSim);
	hTree->SetBranchAddress("bestPhiMatchGenSim",bestPhiMatchGenSim);
	hTree->SetBranchAddress("bestNoConvertEcalIndexSim",bestNoConvertEcalIndexSim);
	hTree->SetBranchAddress("bestNoConvertEcalAngleSim",bestNoConvertEcalAngleSim);
	hTree->SetBranchAddress("bestNoConvertEcalPtSim",bestNoConvertEcalPtSim);
      } // check for simSlimTrackStore
    } // check for simTrackStore

    if(chmesonStore) {
      hTree->SetBranchAddress("kChMeson",kChMeson);
      hTree->SetBranchAddress("pdgIdChMeson",pdgIdChMeson);
      hTree->SetBranchAddress("statusChMeson",statusChMeson);
      hTree->SetBranchAddress("motherIdChMeson",motherIdChMeson);
      hTree->SetBranchAddress("ptChMeson",ptChMeson);
      hTree->SetBranchAddress("etaChMeson",etaChMeson);
      hTree->SetBranchAddress("phiChMeson",phiChMeson);
    }

    if(mesonStore) {
      hTree->SetBranchAddress("kMeson",kMeson);
      hTree->SetBranchAddress("pdgIdMeson",pdgIdMeson);
      hTree->SetBranchAddress("statusMeson",statusMeson);
      hTree->SetBranchAddress("motherIdMeson",motherIdMeson);
      hTree->SetBranchAddress("ptMeson",ptMeson);
      hTree->SetBranchAddress("etaMeson",etaMeson);
      hTree->SetBranchAddress("phiMeson",phiMeson);
      hTree->SetBranchAddress("daughtersFromMeson",daughtersFromMeson);
      hTree->SetBranchAddress("pdgIdDecay1Meson",pdgIdDecay1Meson);
      hTree->SetBranchAddress("ptDecay1Meson",ptDecay1Meson);
      hTree->SetBranchAddress("etaDecay1Meson",etaDecay1Meson);
      hTree->SetBranchAddress("phiDecay1Meson",phiDecay1Meson);
      hTree->SetBranchAddress("mergeDecay1Meson",mergeDecay1Meson);
      hTree->SetBranchAddress("convertDecay1Meson",convertDecay1Meson);
      hTree->SetBranchAddress("mergeDecay1Angle",mergeDecay1Angle);
      hTree->SetBranchAddress("pdgIdDecay2Meson",pdgIdDecay2Meson);
      hTree->SetBranchAddress("ptDecay2Meson",ptDecay2Meson);
      hTree->SetBranchAddress("etaDecay2Meson",etaDecay2Meson);
      hTree->SetBranchAddress("phiDecay2Meson",phiDecay2Meson);
      hTree->SetBranchAddress("mergeDecay2Meson",mergeDecay2Meson);
      hTree->SetBranchAddress("convertDecay2Meson",convertDecay2Meson);
      hTree->SetBranchAddress("mergeDecay2Angle",mergeDecay2Angle);
      hTree->SetBranchAddress("pdgIdDecay3Meson",pdgIdDecay3Meson);
      hTree->SetBranchAddress("ptDecay3Meson",ptDecay3Meson);
      hTree->SetBranchAddress("etaDecay3Meson",etaDecay3Meson);
      hTree->SetBranchAddress("phiDecay3Meson",phiDecay3Meson);
      hTree->SetBranchAddress("mergeDecay3Meson",mergeDecay3Meson);
      hTree->SetBranchAddress("convertDecay3Meson",convertDecay3Meson);
      hTree->SetBranchAddress("mergeDecay3Angle",mergeDecay3Angle);
      hTree->SetBranchAddress("massRecoMeson",massRecoMeson);
      hTree->SetBranchAddress("ptRecoMeson",ptRecoMeson);
      hTree->SetBranchAddress("etaRecoMeson",etaRecoMeson);
      hTree->SetBranchAddress("phiRecoMeson",phiRecoMeson);
    }
    
    if(photonStore) {
      hTree->SetBranchAddress("kPhotonGen",kPhotonGen);
      hTree->SetBranchAddress("motherPdgIdPhotonGen",motherPdgIdPhotonGen);
      hTree->SetBranchAddress("ptMotherPhotonGen",ptMotherPhotonGen);
      hTree->SetBranchAddress("ptPhotonGen",ptPhotonGen);
      hTree->SetBranchAddress("etaPhotonGen",etaPhotonGen);
      hTree->SetBranchAddress("phiPhotonGen",phiPhotonGen);
      hTree->SetBranchAddress("mergeIndexPhotonGen",mergeIndexPhotonGen);
      hTree->SetBranchAddress("clusterIndexPhotonGen",clusterIndexPhotonGen);
      hTree->SetBranchAddress("convertPhotonGen",convertPhotonGen);
      hTree->SetBranchAddress("angleRecoPhotonGen",angleRecoPhotonGen);
      hTree->SetBranchAddress("ptRecoPhotonGen",ptRecoPhotonGen);
      hTree->SetBranchAddress("etaRecoPhotonGen",etaRecoPhotonGen);
      hTree->SetBranchAddress("phiRecoPhotonGen",phiRecoPhotonGen);
    }
    
    if(genParticleStore) {
      cout << "\n\n There is no genParticle information stored" << endl << endl;
    }
    
    if(iOption == 10) {
      c1->Divide(2,3);
      
      c1->cd(1);
      TH2D *dPhiDxy1 = new TH2D("dPhiDxy1", "#Delta#Phi vs #Delta XY", 100, -20.0, 20.0, 100, -0.06, 0.06);
      hTree->Project("dPhiDxy1", "dPhiBestAngleMatch:dxyVertexBestTrackMatch", "(abs(dxyVertexBestTrackMatch-4.5)<4.0||abs(dxyVertexBestTrackMatch+4.5))<4.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      dPhiDxy1->SetStats(0);
      dPhiDxy1->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      c1->cd(3);
      TH1D *dPhi = new TH1D("dPhi", "#Delta#Phi for Abs(#Delta XY)", 100, -0.10, 0.10);
      hTree->Project("dPhi", "dPhiBestAngleMatch", "abs(dThetaBestAngleMatch)<0.04&&abs(dxyVertexBestTrackMatch-4.5)<4.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      
      TF1 *fitPhi = new TF1("fitPhi", doubleGaussPeakFixed, -0.10, +0.10, 5);
      fitPhi->SetParameters(100, 0.0, 0.016, 30.0, 0.07);
      fitPhi->SetParName(0, "Ampl1");
      fitPhi->SetParName(1, "Cent1");
      fitPhi->SetParName(2, "Sigma1");
      fitPhi->SetParName(3, "Ampl2");
      fitPhi->SetParName(4, "Sigma2");
      
      fitPhi->SetNpx(500);
      fitPhi->SetLineWidth(2);
      fitPhi->SetLineColor(kBlue);
      
      dPhi->Fit("fitPhi", "", "", -0.10, +0.10);
      
      (c1->cd(3))->SetGrid();
      
      c1->cd(2);
      TH1D *dPhiPlus = new TH1D("dPhiPlus", "#Delta#Phi for Positive #Delta XY", 100, -0.10, 0.10);
      hTree->Project("dPhiPlus", "dPhiBestAngleMatch", "abs(dThetaBestAngleMatch)<0.04&&abs(dxyVertexBestTrackMatch-5.5)<5.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      
      TH1D *dxyPlus = new TH1D("dxyPlus", "#Delta XY for Positive #Delta XY", 100, -20., 20.);
      hTree->Project("dxyPlus", "dxyVertexBestTrackMatch", "abs(dThetaBestAngleMatch)<0.04&&abs(dxyVertexBestTrackMatch-5.5)<5.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      
      TH1D *dxyMinus = new TH1D("dxyMinus", "#Delta XY for Negative #Delta XY", 100, -20., 20.);
      hTree->Project("dxyMinus", "dxyVertexBestTrackMatch", "abs(dThetaBestAngleMatch)<0.04&&abs(dxyVertexBestTrackMatch+5.5)<5.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      
      
      TF1 *fitPhiPlus = new TF1("fitPhiPlus", doubleGaussPeakFixed, -0.10, +0.10, 5);
      fitPhiPlus->SetParameters(100, 0.0, 0.016, 30.0, 0.07);
      fitPhiPlus->SetParName(0, "Ampl1");
      fitPhiPlus->SetParName(1, "Cent1");
      fitPhiPlus->SetParName(2, "Sigma1");
      fitPhiPlus->SetParName(3, "Ampl2");
      fitPhiPlus->SetParName(4, "Sigma2");
      
      fitPhiPlus->SetNpx(500);
      fitPhiPlus->SetLineWidth(2);
      fitPhiPlus->SetLineColor(kBlue);
      
      dPhiPlus->Fit("fitPhiPlus", "", "", -0.10, +0.10);
      
      (c1->cd(2))->SetGrid();
      
      c1->cd(5);
      dxyPlus->Draw();
      (c1->cd(5))->SetGrid();
      
      c1->cd(6);
      dxyMinus->Draw();
      (c1->cd(6))->SetGrid();
      
      c1->cd(4);
      TH1D *dPhiMinus = new TH1D("dPhiMinus", "#Delta#Phi for Negative #Delta XY", 100, -0.10, 0.10);
      hTree->Project("dPhiMinus", "dPhiBestAngleMatch", "abs(dThetaBestAngleMatch)<0.04&&abs(dxyVertexBestTrackMatch+5.5)<5.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      
      TF1 *fitPhiMinus = new TF1("fitPhiMinus", doubleGaussPeakFixed, -0.10, +0.10, 5);
      fitPhiMinus->SetParameters(100, 0.0, 0.016, 30.0, 0.07);
      fitPhiMinus->SetParName(0, "Ampl1");
      fitPhiMinus->SetParName(1, "Cent1");
      fitPhiMinus->SetParName(2, "Sigma1");
      fitPhiMinus->SetParName(3, "Ampl2");
      fitPhiMinus->SetParName(4, "Sigma2");
      
      fitPhiMinus->SetNpx(500);
      fitPhiMinus->SetLineWidth(2);
      fitPhiMinus->SetLineColor(kBlue);
      
      dPhiMinus->Fit("fitPhiMinus", "", "", -0.10, +0.10);
      
      (c1->cd(4))->SetGrid();
      
      return;
      
    } // iOption = 10 for dPhiDxy1
    
    if(iOption == 11) { // Projections for dPhi, dTheta residual histogram fitting
      c1->Divide(2,2);
      
      c1->cd(1);
      TH1D *dPhi1 = new TH1D("dPhi1", "#Delta#phi_{T-E} for Secondary Tracks with p_{T} > 1.5 GeV/c", 100, -0.10, 0.10);
      dPhi1->SetXTitle("#Delta#phi_{T-E} (azimuthal residual, radians)");
      dPhi1->SetYTitle("Counts per 0.002 radian bin");
      hTree->Project("dPhi1", "dPhiBestAngleMatch", "abs(dxyVertexBestTrackMatch)>=1.0&&valueBestAngleMatch<0.10&&valueBestAngleMatch>=0.0");
      (dPhi1->GetXaxis())->SetLabelSize(0.040);
      (dPhi1->GetXaxis())->SetTitleOffset(0.8);
      (dPhi1->GetXaxis())->SetTitleSize(0.05);
      (dPhi1->GetXaxis())->CenterTitle();
      (dPhi1->GetYaxis())->SetLabelSize(0.040);
      (dPhi1->GetYaxis())->SetTitleOffset(0.8);
      (dPhi1->GetYaxis())->SetTitleSize(0.05);
      (dPhi1->GetYaxis())->CenterTitle();
      
      TF1 *fitPhi1 = new TF1("fitPhi1", doubleGaussPeak, -0.1, +0.1, 6);
      fitPhi1->SetParameters(100, 0.0, 0.01, 30.0, 0.0, 0.07);
      fitPhi1->SetParName(0, "Ampl1");
      fitPhi1->SetParName(1, "Cent1");
      fitPhi1->SetParName(2, "Sigma1");
      fitPhi1->SetParName(3, "Ampl2");
      fitPhi1->SetParName(4, "Cent2");
      fitPhi1->SetParName(5, "Sigma2");
      
      fitPhi1->SetNpx(500);
      fitPhi1->SetLineWidth(2);
      fitPhi1->SetLineColor(kBlue);
      
      dPhi1->Fit("fitPhi1", "", "", -0.1, +0.1);
      
      TF1 *bgrndPhi1 = new TF1("bgrndPhi1", gaussPeak, -0.1, +0.1, 3);
      bgrndPhi1->SetParameter(0, fitPhi1->GetParameter(3));
      bgrndPhi1->SetParameter(1, fitPhi1->GetParameter(4));
      bgrndPhi1->SetParameter(2, fitPhi1->GetParameter(5));
      bgrndPhi1->SetLineColor(2);
      bgrndPhi1->Draw("same");
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      TH1D *dTheta1 = new TH1D("dTheta1", "#Delta#Theta_{T-E} for Secondary Tracks with p_{T} > 1.5 GeV/c", 100, -0.10, 0.10);
      dTheta1->SetXTitle("#Delta#theta_{T-E} (polar angle residual, radians)");
      dTheta1->SetYTitle("Counts per 0.002 radian bin");
      hTree->Project("dTheta1", "dThetaBestAngleMatch", "abs(dxyVertexBestTrackMatch)>=1.0&&valueBestAngleMatch<0.10&&valueBestAngleMatch>=0.0");
      (dTheta1->GetXaxis())->SetLabelSize(0.040);
      (dTheta1->GetXaxis())->SetTitleOffset(0.8);
      (dTheta1->GetXaxis())->SetTitleSize(0.05);
      (dTheta1->GetXaxis())->CenterTitle();
      (dTheta1->GetYaxis())->SetLabelSize(0.040);
      (dTheta1->GetYaxis())->SetTitleOffset(0.8);
      (dTheta1->GetYaxis())->SetTitleSize(0.05);
      (dTheta1->GetYaxis())->CenterTitle();
      
      TF1 *fitTheta1 = new TF1("fitTheta1", doubleGaussPeak, -0.1, +0.1, 6);
      fitTheta1->SetParameters(100, 0.0, 0.02, 20.0, 0.0, 0.07);
      fitTheta1->SetParName(0, "Ampl1");
      fitTheta1->SetParName(1, "Cent1");
      fitTheta1->SetParName(2, "Sigma1");
      fitTheta1->SetParName(3, "Ampl2");
      fitTheta1->SetParName(4, "Cent2");
      fitTheta1->SetParName(5, "Sigma2");
      
      fitTheta1->SetNpx(500);
      fitTheta1->SetLineWidth(2);
      fitTheta1->SetLineColor(kBlue);
      
      dTheta1->Fit("fitTheta1", "", "", -0.1, +0.1);
      TF1 *bgrndTheta1 = new TF1("bgrndTheta1", gaussPeak, -0.1, +0.1, 3);
      bgrndTheta1->SetParameter(0, fitTheta1->GetParameter(3));
      bgrndTheta1->SetParameter(1, fitTheta1->GetParameter(4));
      bgrndTheta1->SetParameter(2, fitTheta1->GetParameter(5));
      bgrndTheta1->SetLineColor(2);
      bgrndTheta1->Draw("same");
      (c1->cd(2))->SetGrid();
      
      c1->cd(3);
      TH1D *dPhi0 = new TH1D("dPhi0", "#Delta#phi_{T-E} for Primary Tracks with p_{T} > 1.5 GeV/c", 100, -0.10, 0.10);
      dPhi0->SetXTitle("#Delta#phi_{T-E} (azimuthal residual, radians)");
      dPhi0->SetYTitle("Counts per 0.002 radian bin");
      hTree->Project("dPhi0", "dPhiBestAngleMatch", "abs(dxyVertexBestTrackMatch)<1.0&&valueBestAngleMatch<0.10&&valueBestAngleMatch>=0.0");
      (dPhi0->GetXaxis())->SetLabelSize(0.040);
      (dPhi0->GetXaxis())->SetTitleOffset(0.8);
      (dPhi0->GetXaxis())->SetTitleSize(0.05);
      (dPhi0->GetXaxis())->CenterTitle();
      (dPhi0->GetYaxis())->SetLabelSize(0.040);
      (dPhi0->GetYaxis())->SetTitleOffset(0.9);
      (dPhi0->GetYaxis())->SetTitleSize(0.05);
      (dPhi0->GetYaxis())->CenterTitle();
      
      TF1 *fitPhi0 = new TF1("fitPhi0", doubleGaussPeak, -0.1, +0.1, 6);
      fitPhi0->SetParameters(400, 0.0, 0.02, 200.0, 0.0, 0.08);
      fitPhi0->SetParName(0, "Ampl1");
      fitPhi0->SetParName(1, "Cent1");
      fitPhi0->SetParName(2, "Sigma1");
      fitPhi0->SetParName(3, "Ampl2");
      fitPhi0->SetParName(4, "Cent2");
      fitPhi0->SetParName(5, "Sigma2");
      
      fitPhi0->SetNpx(500);
      fitPhi0->SetLineWidth(2);
      fitPhi0->SetLineColor(kBlue);
      
      dPhi0->Fit("fitPhi0", "", "", -0.1, +0.1);
      TF1 *bgrndPhi0 = new TF1("bgrndPhi0", gaussPeak, -0.1, +0.1, 3);
      bgrndPhi0->SetParameter(0, fitPhi0->GetParameter(3));
      bgrndPhi0->SetParameter(1, fitPhi0->GetParameter(4));
      bgrndPhi0->SetParameter(2, fitPhi0->GetParameter(5));
      bgrndPhi0->SetLineColor(2);
      bgrndPhi0->Draw("same");
      (c1->cd(3))->SetGrid();
      
      c1->cd(4);
      TH1D *dTheta0 = new TH1D("dTheta0", "#Delta#theta_{T-E} for Primary Tracks with p_{T} > 1.5 GeV/c", 100, -0.10, 0.10);
      dTheta0->SetXTitle("#Delta#theta_{T-E} (polar angle residual, radians)");
      dTheta0->SetYTitle("Counts per 0.002 radian bin");
      hTree->Project("dTheta0", "dThetaBestAngleMatch", "abs(dxyVertexBestTrackMatch)<1.0&&valueBestAngleMatch<0.10&&valueBestAngleMatch>=0.0");
      (dTheta0->GetXaxis())->SetLabelSize(0.040);
      (dTheta0->GetXaxis())->SetTitleOffset(0.8);
      (dTheta0->GetXaxis())->SetTitleSize(0.05);
      (dTheta0->GetXaxis())->CenterTitle();
      (dTheta0->GetYaxis())->SetLabelSize(0.040);
      (dTheta0->GetYaxis())->SetTitleOffset(0.9);
      (dTheta0->GetYaxis())->SetTitleSize(0.05);
      (dTheta0->GetYaxis())->CenterTitle();
      
      TF1 *fitTheta0 = new TF1("fitTheta0", doubleGaussPeak, -0.1, +0.1, 6);
      fitTheta0->SetParameters(400, 0.0, 0.02, 150.0, 0.0, 0.07);
      fitTheta0->SetParName(0, "Ampl1");
      fitTheta0->SetParName(1, "Cent1");
      fitTheta0->SetParName(2, "Sigma1");
      fitTheta0->SetParName(3, "Ampl2");
      fitTheta0->SetParName(4, "Cent2");
      fitTheta0->SetParName(5, "Sigma2");
      
      fitTheta0->SetNpx(500);
      fitTheta0->SetLineWidth(2);
      fitTheta0->SetLineColor(kBlue);
      
      dTheta0->Fit("fitTheta0", "", "", -0.1, +0.1);
      TF1 *bgrndTheta0 = new TF1("bgrndTheta0", gaussPeak, -0.1, +0.1, 3);
      bgrndTheta0->SetParameter(0, fitTheta0->GetParameter(3));
      bgrndTheta0->SetParameter(1, fitTheta0->GetParameter(4));
      bgrndTheta0->SetParameter(2, fitTheta0->GetParameter(5));
      bgrndTheta0->SetLineColor(2);
      bgrndTheta0->Draw("same");
      (c1->cd(4))->SetGrid();
      
      return;
      
    } // iOption = 11 Projections for dPhi, dTheta residual histogram fitting
    
    if(iOption == 12) {
      c1->Divide(1,2);
      
      c1->cd(1);
      TH2D *dThetaDz1 = new TH2D("dThetaDz1", "#Delta#Theta vs #Delta Z", 100, -20.0, 20.0, 100, -0.06, 0.06);
      hTree->Project("dThetaDz1", "dThetaBestAngleMatch:dzVertexBestTrackMatch", "abs(dxyVertexBestTrackMatch)>=1.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      dThetaDz1->SetStats(0);
      dThetaDz1->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      TH2D *dThetaDz0 = new TH2D("dThetaDz0", "#Delta#Theta vs #Delta Z", 100, -20.0, 20.0, 100, -0.06, 0.06);
      hTree->Project("dThetaDz0", "dThetaBestAngleMatch:dzVertexBestTrackMatch", "abs(dxyVertexBestTrackMatch)<1.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      dThetaDz0->SetStats(0);
      dThetaDz0->Draw("contz");
      (c1->cd(2))->SetLogz();
      (c1->cd(2))->SetGrid();
      
      return;
      
    } // iOption = 12 Projection for dThetaDz
    
    
    if(iOption == 13) { // Projection for dTheta vs Zvtx
      c1->Divide(1,2);
      
      //
      // Initial results indicate a -3.0e-04*zPrimaryVtx correction factor is needed as a function of zPrimaryVtx
      //
      
      c1->cd(1);
      TH2D *dThetaDz1 = new TH2D("dThetaDz1", "#Delta#Theta vs Zvtx", 100, -20.0, 20.0, 100, -0.06, 0.06);
      hTree->Project("dThetaDz1", "dThetaBestAngleMatch:zPrimaryVtx", "abs(dxyVertexBestTrackMatch)>=1.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      dThetaDz1->SetStats(0);
      dThetaDz1->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      TH2D *dThetaDz0 = new TH2D("dThetaDz0", "#Delta#Theta vs Zvtx", 100, -20.0, 20.0, 100, -0.06, 0.06);
      hTree->Project("dThetaDz0", "dThetaBestAngleMatch:zPrimaryVtx", "abs(dxyVertexBestTrackMatch)<1.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      dThetaDz0->SetStats(0);
      dThetaDz0->Draw("contz");
      (c1->cd(2))->SetLogz();
      (c1->cd(2))->SetGrid();
      
      return;
      
    } // iOption = 13 Projection for dTheta vs Zvtx
    
    
    if(iOption == 14) { // for particle ID, with ptClu
      c1->Divide(1,2);
      
      c1->cd(1);
      TH2D *ePRatioAngMatch1 = new TH2D("ePRatioAngMatch1", "Ratio E/p vs Opening Angle #Delta#Theta_{T-E} for Secondary Tracks with p_{T} > 1.5 GeV/c", 100, 0.0, 0.20, 100, 0.0, 2.0);
      ePRatioAngMatch1->SetXTitle("#Delta#Theta_{T-E} (opening angle between track projection and ECAL cluster, radians)");
      ePRatioAngMatch1->SetYTitle("Ratio of cluster energy to track momentum");
      (ePRatioAngMatch1->GetXaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch1->GetXaxis())->SetTitleOffset(0.8);
      (ePRatioAngMatch1->GetXaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch1->GetXaxis())->CenterTitle();
      (ePRatioAngMatch1->GetYaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch1->GetYaxis())->SetTitleOffset(0.5);
      (ePRatioAngMatch1->GetYaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch1->GetYaxis())->CenterTitle();
      hTree->Project("ePRatioAngMatch1", "ptClu/momentumBestTrackMatch:valueBestAngleMatch", "ptClu/momentumBestTrackMatch<1.4&&outerRadiusTrackMatch>80.0&&abs(dxyVertexBestTrackMatch)>=1.0&&valueBestAngleMatch<0.20&&valueBestAngleMatch>=0.0");
      ePRatioAngMatch1->SetStats(0);
      ePRatioAngMatch1->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      TLatex *runLabel1a = new TLatex(0.025, 1.81, "MC pPb for 2013");
      runLabel1a->SetTextColor(kBlack);
      runLabel1a->SetTextSize(0.08);
      runLabel1a->Draw();
      
      TLatex *runLabel1b = new TLatex(0.025, 1.61, "E/p particle identification for secondary tracks");
      runLabel1b->SetTextColor(kBlack);
      runLabel1b->SetTextSize(0.06);
      runLabel1b->Draw();
      
      TLatex *runLabel1c = new TLatex(0.035, 1.46, "Opening angle #Delta#Theta_{T-E} #equiv cos^{-1}[cos(#theta_{T})cos(#theta_{E}) - sin(#theta_{T})sin(#theta_{E})cos(#phi_{T}-#phi_{E})]");
      runLabel1c->SetTextColor(kBlack);
      runLabel1c->SetTextSize(0.045);
      runLabel1c->Draw();
      
      c1->cd(2);
      TH2D *ePRatioAngMatch0 = new TH2D("ePRatioAngMatch0", "Ratio E/p vs Opening Angle #Delta#Theta_{T-E} for Primary Tracks with p_{T} > 1.5 GeV/c", 100, 0.0, 0.20, 100, 0.0, 2.0);
      ePRatioAngMatch0->SetXTitle("#Delta#Theta_{T-E} (opening angle between track projection and ECAL cluster, radians)");
      ePRatioAngMatch0->SetYTitle("Ratio of cluster energy to track momentum");
      (ePRatioAngMatch0->GetXaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch0->GetXaxis())->SetTitleOffset(0.8);
      (ePRatioAngMatch0->GetXaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch0->GetXaxis())->CenterTitle();
      (ePRatioAngMatch0->GetYaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch0->GetYaxis())->SetTitleOffset(0.5);
      (ePRatioAngMatch0->GetYaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch0->GetYaxis())->CenterTitle();
      hTree->Project("ePRatioAngMatch0", "ptClu/momentumBestTrackMatch:valueBestAngleMatch", "outerRadiusTrackMatch>80.0&&abs(dxyVertexBestTrackMatch)<1.0&&valueBestAngleMatch<0.20&&valueBestAngleMatch>=0.0");
      ePRatioAngMatch0->SetStats(0);
      ePRatioAngMatch0->Draw("contz");
      (c1->cd(2))->SetLogz();
      (c1->cd(2))->SetGrid();
      
      TLatex *runLabel2a = new TLatex(0.025, 1.81, "MC pPb for 2013");
      runLabel2a->SetTextColor(kBlack);
      runLabel2a->SetTextSize(0.08);
      runLabel2a->Draw();
      
      TLatex *runLabel2b = new TLatex(0.025, 1.61, "E/p particle identification for primary tracks");
      runLabel2b->SetTextColor(kBlack);
      runLabel2b->SetTextSize(0.06);
      runLabel2b->Draw();
      
      return;
      
    } // iOption = 14 Projection for particle ID
    
    
    if(iOption == 15) { // dTheta vs zClu
      c1->Divide(1,2);
      
      //
      // Initial results indicate a -3.0e-04*zPrimaryVtx correction factor is needed as a function of zPrimaryVtx
      //
      
      c1->cd(1);
      TH2D *dThetaDz1 = new TH2D("dThetaDz1", "#Delta#Theta vs zClu", 100, -300.0, 300.0, 100, -0.06, 0.06);
      hTree->Project("dThetaDz1", "dThetaBestAngleMatch:zClu", "abs(dxyVertexBestTrackMatch)>=1.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      dThetaDz1->SetStats(0);
      dThetaDz1->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      TH2D *dThetaDz0 = new TH2D("dThetaDz0", "#Delta#Theta vs zClu", 150, -300.0, 300.0, 100, -0.06, 0.06);
      hTree->Project("dThetaDz0", "dThetaBestAngleMatch:zClu", "abs(dxyVertexBestTrackMatch)<1.0&&valueBestAngleMatch<0.06&&valueBestAngleMatch>=0.0");
      dThetaDz0->SetStats(0);
      dThetaDz0->Draw("contz");
      (c1->cd(2))->SetLogz();
      (c1->cd(2))->SetGrid();
      
      return;
      
    } // iOption = 15 Projection for dTheta vs zClu
    
    if(iOption == 16) { // dTheta vs zClu, loop over hTree events
      c1->Divide(1,2);
      
      //
      // Initial results indicate a -3.0e-04*zPrimaryVtx correction factor is needed as a function of zPrimaryVtx
      //
      TH2D *dThetaDz1 = new TH2D("dThetaDz1", "#Delta#Theta vs zClu (Secondary Particles, p_{T} > 1.5 GeV/c)", 100, -300.0, 300.0, 100, -0.06, 0.06);
      TH2D *dThetaDz0 = new TH2D("dThetaDz0", "#Delta#Theta vs zClu (Primary Particles), p_{T} > 1.5 GeV/c", 100, -300.0, 300.0, 100, -0.06, 0.06);
      
      int countPrimary = 0;
      int countSecondary = 0;
      
      
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
        hTree->GetEntry(i);
        
        if(i%nEntries10 == 0 && i !=0) {
          cout << "\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
          cout << "; current primary count = " << countPrimary;
          cout << ", current secondary count = " << countSecondary;
        }
        
        for(int jClu=0; jClu<nClu; jClu++) {
          
          if(valueBestAngleMatch[jClu] <0.06 && valueBestAngleMatch[jClu] > 0.0) {
            
            if(usezEcalCorrection) {
              float zCalValue = zClu[jClu];
              
              if(zCalValue >= zEcalCut)
                dThetaBestAngleMatch[jClu] += zEcalSaturationValue;
              
              if(zCalValue <= -zEcalCut)
                dThetaBestAngleMatch[jClu] -= zEcalSaturationValue;
              
              if(zCalValue > -zEcalCut && zCalValue < zEcalCut)
                dThetaBestAngleMatch[jClu] += zEcalCorrectionFactor*zCalValue;
              
            }
            
            if(fabs(dxyVertexBestTrackMatch[jClu]) >= 1.0) {
              //
              // Secondary particle
              //
              countSecondary++;
              dThetaDz1->Fill(zClu[jClu], dThetaBestAngleMatch[jClu]);
            }
            if(fabs(dxyVertexBestTrackMatch[jClu]) < 1.0 && dxyVertexBestTrackMatch[jClu] > -998.0 ) {
              //
              // Primary particle
              //
              countPrimary++;
              dThetaDz0->Fill(zClu[jClu], dThetaBestAngleMatch[jClu]);
            }
            
          } // check on angular match range
          
        } // loop over clusters in this event
        
        
      } // loop over entries
      
      cout << "\n Number of primaries = " << countPrimary;
      cout << ",  number of secondaries = " << countSecondary;
      
      cout << endl;
      
      c1->cd(1);
      dThetaDz1->SetStats(0);
      dThetaDz1->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      dThetaDz0->SetStats(0);
      dThetaDz0->Draw("contz");
      (c1->cd(2))->SetLogz();
      (c1->cd(2))->SetGrid();
      
    } // iOption = 16, loop over nEntries for dTheta vs zClu
    
    if(iOption == 17) { // for particle ID, with ptClu, and outerPtTrackMatch check
      c1->Divide(1,2);
      
      c1->cd(1);
      TH2D *ePRatioAngMatch1 = new TH2D("ePRatioAngMatch1", "Ratio E/p vs Opening Angle #Delta#Theta_{T-E} for Secondary Tracks with p_{T} > 1.5 GeV/c", 100, 0.0, 0.20, 100, 0.0, 2.0);
      ePRatioAngMatch1->SetXTitle("#Delta#Theta_{T-E} (opening angle between track projection and ECAL cluster, radians)");
      ePRatioAngMatch1->SetYTitle("Ratio of cluster energy to track momentum");
      (ePRatioAngMatch1->GetXaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch1->GetXaxis())->SetTitleOffset(0.8);
      (ePRatioAngMatch1->GetXaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch1->GetXaxis())->CenterTitle();
      (ePRatioAngMatch1->GetYaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch1->GetYaxis())->SetTitleOffset(0.5);
      (ePRatioAngMatch1->GetYaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch1->GetYaxis())->CenterTitle();
      hTree->Project("ePRatioAngMatch1", "ptClu/momentumBestTrackMatch:valueBestAngleMatch", "outerPtTrackMatch/momentumBestTrackMatch>0.95&&ptClu/momentumBestTrackMatch<1.4&&outerRadiusTrackMatch>80.0&&abs(dxyVertexBestTrackMatch)>=1.0&&valueBestAngleMatch<0.20&&valueBestAngleMatch>=0.0");
      ePRatioAngMatch1->SetStats(0);
      ePRatioAngMatch1->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      TLatex *runLabel1a = new TLatex(0.025, 1.81, "MC pPb for 2013");
      runLabel1a->SetTextColor(kBlack);
      runLabel1a->SetTextSize(0.08);
      runLabel1a->Draw();
      
      TLatex *runLabel1b = new TLatex(0.025, 1.61, "E/p particle identification for secondary tracks");
      runLabel1b->SetTextColor(kBlack);
      runLabel1b->SetTextSize(0.06);
      runLabel1b->Draw();
      
      TLatex *runLabel1c = new TLatex(0.035, 1.46, "Opening angle #Delta#Theta_{T-E} #equiv cos^{-1}[cos(#theta_{T})cos(#theta_{E}) - sin(#theta_{T})sin(#theta_{E})cos(#phi_{T}-#phi_{E})]");
      runLabel1c->SetTextColor(kBlack);
      runLabel1c->SetTextSize(0.045);
      runLabel1c->Draw();
      
      c1->cd(2);
      TH2D *ePRatioAngMatch0 = new TH2D("ePRatioAngMatch0", "Ratio E/p vs Opening Angle #Delta#Theta_{T-E} for Primary Tracks with p_{T} > 1.5 GeV/c", 100, 0.0, 0.20, 100, 0.0, 2.0);
      ePRatioAngMatch0->SetXTitle("#Delta#Theta_{T-E} (opening angle between track projection and ECAL cluster, radians)");
      ePRatioAngMatch0->SetYTitle("Ratio of cluster energy to track momentum");
      (ePRatioAngMatch0->GetXaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch0->GetXaxis())->SetTitleOffset(0.8);
      (ePRatioAngMatch0->GetXaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch0->GetXaxis())->CenterTitle();
      (ePRatioAngMatch0->GetYaxis())->SetLabelSize(0.045);
      (ePRatioAngMatch0->GetYaxis())->SetTitleOffset(0.5);
      (ePRatioAngMatch0->GetYaxis())->SetTitleSize(0.05);
      (ePRatioAngMatch0->GetYaxis())->CenterTitle();
      hTree->Project("ePRatioAngMatch0", "ptClu/momentumBestTrackMatch:valueBestAngleMatch", "outerPtTrackMatch/momentumBestTrackMatch>0.95&&outerRadiusTrackMatch>80.0&&abs(dxyVertexBestTrackMatch)<1.0&&valueBestAngleMatch<0.20&&valueBestAngleMatch>=0.0");
      ePRatioAngMatch0->SetStats(0);
      ePRatioAngMatch0->Draw("contz");
      (c1->cd(2))->SetLogz();
      (c1->cd(2))->SetGrid();
      
      TLatex *runLabel2a = new TLatex(0.025, 1.81, "MC pPb for 2013");
      runLabel2a->SetTextColor(kBlack);
      runLabel2a->SetTextSize(0.08);
      runLabel2a->Draw();
      
      TLatex *runLabel2b = new TLatex(0.025, 1.61, "E/p particle identification for primary tracks");
      runLabel2b->SetTextColor(kBlack);
      runLabel2b->SetTextSize(0.06);
      runLabel2b->Draw();
      
      return;
      
    } // iOption = 17 Projection for particle ID, with outerPtTrackMatch check
    
    if(iOption == 18 || iOption == -18) { // plotting photon conversion spectra
      c1->Divide(2,1);
      
      //
      // Initial results indicate a -3.0e-04*zPrimaryVtx correction factor is needed as a function of zPrimaryVtx
      //
      TH1D *etaPhoton = new TH1D("etaPhoton", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhoton = new TH1D("ptPhoton", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
      
      TH1D *etaPhotonNoConv = new TH1D("etaPhotonNoConv", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhotonNoConv = new TH1D("ptPhotonNoConv", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
      
      TH1D *etaPhotonNoConvLine = new TH1D("etaPhotonNoConv", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhotonNoConvLine = new TH1D("ptPhotonNoConv", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
      
      TH1D *etaPhotonConv = new TH1D("etaPhotonConv", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhotonConv = new TH1D("ptPhotonConv", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
      
      int countPrimaryPhotons = 0;
      int countNoConvPhotons = 0;
      int countConvPhotons = 0;
      
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
        hTree->GetEntry(i);
        
        if(i%nEntries10 == 0 || i < 10) {
          cout << "\n\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
          cout << "; current primary count photons = " << countPrimaryPhotons;
          cout << ", no conversion photons " << countNoConvPhotons << " and conversion photons " << countConvPhotons;
          cout << "\n mergedTrackTruthSize " << mergedTrackTruthSize;
          cout << "; first element primary, pdgId, eta = " << primaryTrackMerge[0] << ", " ;
          cout << etaMerge[0] << ", " << ptMerge[0];
        }
        
        for(int jMerge=0; jMerge<mergedTrackTruthSize; jMerge++) {
          
          if(primaryTrackMerge[jMerge] == 1 && pdgIdMerge[jMerge] == 22 && fabs(etaMerge[jMerge]) < 1.49  && fabs(ptMerge[jMerge]) > 0.5) {
            
            countPrimaryPhotons++;
            
            etaPhoton->Fill(etaMerge[jMerge]);
            ptPhoton->Fill(ptMerge[jMerge]);
            
            if(numberDecayVerticesMerge[jMerge] == 0) {
              etaPhotonNoConv->Fill(etaMerge[jMerge]);
              ptPhotonNoConv->Fill(ptMerge[jMerge]);
              etaPhotonNoConvLine->Fill(etaMerge[jMerge]);
              ptPhotonNoConvLine->Fill(ptMerge[jMerge]);
              countNoConvPhotons++;
            }
            else {
              etaPhotonConv->Fill(etaMerge[jMerge]);
              ptPhotonConv->Fill(ptMerge[jMerge]);
              countConvPhotons++;
            }
            
          }  // check for primary photon
          
        } // loop over mergeTrackTruth entries
        
      } // loop over entries
      
      c1->cd(1);
      float histogramMaximum = 1.2*etaPhoton->GetMaximum();
      etaPhoton->SetMaximum(histogramMaximum);
      etaPhoton->SetStats(0);
      etaPhoton->SetFillColor(kBlue);
      etaPhoton->SetXTitle("#eta value for primary vertex photon");
      etaPhoton->SetYTitle("Counts per 0.02 #eta bin size");
      
      (etaPhoton->GetXaxis())->SetLabelSize(0.035);
      (etaPhoton->GetXaxis())->SetTitleOffset(0.8);
      (etaPhoton->GetXaxis())->SetTitleSize(0.040);
      (etaPhoton->GetXaxis())->CenterTitle();
      (etaPhoton->GetYaxis())->SetLabelSize(0.030);
      (etaPhoton->GetYaxis())->SetTitleOffset(1.2);
      (etaPhoton->GetYaxis())->SetTitleSize(0.040);
      (etaPhoton->GetYaxis())->CenterTitle();
      
      etaPhotonNoConv->SetFillColor(kGreen);
      etaPhotonNoConvLine->SetLineColor(kGreen);
      etaPhotonNoConvLine->SetLineWidth(2);
      etaPhotonConv->SetFillColor(kRed);
      
      etaPhoton->SetMinimum(0);
      etaPhoton->Draw();
      
      etaPhotonNoConv->Draw("same");
      etaPhotonConv->Draw("same");
      etaPhotonNoConvLine->Draw("same");
      
      (c1->cd(1))->SetGrid();
      
      TLatex *runLabel1a = new TLatex(-0.75, 0.95*histogramMaximum, "MC pPb for 2013");
      TLatex *runLabel1b;
      if(iOption == 18)
        runLabel1b = new TLatex(-0.75, 0.90*histogramMaximum, "#pi^{0} parent meson");
      else
        runLabel1b = new TLatex(-0.95, 0.90*histogramMaximum, "#eta(547.5 MeV) parent meson");
      
      runLabel1a->SetTextColor(kBlack);
      runLabel1a->SetTextSize(0.05);
      runLabel1a->Draw();
      
      runLabel1b->SetTextColor(kBlack);
      runLabel1b->SetTextSize(0.045);
      runLabel1b->Draw();
      
      c1->cd(2);
      ptPhoton->SetStats(0);
      ptPhoton->SetFillColor(kBlue);
      ptPhoton->SetXTitle("p_{T} value for primary vertex photon (GeV/c)");
      ptPhoton->SetYTitle("Counts per 0.04 GeV/c bin size");
      
      ptPhotonNoConv->SetFillColor(kGreen);
      ptPhotonNoConvLine->SetLineColor(kGreen);
      ptPhotonNoConvLine->SetLineWidth(2);
      ptPhotonConv->SetFillColor(kRed);
      
      ptPhoton->SetMinimum(1.);
      ptPhoton->Draw();
      
      (ptPhoton->GetXaxis())->SetLabelSize(0.035);
      (ptPhoton->GetXaxis())->SetTitleOffset(0.8);
      (ptPhoton->GetXaxis())->SetTitleSize(0.040);
      (ptPhoton->GetXaxis())->CenterTitle();
      (ptPhoton->GetYaxis())->SetLabelSize(0.035);
      (ptPhoton->GetYaxis())->SetTitleOffset(1.2);
      (ptPhoton->GetYaxis())->SetTitleSize(0.040);
      (ptPhoton->GetYaxis())->CenterTitle();
      
      ptPhotonNoConv->Draw("same");
      ptPhotonConv->Draw("same");
      ptPhotonNoConvLine->Draw("same");
      
      (c1->cd(2))->SetGrid();
      (c1->cd(2))->SetLogy();
      
      return;
      
    } // iOption = 18, plotting photon conversion spectra, using mergedTrackTruth
    
    
    if(iOption == 19 || iOption == -19) { // looking at mergedTrackTruth matches with ECAL clusters for primary photons
      c1->Divide(2,2);
      
      float plotLimit = 0.04;
      if(iOption == -19) {
        plotLimit = 0.20;
      }
      
      TH1D *dEtaMergeEcal = new TH1D("dEtaMergeEcal", "Photon #Delta#eta reco matches with truth tracks (NO Conversions)", 100, -plotLimit, plotLimit);
      dEtaMergeEcal->SetXTitle("#Delta#eta_{MC-RECO} (pseudorapidity residual, radians)");
      dEtaMergeEcal->SetYTitle("Counts");
      TH1D *dPhiMergeEcal = new TH1D("dPhiMergeEcal", "Photon #Delta#phi reco matches with truth tracks (NO Conversions)", 100, -plotLimit, plotLimit);
      dPhiMergeEcal->SetXTitle("#Delta#phi_{MC-RECO} (azimuthal residual, radians)");
      dPhiMergeEcal->SetYTitle("Counts");
      TH1D *dAngleMergeEcal = new TH1D("dAngleMergeEcal", "Photon #DeltaR reco matches with truth tracks (N0 Conversions)", 100, 0.0, plotLimit);
      dAngleMergeEcal->SetXTitle("#DeltaR_{MC-RECO} (sqrt(#Delta#phi^{2} + #Delta#eta^{2}), radians)");
      dAngleMergeEcal->SetYTitle("Counts");
      TH2D *dPhiDEtaMergeEcal = new TH2D("dPhiDEtaMergeEcal", "Photon #Delta#eta vs #Delta#phi reco matches with truth tracks (NO Conversions)", 100, -plotLimit, plotLimit, 100, -plotLimit, plotLimit);
      dPhiDEtaMergeEcal->SetXTitle("#Delta#eta_{MC-RECO} (pseudorapidity residual, rad)");
      dPhiDEtaMergeEcal->SetYTitle("#Delta#phi_{MC-RECO} (azimuthal residual, rad)");
      
      if(iOption == -19) {
        dEtaMergeEcal->SetTitle("Photon #Delta#eta reco matches with truth tracks (WITH Conversions)");
        dPhiMergeEcal->SetTitle("Photon #Delta#phi reco matches with truth tracks (WITH Conversions)");
        dAngleMergeEcal->SetTitle("Photon #DeltaR reco matches with truth tracks (WITH Conversions)");
        dPhiDEtaMergeEcal->SetTitle("Photon #Delta#eta vs #Delta#phi reco matches with truth tracks (WITH Conversions)");
      }
      
      (dPhiDEtaMergeEcal->GetXaxis())->SetLabelSize(0.040);
      (dPhiDEtaMergeEcal->GetXaxis())->SetTitleOffset(0.8);
      (dPhiDEtaMergeEcal->GetXaxis())->SetTitleSize(0.05);
      (dPhiDEtaMergeEcal->GetXaxis())->CenterTitle();
      (dPhiDEtaMergeEcal->GetYaxis())->SetLabelSize(0.040);
      (dPhiDEtaMergeEcal->GetYaxis())->SetTitleOffset(1.0);
      (dPhiDEtaMergeEcal->GetYaxis())->SetTitleSize(0.05);
      (dPhiDEtaMergeEcal->GetYaxis())->CenterTitle();
      
      (dAngleMergeEcal->GetXaxis())->SetLabelSize(0.040);
      (dAngleMergeEcal->GetXaxis())->SetTitleOffset(0.8);
      (dAngleMergeEcal->GetXaxis())->SetTitleSize(0.05);
      (dAngleMergeEcal->GetXaxis())->CenterTitle();
      (dAngleMergeEcal->GetYaxis())->SetLabelSize(0.040);
      (dAngleMergeEcal->GetYaxis())->SetTitleOffset(0.8);
      (dAngleMergeEcal->GetYaxis())->SetTitleSize(0.05);
      (dAngleMergeEcal->GetYaxis())->CenterTitle();
      
      (dEtaMergeEcal->GetXaxis())->SetLabelSize(0.040);
      (dEtaMergeEcal->GetXaxis())->SetTitleOffset(0.8);
      (dEtaMergeEcal->GetXaxis())->SetTitleSize(0.05);
      (dEtaMergeEcal->GetXaxis())->CenterTitle();
      (dEtaMergeEcal->GetYaxis())->SetLabelSize(0.040);
      (dEtaMergeEcal->GetYaxis())->SetTitleOffset(0.8);
      (dEtaMergeEcal->GetYaxis())->SetTitleSize(0.05);
      (dEtaMergeEcal->GetYaxis())->CenterTitle();
      
      (dPhiMergeEcal->GetXaxis())->SetLabelSize(0.040);
      (dPhiMergeEcal->GetXaxis())->SetTitleOffset(0.8);
      (dPhiMergeEcal->GetXaxis())->SetTitleSize(0.05);
      (dPhiMergeEcal->GetXaxis())->CenterTitle();
      (dPhiMergeEcal->GetYaxis())->SetLabelSize(0.040);
      (dPhiMergeEcal->GetYaxis())->SetTitleOffset(0.8);
      (dPhiMergeEcal->GetYaxis())->SetTitleSize(0.05);
      (dPhiMergeEcal->GetYaxis())->CenterTitle();
      
      int countPrimaryPhotons = 0;
      int countNoConvPhotons = 0;
      int countConvPhotons = 0;
      
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
        hTree->GetEntry(i);
        
        if(i%nEntries10 == 0 || i < 10) {
          cout << "\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
          cout << "; current primary count photons = " << countPrimaryPhotons;
          cout << ", no conversion photons " << countNoConvPhotons << ", conversion photons " << countConvPhotons;
          cout << ", and mergedTrackTruthSize " << mergedTrackTruthSize;
        }
        
        for(int jMerge=0; jMerge<mergedTrackTruthSize; jMerge++) {
          if(primaryTrackMerge[jMerge] == 1 && pdgIdMerge[jMerge] == 22 && fabs(etaMerge[jMerge]) < 1.49  && fabs(ptMerge[jMerge]) > 0.5) {
            
            countPrimaryPhotons++;
            
            if(numberDecayVerticesMerge[jMerge] == 0 && iOption == 19) {
              countNoConvPhotons++;
              dEtaMergeEcal->Fill(bestEcalDEtaMatch[jMerge]);
              dPhiMergeEcal->Fill(bestEcalDPhiMatch[jMerge]);
              dAngleMergeEcal->Fill(bestEcalAngleMatch[jMerge]);
              if(bestEcalAngleMatch[jMerge] >= 0.0 && bestEcalAngleMatch[jMerge] < 0.06) {
                dPhiDEtaMergeEcal->Fill(bestEcalDEtaMatch[jMerge], bestEcalDPhiMatch[jMerge]);
              }
            }
            if(numberDecayVerticesMerge[jMerge] > 0 && iOption == -19) {
              countConvPhotons++;
              dEtaMergeEcal->Fill(bestEcalDEtaMatch[jMerge]);
              dPhiMergeEcal->Fill(bestEcalDPhiMatch[jMerge]);
              dAngleMergeEcal->Fill(bestEcalAngleMatch[jMerge]);
              if(bestEcalAngleMatch[jMerge] >= 0.0 && bestEcalAngleMatch[jMerge] < 1.5*plotLimit) {
                dPhiDEtaMergeEcal->Fill(bestEcalDEtaMatch[jMerge], bestEcalDPhiMatch[jMerge]);
              }
            } // check decay vertices number
            
          } // check for primary track
          
        } // loop on merge tracks
        
      } // loop on entries
      
      c1->cd(1);
      dPhiDEtaMergeEcal->SetStats(0);
      dPhiDEtaMergeEcal->Draw("contz");
      (c1->cd(1))->SetLogz();
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      dEtaMergeEcal->SetStats(0);
      dEtaMergeEcal->Draw("");
      (c1->cd(2))->SetGrid();
      
      c1->cd(3);
      dPhiMergeEcal->SetStats(0);
      dPhiMergeEcal->Draw("");
      (c1->cd(3))->SetGrid();
      
      c1->cd(4);
      dAngleMergeEcal->SetStats(0);
      dAngleMergeEcal->Draw("");
      (c1->cd(4))->SetGrid();
      
      return;
      
    } // option 19, looking at mergedTrackTruth matching with ECAL clusters for primary photons
    
    if(iOption == 20) { // check pT reconstruction for unconverted and converted photons
      
      c1->Divide(2,2);
      
      TF1 *fitQuadFunction = new TF1("fitQuadFunction", quadraticFunction, 0.0, 3.0, 2);
      fitQuadFunction->SetParName(0, "Linear");  // give the name of the first parameter
      fitQuadFunction->SetParameter(0, 0.050211);    // give an initial guess of the first parameter
      fitQuadFunction->SetParName(1, "Quad");  // give the name of the second parameter
      fitQuadFunction->SetParameter(1, 0.045523);    // give an initial guess of the second parameter
      
      TH1D *ptResolutionUnconverted = new TH1D("ptResolutionUnconverted", "p_{T} Resolution for Unconverted Photons", 100, -0.75, 0.75);
      ptResolutionUnconverted->SetXTitle("(p_{T}^{ECAL} - p_{T}^{MC})/p_{T}^{MC}");
      ptResolutionUnconverted->SetYTitle("Counts");
      
      TH1D *ptResolutionConverted = new TH1D("ptResolutionConverted", "p_{T} Resolution for Converted Photons", 100, -0.75, 0.75);
      ptResolutionConverted->SetXTitle("(p_{T}^{ECAL} - p_{T}^{MC})/p_{T}^{MC}");
      ptResolutionConverted->SetYTitle("Counts");
      
      TH2D *ptResolutionUnconvertedVsPt = new TH2D("ptResolutionUnconvertedVsPt", "p_{T} Resolution for Unconverted Photons vs MC p_{T}",
                                                   100, 0.0, 5.0, 100, -0.75, 0.40);
      ptResolutionUnconvertedVsPt->SetYTitle("(p_{T}^{ECAL} - p_{T}^{MC})/p_{T}^{MC}");
      ptResolutionUnconvertedVsPt->SetXTitle("p_{T}^{MC} (GeV/c)");
      
      TH2D *ptResolutionUnconvertedVsPtEcal = new TH2D("ptResolutionUnconvertedVsPtEcal", "p_{T} Resolution for Unconverted Photons vs ECAL p_{T}",
                                                       100, 0.0, 5.0, 100, -0.75, 0.40);
      ptResolutionUnconvertedVsPtEcal->SetYTitle("(p_{T}^{ECAL} - p_{T}^{MC})/p_{T}^{MC}");
      ptResolutionUnconvertedVsPtEcal->SetXTitle("p_{T}^{ECAL} (GeV/c)");
      ptResolutionUnconvertedVsPtEcal->SetStats(0);
      
      TH2D *ptAfterVsBefore = new TH2D("ptAfterVsBefore", "p_{T} Correction: After vs Before",
                                       100, 0.0, 4.0, 100, 0.0, 4.0);
      ptAfterVsBefore->SetXTitle("p_{T}^{ECAL} (GeV/c) before correction");
      ptAfterVsBefore->SetYTitle("p_{T}^{ECAL} (GeV/c) after correction");
      ptAfterVsBefore->SetStats(0);
      
      TH2D *ptCorrectionVsPtInverse = new TH2D("ptCorrectionVsPtInverse", "p_{T} Correction vs Inverse of ECAL p_{T}", 100, 0.0, 3.0, 100, -0.3, 0.5);
      ptCorrectionVsPtInverse->SetXTitle("Inverse of p_{T}^{ECAL} before correction");
      ptCorrectionVsPtInverse->SetYTitle("Correction Factor");
      ptCorrectionVsPtInverse->SetStats(0);
			
      TH2D *ptResolutionVsEta = new TH2D("ptResolutionVsEta", "p_{T} Resolution (Unconverted) vs Eta", 150, -1.5, 1.5, 100, -0.5, 0.5);
      ptResolutionVsEta->SetXTitle("Psuedsorapidity #eta");
      ptResolutionVsEta->SetYTitle("(p_{T}^{ECAL} - p_{T}^{MC})/p_{T}^{MC}");
      ptResolutionVsEta->SetStats(0);
      
      ptResolutionUnconverted->SetXTitle("(p_{T}^{ECAL} - p_{T}^{MC})/p_{T}^{MC}");
      ptResolutionUnconverted->SetYTitle("Counts");
      
      (ptResolutionUnconverted->GetXaxis())->SetLabelSize(0.040);
      (ptResolutionUnconverted->GetXaxis())->SetTitleOffset(0.8);
      (ptResolutionUnconverted->GetXaxis())->SetTitleSize(0.05);
      (ptResolutionUnconverted->GetXaxis())->CenterTitle();
      (ptResolutionUnconverted->GetYaxis())->SetLabelSize(0.037);
      (ptResolutionUnconverted->GetYaxis())->SetTitleOffset(0.9);
      (ptResolutionUnconverted->GetYaxis())->SetTitleSize(0.05);
      (ptResolutionUnconverted->GetYaxis())->CenterTitle();
      
      (ptResolutionConverted->GetXaxis())->SetLabelSize(0.040);
      (ptResolutionConverted->GetXaxis())->SetTitleOffset(0.8);
      (ptResolutionConverted->GetXaxis())->SetTitleSize(0.05);
      (ptResolutionConverted->GetXaxis())->CenterTitle();
      (ptResolutionConverted->GetYaxis())->SetLabelSize(0.040);
      (ptResolutionConverted->GetYaxis())->SetTitleOffset(0.8);
      (ptResolutionConverted->GetYaxis())->SetTitleSize(0.05);
      (ptResolutionConverted->GetYaxis())->CenterTitle();
      
      (ptResolutionUnconvertedVsPt->GetXaxis())->SetLabelSize(0.040);
      (ptResolutionUnconvertedVsPt->GetXaxis())->SetTitleOffset(0.8);
      (ptResolutionUnconvertedVsPt->GetXaxis())->SetTitleSize(0.05);
      (ptResolutionUnconvertedVsPt->GetXaxis())->CenterTitle();
      (ptResolutionUnconvertedVsPt->GetYaxis())->SetLabelSize(0.037);
      (ptResolutionUnconvertedVsPt->GetYaxis())->SetTitleOffset(0.9);
      (ptResolutionUnconvertedVsPt->GetYaxis())->SetTitleSize(0.05);
      (ptResolutionUnconvertedVsPt->GetYaxis())->CenterTitle();
      
      (ptResolutionUnconvertedVsPtEcal->GetXaxis())->SetLabelSize(0.040);
      (ptResolutionUnconvertedVsPtEcal->GetXaxis())->SetTitleOffset(0.8);
      (ptResolutionUnconvertedVsPtEcal->GetXaxis())->SetTitleSize(0.05);
      (ptResolutionUnconvertedVsPtEcal->GetXaxis())->CenterTitle();
      (ptResolutionUnconvertedVsPtEcal->GetYaxis())->SetLabelSize(0.037);
      (ptResolutionUnconvertedVsPtEcal->GetYaxis())->SetTitleOffset(0.9);
      (ptResolutionUnconvertedVsPtEcal->GetYaxis())->SetTitleSize(0.05);
      (ptResolutionUnconvertedVsPtEcal->GetYaxis())->CenterTitle();
			
      (ptResolutionVsEta->GetXaxis())->SetLabelSize(0.040);
      (ptResolutionVsEta->GetXaxis())->SetTitleOffset(0.8);
      (ptResolutionVsEta->GetXaxis())->SetTitleSize(0.05);
      (ptResolutionVsEta->GetXaxis())->CenterTitle();
      (ptResolutionVsEta->GetYaxis())->SetLabelSize(0.037);
      (ptResolutionVsEta->GetYaxis())->SetTitleOffset(0.9);
      (ptResolutionVsEta->GetYaxis())->SetTitleSize(0.05);
      (ptResolutionVsEta->GetYaxis())->CenterTitle();
      
      (ptAfterVsBefore->GetXaxis())->SetLabelSize(0.040);
      (ptAfterVsBefore->GetXaxis())->SetTitleOffset(0.8);
      (ptAfterVsBefore->GetXaxis())->SetTitleSize(0.05);
      (ptAfterVsBefore->GetXaxis())->CenterTitle();
      (ptAfterVsBefore->GetYaxis())->SetLabelSize(0.037);
      (ptAfterVsBefore->GetYaxis())->SetTitleOffset(0.9);
      (ptAfterVsBefore->GetYaxis())->SetTitleSize(0.05);
      (ptAfterVsBefore->GetYaxis())->CenterTitle();
      
      int countPrimaryPhotons = 0;
      int countNoConvPhotons = 0;
      int countConvPhotons = 0;
      int countOutOfRangeEcalIndex = 0;
      int countOutOfRangeCrystal = 0;
      int countBadS4S9Ratio = 0;
      int countMissingMergeParent = 0;
      int countFoundMergeParent = 0;
			
      float lowEnergyCut[10] =  {0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.2, 2.0, 3.0};
      float highEnergyCut[10] = {0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.2, 2.0, 3.0, 5.0};
      
      int counts[10] =    {0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
      float energyMean[10] =  {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.};
      float energyValid[10] = {0., 0., 0., 0., 0., 0., 0., 0., 0., 0.};
      float resolutionEnergy[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      float correctionEnergy[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
			
      int countsEta[10] = {0,  0,  0,  0,  0,  0,  0,  0,  0,  0};
      float lowEtaCut[10] =  {-1.50, -1.20, -0.90, -0.60, -0.30, 0.00, 0.30, 0.60, 0.90, 1.20};
      float highEtaCut[10] = {-1.20, -0.90, -0.60, -0.30, 0.00,  0.30, 0.60, 0.90, 1.20, 1.50};
      float resolutionEta[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
			
      int pdgIdMergeParent[10000];
      
      int maxDebugPrint = 0;
      int countDebugPrint = 0;
      
      for (Long64_t i=0; i<entriesToProcess; i++) {
				
        hTree->GetEntry(i);
				
        if(i%nEntries10 == 0 || i < 10) {
          cout << "\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
          cout << "; current primary count photons = " << countPrimaryPhotons;
          cout << ", no conversion photons " << countNoConvPhotons << ", conversion photons " << countConvPhotons;
          cout << ", and mergedTrackTruthSize " << mergedTrackTruthSize;
        }
        
        for(int jMerge=0; jMerge<mergedTrackTruthSize; jMerge++) {
          pdgIdMergeParent[jMerge] = -1;
          float ptEcal = bestEcalPtMatch[jMerge];
          float ptTrue = ptMerge[jMerge];
          if(primaryTrackMerge[jMerge] == 1 && pdgIdMerge[jMerge] == 22 && fabs(etaMerge[jMerge]) < 1.49  &&
             ptEcal > lowEnergyCutParameter && ptTrue > 0.0) {
            for(int kPhoton=0; kPhoton<nPhotonSize; kPhoton++) {
              if(mergeIndexPhotonGen[kPhoton] == jMerge) {
                pdgIdMergeParent[jMerge] = motherPdgIdPhotonGen[kPhoton];
                break;
              }
            } // loop over photon collection
						
            if(pdgIdMergeParent[jMerge] == -1)
              countMissingMergeParent++;
            else
              countFoundMergeParent++;
            
          } // check for primary photons
					
        } // loop to get parent ID for the mergedTrackTruth photons
				
        for(int jMerge=0; jMerge<mergedTrackTruthSize; jMerge++) {
					
          int mergePdgIdParent = pdgIdMergeParent[jMerge];
          if(useOnlyPdg111 && mergePdgIdParent != 111)
            continue;
          if(useOnlyPdg221 && mergePdgIdParent != 221)
            continue;
          if(useBothPi0Eta && mergePdgIdParent != 221 && mergePdgIdParent != 111)
            continue;
          
          bool skipThisTrack = false;
					
          int indexEcal = bestEcalIndexMatch[jMerge];
          if(indexEcal < 0 || indexEcal >= nClu) {
            countOutOfRangeEcalIndex++;
            skipThisTrack = true;
          }
          
          float etaCal = etaClu[indexEcal];
          float etaTrue = etaMerge[jMerge];
          
          //
          // Change to looking at the S9 cluster energy instead of the pT
          //
          float energyEcal = S9Clu[indexEcal];
          float thetaTrue = 2.0*atan(exp(-etaTrue));
          float energyTrue = ptMerge[jMerge]/sin(thetaTrue);
          
          float ptEcal = ptClu[indexEcal];
          float ptTrue = ptMerge[jMerge];
					
          if(primaryTrackMerge[jMerge] == 1 && pdgIdMerge[jMerge] == 22 && fabs(etaCal) <= etaHighLimit  &&
             fabs(etaCal) >= etaLowLimit && energyEcal > lowEnergyCutParameter && ptTrue > 0.0) {
						
            countPrimaryPhotons++;  // these must have a valid indexEcal
            
            if(useClusterCrystalLimit && !clusterCrystalLimitLowPtOnly) {
              if(nCryClu[indexEcal] < lowCrystalLimit || nCryClu[indexEcal] > highCrystalLimit) {
                countOutOfRangeCrystal++;
                skipThisTrack = true;
              } // check on within crystal number range
            } // check on using crystal number limits
						
            if(S4Clu[indexEcal]/S9Clu[indexEcal] < 0.80) {
              countBadS4S9Ratio++;
              skipThisTrack = true;
            }
						
            if(skipThisTrack)
              continue;
            
            float ptOld = ptEcal;
            float energyOld = energyEcal;
            float energyCorrectionFactor = 0.0;
						
            if(useEnergyCorrection) {
              int crystalIndex = nCryClu[indexEcal] - 1;
              if(crystalIndex < 0 || crystalIndex > 8) {
                cerr << "\n Program error with crystalIndex = " << crystalIndex;
                return;
              }
              
              energyEcal = crystalCorrectionFunction(crystalIndex, energyOld);
              energyCorrectionFactor = energyEcal/energyOld;
              
              if(maxDebugPrint > 0 && countDebugPrint < maxDebugPrint) {
                countDebugPrint++;
                cout << "\n " << countDebugPrint << ") original energy = " << energyOld;
                cout << ",  corrected energy = " << energyEcal;
                cout << ",  energyCorrectionFactor = " << energyCorrectionFactor;
                cout << ",  crystal index =  " << crystalIndex;
                if(countDebugPrint >= maxDebugPrint) {
                  cout << endl;
                  return;
                }
              }
              
              ptEcal = ptOld*energyCorrectionFactor;
              
            } // check on useEnergyCorrection
            
            ptCorrectionVsPtInverse->Fill(1.0/ptOld, ptEcal/ptOld - 1.0);
						
            if(ptOld > 0.3 && ptOld < 5.0)
              ptAfterVsBefore->Fill(ptOld, ptEcal);
						
            float ptResolution = (ptEcal - ptTrue)/ptTrue;
            
            float energyResolution = (energyEcal - energyTrue)/energyTrue;
            float energyCorrection = (energyTrue - energyEcal)/energyEcal;
						
            if(numberDecayVerticesMerge[jMerge] == 0) {
              countNoConvPhotons++;
              if(bestEcalAngleMatch[jMerge] < 0.01){
                ptResolutionUnconverted->Fill(ptResolution);
                ptResolutionUnconvertedVsPt->Fill(ptTrue, ptResolution);
                ptResolutionUnconvertedVsPtEcal->Fill(ptOld, ptResolution);
                ptResolutionVsEta->Fill(bestEtaMatchMerge[jMerge], ptResolution); // could use the ECAL reco eta instead?
                
                for (int etaBin=0; etaBin<10; etaBin++) {
                  if(etaCal >= lowEtaCut[etaBin] && etaCal < highEtaCut[etaBin]) {
                    countsEta[etaBin]++;
                    resolutionEta[etaBin] += ptResolution;
                    break;
                  }
                } // loop over eta bins
								
                for(unsigned int energyBin=0; energyBin<10; energyBin++) {
                  if(energyEcal >= lowEnergyCut[energyBin] && energyEcal < highEnergyCut[energyBin]) {
                    counts[energyBin]++;
                    energyMean[energyBin] += energyEcal;
                    energyValid[energyBin] += energyTrue;
                    resolutionEnergy[energyBin] += energyResolution;
                    correctionEnergy[energyBin] += energyCorrection;
                    break;
                  } // check for energyEcal value
                } // loop over energyBins
								
              } // check for angleMatch < 0.05
            } // branch for no conversions
            else {
              countConvPhotons++;
              if(bestEcalAngleMatch[jMerge] < 0.20)
                ptResolutionConverted->Fill(ptResolution);
            } // branch for conversions
						
          } // check for primary photon
					
        } // loop over merge tracks
				
      } // loop over hTree entries
      
      c1->cd(1);
      ptResolutionUnconverted->Draw();
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      ptResolutionConverted->Draw();
      (c1->cd(2))->SetGrid();
      
      c1->cd(3);
      ptResolutionUnconvertedVsPt->SetStats(0);
      ptResolutionUnconvertedVsPt->Draw("contz");
      (c1->cd(3))->SetLogz();
      (c1->cd(3))->SetGrid();
      
      c1->cd(4);
      if(useEnergyCorrection) {
        ptCorrectionVsPtInverse->Draw("contz");
        // ptResolutionVsEta->Draw("contz");
      }
      else {
        ptResolutionUnconvertedVsPtEcal->Draw("contz");
      }
			
      (c1->cd(4))->SetLogz();
      (c1->cd(4))->SetGrid();
			
      cout << "\n\n Resolution as a function of energyEcal bin:";
      cout << "\n lowCrystalLimit " << lowCrystalLimit;
      cout << ", highCrystalLimit " << highCrystalLimit;
      cout << "\n useOnlyPdg111 " << useOnlyPdg111;
      cout << ",  useOnlyPdg221 " << useOnlyPdg221;
      cout << ",  useBothPi0Eta " << useBothPi0Eta;
      float weightedAverageResolutionEnergy = 0;
      float weightedAverageCorrectionEnergy = 0;
      float weightedAverageMeasuredEnergy = 0.0;
      int sumWeights = 0;
      int nDataToFit = 0;
      float xData[10];
      float xError[10];
      float yData[10];
      float yError[10];
      int dataCounts[10];
      int maxCounts = 0;
      for(unsigned int energyBin=0; energyBin<10; energyBin++) {
        cout << "\n " << energyBin << ") with counts " << counts[energyBin];
        if(counts[energyBin] > 0) {
          cout << ", <energyEcal> " << energyMean[energyBin]/counts[energyBin];
          cout << ", <energyTrue> " << energyValid[energyBin]/counts[energyBin];
          cout << ", <correctionEnergy> " << correctionEnergy[energyBin]/counts[energyBin];
          cout << ", <resolutionEnergy> " << resolutionEnergy[energyBin]/counts[energyBin];
          cout << ", <residual> " << (energyMean[energyBin] - energyValid[energyBin])/energyValid[energyBin];
          weightedAverageResolutionEnergy += resolutionEnergy[energyBin];
          weightedAverageCorrectionEnergy += correctionEnergy[energyBin];
          weightedAverageMeasuredEnergy += energyMean[energyBin];
          sumWeights += counts[energyBin];
          if(counts[energyBin] > 100) {
            xData[nDataToFit] = energyMean[energyBin]/counts[energyBin];
            xError[nDataToFit] = 0;
            yData[nDataToFit] = correctionEnergy[energyBin]/counts[energyBin];
            dataCounts[nDataToFit] = counts[energyBin];
            if(counts[energyBin] > maxCounts)
              maxCounts = counts[energyBin];
            nDataToFit++;
          }
        } // check for non-zero counts
      } // loop over energyBins
      cout << "\n Weighted average resolution " << weightedAverageResolutionEnergy/sumWeights;
      cout << ",  weighted average correction " << weightedAverageCorrectionEnergy/sumWeights;
      cout << ",  weighted average measured energy " << weightedAverageMeasuredEnergy/sumWeights;
			
      cout << "\n\n Resolution as a function of ECAL eta bin:";
      for(int etaBin=0; etaBin<10; etaBin++) {
        cout << "\n " << etaBin << ") with counts " << countsEta[etaBin];
        if(countsEta[etaBin] > 0)
          cout << " and resolution " << resolutionEta[etaBin]/countsEta[etaBin];
      }
			
      cout << "\n\n Number of primary photons = " << countPrimaryPhotons;
      cout << "\n Number of merge tracks with found parent = " << countFoundMergeParent;
      cout << "\n Number of merge tracks with missing parent = " << countMissingMergeParent;
      cout << "\n Number of out of range ECAL index = " << countOutOfRangeEcalIndex;
      cout << "\n Number of out of range crystal values = " << countOutOfRangeCrystal;
      cout << "\n Number of clusters with a bad S4/S9 ratio = " << countBadS4S9Ratio;
      cout << "\n Number of unconverted photons = " << countNoConvPhotons;
      cout << "\n Number of converted photons = " << countConvPhotons;
      cout << endl;
			
      if(doCorrectionFit) {
        c1->Clear();
        float baseError = 0.6/sqrt(float(maxCounts));
        for(int kData=0; kData<nDataToFit; kData++) {
          yError[kData] = sqrt(float(maxCounts)/float(dataCounts[kData]))*baseError*yData[kData];
        }
				
        TGraphErrors *graphCorrection1 = new TGraphErrors(nDataToFit, xData, yData, xError, yError);
        graphCorrection1->SetTitle("Correction function for single crystal clusters");
        graphCorrection1->SetMarkerColor(4);
        graphCorrection1->SetMarkerStyle(20);
        graphCorrection1->SetMarkerSize(1.00);
        graphCorrection1->SetMinimum(0.20);
        graphCorrection1->SetMaximum(0.32);
        if(lowCrystalLimit == 2) {
          graphCorrection1->SetTitle("Correction function for two-crystal clusters");
          graphCorrection1->SetMinimum(0.14);
          graphCorrection1->SetMaximum(0.20);
        }
        
        (graphCorrection1->GetXaxis())->SetTitle("ECAL Energy (GeV)");
        (graphCorrection1->GetYaxis())->SetTitle("Correction Factor");
				
        TF1 *fitCorrectionCrystal1 = new TF1("fitCorrectionCrystal1", linearBackground, 0.0, 1.0, 2);
        fitCorrectionCrystal1->SetParName(0, "Intercept");
        fitCorrectionCrystal1->SetParName(1, "Slope");
        fitCorrectionCrystal1->SetParameter(0, 0.24);
        fitCorrectionCrystal1->SetParameter(1, 0.10);
				
        graphCorrection1->Fit("fitCorrectionCrystal1");
        graphCorrection1->Draw("AP");
        c1->SetGrid();
				
        graphCorrection1->Fit("fitCorrectionCrystal1");
        graphCorrection1->Draw("AP");
        cout << "\n\n Fit results: Intercept = " << fitCorrectionCrystal1->GetParameter(0);
        cout << ",  Slope = " << fitCorrectionCrystal1->GetParameter(1);
        cout << endl;
				
        return;
				
      } // do energy correction fit
			
      return;
      
    } // option 20,  check pT reconstruction for unconverted and converted photons
    
    if(iOption == 21) { // generate pi0 mass spectrum from unconverted primary photons
      
      TH1D *uncorrectedPairMass = new TH1D("uncorrectedPairMass", "Di-photon Mass Before ECAL Energy Corrections (unconverted photons only)",
                                           200, 0.0, 0.80);
      
      TH1D *correctedPairMass = new TH1D("correctedPairMass", "Di-photon Mass After ECAL Energy Corrections (unconverted photons only)",
                                         200, 0.0, 0.80);
      
      TH1D *uncorrectedPairMassLowPt = new TH1D("uncorrectedPairMassLowPt", "Di-photon Mass 0.7<p_{T}<1.0 GeV/c Before Corrections (unconverted photons only)",
                                                200, 0.0, 0.80);
      
      TH1D *correctedPairMassLowPt = new TH1D("correctedPairMassLowPt", "Di-photon Mass 0.7<p_{T}<1.0 GeV/c After Corrections (unconverted photons only)",
                                              200, 0.0, 0.80);
      
      TH1D *uncorrectedPairMassMidPt = new TH1D("uncorrectedPairMassMidPt", "Di-photon Mass 1.0<p_{T}<1.5 GeV/c Before Corrections (unconverted photons only)",
                                                200, 0.0, 0.80);
      
      TH1D *correctedPairMassMidPt = new TH1D("correctedPairMassMidPt", "Di-photon Mass 1.0<p_{T}<1.5 GeV/c After Corrections (unconverted photons only)",
                                              200, 0.0, 0.80);
      
      int countPrimaryPhotons = 0;
      int countNoConvPhotons = 0;
      int countConvPhotons = 0;
      int countEvents = 0;
      
      int maxArraySize = 0;
      
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
        const int ARRAYMAX = 2000;
        float ecalEnergyBefore[2000];
        float ecalEnergyAfter[2000];
        float ecalTheta[2000];
        float ecalPhi[2000];
        
        hTree->GetEntry(i);
        
        if(i%nEntries10 == 0 || i < 10) {
          cout << "\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
          cout << "; current primary count photons = " << countPrimaryPhotons;
          cout << ", no conversion photons " << countNoConvPhotons << ", conversion photons " << countConvPhotons;
          cout << ", and mergedTrackTruthSize " << mergedTrackTruthSize;
        }
        
        countEvents++;
        
        int kArray = 0;
        for(int jMerge=0; jMerge<mergedTrackTruthSize; jMerge++) {
          
          if(primaryTrackMerge[jMerge] == 1 && pdgIdMerge[jMerge] == 22 && bestEcalPtMatch[jMerge] > 0.30 && fabs(etaMerge[jMerge]) < 1.49  && fabs(ptMerge[jMerge]) > 0.4) {
            
            int indexEcal = bestEcalIndexMatch[jMerge];
            if(indexEcal < 0 || indexEcal >= nClu)
              continue;
            
            if(useClusterCrystalLimit) {
              if(nCryClu[indexEcal] < lowCrystalLimit || nCryClu[indexEcal] > highCrystalLimit)
                continue;
            } // check on using crystal number limits
            int crystalIndex = nCryClu[indexEcal] - 1;
            
            countPrimaryPhotons++;
            
            if(numberDecayVerticesMerge[jMerge] == 0) {
              countNoConvPhotons++;
              if(kArray < ARRAYMAX) {
                float ptEcalOld = bestEcalPtMatch[jMerge];
                ecalPhi[kArray] = bestEcalDPhiMatch[jMerge] + phiMerge[jMerge];
                float ecalEta = bestEcalDEtaMatch[jMerge] + etaMerge[jMerge];
                ecalTheta[kArray] = 2.0*atan(exp(-ecalEta));
                float ecalEnergyUncorrected = ptEcalOld/sin(ecalTheta[kArray]);
                
                ecalEnergyBefore[kArray] = ecalEnergyUncorrected;
                ecalEnergyAfter[kArray] = crystalCorrectionFunction(crystalIndex, ecalEnergyUncorrected);
              }
              kArray++;
            }
            else {
              countConvPhotons++;
            }
            
          }  // check for primary track above 0.4 GeV/c
          
        } // loop on merge tracks
        if(kArray > maxArraySize)
          maxArraySize = kArray;
        
        if(kArray > 1) { // check for at least two clusters
          int kArrayMinusOne = kArray - 1;
          
          for(int jClu=0; jClu< kArrayMinusOne; jClu++) {
            
            float cosTheta1 = cos(ecalTheta[jClu]);
            float sinTheta1 = sin(ecalTheta[jClu]);
            float phi1 = ecalPhi[jClu];
            float cosphi1 = cos(phi1);
            float sinphi1 = sin(phi1);
            float uncorrectedEnergy1 = ecalEnergyBefore[jClu];
            float correctedEnergy1 = ecalEnergyAfter[jClu];
            
            float pt1Uncorrected = uncorrectedEnergy1*sinTheta1;
            float px1Uncorrected = pt1Uncorrected*cosphi1;
            float py1Uncorrected = pt1Uncorrected*sinphi1;
            
            float pt1Corrected = correctedEnergy1*sinTheta1;
            float px1Corrected = pt1Corrected*cosphi1;
            float py1Corrected = pt1Corrected*sinphi1;
            
            int jCluPlusOne = jClu + 1;
            
            for(int mClu=jCluPlusOne; mClu< kArray; mClu++) {
              
              float cosTheta2 = cos(ecalTheta[mClu]);
              float sinTheta2 = sin(ecalTheta[mClu]);
              float phi2 = ecalPhi[mClu];
              float cosphi2 = cos(phi2);
              float sinphi2 = sin(phi2);
              float uncorrectedEnergy2 = ecalEnergyBefore[mClu];
              float correctedEnergy2 = ecalEnergyAfter[mClu];
              
              float pt2Uncorrected = uncorrectedEnergy2*sinTheta2;
              float px2Uncorrected = pt2Uncorrected*cosphi2;
              float py2Uncorrected = pt2Uncorrected*sinphi2;
              
              float pt2Corrected = correctedEnergy2*sinTheta2;
              float px2Corrected = pt2Corrected*cosphi2;
              float py2Corrected = pt2Corrected*sinphi2;
              
              float pxUncorrected = px1Uncorrected + px2Uncorrected;
              float pyUncorrected = py1Uncorrected + py2Uncorrected;
              float ptUncorrected = sqrt(pxUncorrected*pxUncorrected + pyUncorrected*pyUncorrected);
              
              float pxCorrected = px1Corrected + px2Corrected;
              float pyCorrected = py1Corrected + py2Corrected;
              float ptCorrected = sqrt(pxCorrected*pxCorrected + pyCorrected*pyCorrected);
              
              float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
              
              float uncorrectedMassTest = 2.0*uncorrectedEnergy1*uncorrectedEnergy2*(1.0 - cosOpenAngle);
              if(uncorrectedMassTest > 0.0001) {
                uncorrectedPairMass->Fill(sqrt(uncorrectedMassTest));
                if(ptUncorrected > 0.7 && ptUncorrected < 1.0)
                  uncorrectedPairMassLowPt->Fill(sqrt(uncorrectedMassTest));
                if(ptUncorrected > 1.0 && ptUncorrected < 1.5)
                  uncorrectedPairMassMidPt->Fill(sqrt(uncorrectedMassTest));
              }
              
              float correctedMassTest = 2.0*correctedEnergy1*correctedEnergy2*(1.0 - cosOpenAngle);
              if(correctedMassTest > 0.0001) {
                correctedPairMass->Fill(sqrt(correctedMassTest));
                if(ptCorrected > 0.7 && ptCorrected < 1.0)
                  correctedPairMassLowPt->Fill(sqrt(correctedMassTest));
                if(ptCorrected > 1.0 && ptCorrected < 1.5)
                  correctedPairMassMidPt->Fill(sqrt(correctedMassTest));
              }
            } // inner cluster loop
            
          } // outer cluster loop
          
        }  // check for at least two clusters
        
      } // loop on entries
      
      cout << "\n\n Number of events = " << countEvents;
      cout << ",  count of uncoverted photons = " << countNoConvPhotons;
      cout << "   with max array size = " << maxArraySize << endl << endl;
      
      c1->Divide(3,2);
      
      c1->cd(1);
      uncorrectedPairMass->SetStats(0);
      uncorrectedPairMass->Draw();
      TLine *pi0MassValue1 = new TLine(0.134976, 0.0, 0.134976, uncorrectedPairMass->GetMaximum());
      pi0MassValue1->SetLineColor(kMagenta);
      pi0MassValue1->Draw("same");
      (c1->cd(1))->SetGrid();
      
      c1->cd(4);
      correctedPairMass->SetStats(0);
      correctedPairMass->Draw();
      TLine *pi0MassValue4 = new TLine(0.134976, 0.0, 0.134976, correctedPairMass->GetMaximum());
      pi0MassValue4->SetLineColor(kMagenta);
      pi0MassValue4->Draw("same");
      (c1->cd(4))->SetGrid();
      
      c1->cd(2);
      uncorrectedPairMassLowPt->SetStats(0);
      uncorrectedPairMassLowPt->Draw();
      TLine *pi0MassValue2 = new TLine(0.134976, 0.0, 0.134976, uncorrectedPairMassLowPt->GetMaximum());
      pi0MassValue2->SetLineColor(kMagenta);
      pi0MassValue2->Draw("same");
      (c1->cd(2))->SetGrid();
      
      c1->cd(5);
      correctedPairMassLowPt->SetStats(0);
      correctedPairMassLowPt->Draw();
      TLine *pi0MassValue5 = new TLine(0.134976, 0.0, 0.134976, correctedPairMassLowPt->GetMaximum());
      pi0MassValue5->SetLineColor(kMagenta);
      pi0MassValue5->Draw("same");
      (c1->cd(5))->SetGrid();
      
      c1->cd(3);
      uncorrectedPairMassMidPt->SetStats(0);
      uncorrectedPairMassMidPt->Draw();
      TLine *pi0MassValue3 = new TLine(0.134976, 0.0, 0.134976, uncorrectedPairMassMidPt->GetMaximum());
      pi0MassValue3->SetLineColor(kMagenta);
      pi0MassValue3->Draw("same");
      (c1->cd(3))->SetGrid();
      
      c1->cd(6);
      correctedPairMassMidPt->SetStats(0);
      correctedPairMassMidPt->Draw();
      TLine *pi0MassValue6 = new TLine(0.134976, 0.0, 0.134976, correctedPairMassMidPt->GetMaximum());
      pi0MassValue6->SetLineColor(kMagenta);
      pi0MassValue6->Draw("same");
      (c1->cd(6))->SetGrid();
      
      
    } // option 21, generate pi0 mass spectrum from uncoverted primary photons
    
    if(iOption == 22 || iOption == -22) { // generate pi0 mass spectrum from all ECAL clusters (-22 ignores the clusters which have charged particle track matches)
			
      TH1D *uncorrectedPairMass = new TH1D("uncorrectedPairMass", "Di-photon Mass Before ECAL Energy Corrections (All ECAL Clusters)",
                                           200, 0.0, 0.80);
			
      TH1D *correctedPairMass = new TH1D("correctedPairMass", "Di-photon Mass After ECAL Energy Corrections (All ECAL Clusters)",
                                         200, 0.0, 0.80);
			
      TH1D *uncorrectedPairMassLowPt = new TH1D("uncorrectedPairMassLowPt", "Di-photon Mass 0.7<p_{T}<1.0 GeV/c Before Corrections (All ECAL Clusters)",
                                                200, 0.0, 0.80);
			
      TH1D *correctedPairMassLowPt = new TH1D("correctedPairMassLowPt", "Di-photon Mass 0.7<p_{T}<1.0 GeV/c After Corrections (All ECAL Clusters)",
                                              200, 0.0, 0.80);
			
      TH1D *uncorrectedPairMassMidPt = new TH1D("uncorrectedPairMassMidPt", "Di-photon Mass 1.0<p_{T}<1.5 GeV/c Before Corrections (All ECAL Clusters)",
                                                200, 0.0, 0.80);
			
      TH1D *correctedPairMassMidPt = new TH1D("correctedPairMassMidPt", "Di-photon Mass 1.0<p_{T}<1.5 GeV/c After Corrections (All ECAL Clusters)",
                                              200, 0.0, 0.80);
			
      if(iOption == -22) {
        uncorrectedPairMass->SetTitle("Di-photon Mass Before ECAL Energy Corrections (ECAL Clusters with no tracking match)");
        correctedPairMass->SetTitle("Di-photon Mass After ECAL Energy Corrections (ECAL Clusters with no tracking match)");
        uncorrectedPairMassLowPt->SetTitle("Di-photon Mass 0.7<p_{T}<1.0 GeV/c Before Corrections (ECAL Clusters with no tracking match)");
        correctedPairMassLowPt->SetTitle("Di-photon Mass 0.7<p_{T}<1.0 GeV/c After Corrections (ECAL Clusters with no tracking match)");
        uncorrectedPairMassMidPt->SetTitle("Di-photon Mass 1.0<p_{T}<1.5 GeV/c Before Corrections (ECAL Clusters with no tracking match)");
        correctedPairMassMidPt->SetTitle("Di-photon Mass 1.0<p_{T}<1.5 GeV/c After Corrections (ECAL Clusters with no tracking match)");
      }
			
      int maxArraySize = 0;
      
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
        const int ARRAYMAX = 2000;
        float ecalEnergyBefore[2000];
        float ecalEnergyAfter[2000];
        float ecalTheta[2000];
        float ecalPhi[2000];
        
        hTree->GetEntry(i);
        
        if(i%nEntries10 == 0 || i < 10) {
          cout << "\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
        }
				
        int kArray = 0;
        for(int jClu=0; jClu<nClu; jClu++) {
					
          if(iOption == -22 && nGoodRecoMatches[jClu] > 0)
            continue;  // skip clusters which have a match to a charged particle track
          
          if(useClusterCrystalLimit) {
            if(nCryClu[jClu] < lowCrystalLimit || nCryClu[jClu] > highCrystalLimit)
              continue;
          } // check on using crystal number limits
          int crystalIndex = nCryClu[jClu] - 1;
					
          float ecalEnergyUncorrected = S9Clu[jClu];
          if(ecalEnergyUncorrected > lowEnergyCutParameter && S4Clu[jClu]/ecalEnergyUncorrected > 0.80) {
						
            if(kArray < ARRAYMAX) {
              ecalPhi[kArray] = phiClu[jClu];
              float ecalEta = etaClu[jClu];
              ecalTheta[kArray] = 2.0*atan(exp(-ecalEta));
              ecalEnergyBefore[kArray] = ecalEnergyUncorrected;
							
              ecalEnergyAfter[kArray] =  crystalCorrectionFunction(crystalIndex, ecalEnergyUncorrected);
							
            }
            kArray++;
						
          }  // check for S9Clu above cut parameter
					
        } // loop on clusters
        
        if(kArray > maxArraySize)
          maxArraySize = kArray;
        
        if(kArray > 1) { // check for at least two clusters
          int kArrayMinusOne = kArray - 1;
					
          for(int jClu=0; jClu< kArrayMinusOne; jClu++) {
						
            float cosTheta1 = cos(ecalTheta[jClu]);
            float sinTheta1 = sin(ecalTheta[jClu]);
            float phi1 = ecalPhi[jClu];
            float cosphi1 = cos(phi1);
            float sinphi1 = sin(phi1);
            float uncorrectedEnergy1 = ecalEnergyBefore[jClu];
            float correctedEnergy1 = ecalEnergyAfter[jClu];
						
            float pt1Uncorrected = uncorrectedEnergy1*sinTheta1;
            float px1Uncorrected = pt1Uncorrected*cosphi1;
            float py1Uncorrected = pt1Uncorrected*sinphi1;
						
            float pt1Corrected = correctedEnergy1*sinTheta1;
            float px1Corrected = pt1Corrected*cosphi1;
            float py1Corrected = pt1Corrected*sinphi1;
            
            int jCluPlusOne = jClu + 1;
            
            for(int mClu=jCluPlusOne; mClu< kArray; mClu++) {
							
              float cosTheta2 = cos(ecalTheta[mClu]);
              float sinTheta2 = sin(ecalTheta[mClu]);
              float phi2 = ecalPhi[mClu];
              float cosphi2 = cos(phi2);
              float sinphi2 = sin(phi2);
              float uncorrectedEnergy2 = ecalEnergyBefore[mClu];
              float correctedEnergy2 = ecalEnergyAfter[mClu];
							
              float pt2Uncorrected = uncorrectedEnergy2*sinTheta2;
              float px2Uncorrected = pt2Uncorrected*cosphi2;
              float py2Uncorrected = pt2Uncorrected*sinphi2;
							
              float pt2Corrected = correctedEnergy2*sinTheta2;
              float px2Corrected = pt2Corrected*cosphi2;
              float py2Corrected = pt2Corrected*sinphi2;
							
              float pxUncorrected = px1Uncorrected + px2Uncorrected;
              float pyUncorrected = py1Uncorrected + py2Uncorrected;
              float ptUncorrected = sqrt(pxUncorrected*pxUncorrected + pyUncorrected*pyUncorrected);
							
              float pxCorrected = px1Corrected + px2Corrected;
              float pyCorrected = py1Corrected + py2Corrected;
              float ptCorrected = sqrt(pxCorrected*pxCorrected + pyCorrected*pyCorrected);
							
              float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
							
              float uncorrectedMassTest = 2.0*uncorrectedEnergy1*uncorrectedEnergy2*(1.0 - cosOpenAngle);
              if(uncorrectedMassTest > 0.0001) {
                uncorrectedPairMass->Fill(sqrt(uncorrectedMassTest));
                if(ptUncorrected > 0.7 && ptUncorrected < 1.0)
                  uncorrectedPairMassLowPt->Fill(sqrt(uncorrectedMassTest));
                if(ptUncorrected > 1.0 && ptUncorrected < 1.5)
                  uncorrectedPairMassMidPt->Fill(sqrt(uncorrectedMassTest));
              }
							
              float correctedMassTest = 2.0*correctedEnergy1*correctedEnergy2*(1.0 - cosOpenAngle);
              if(correctedMassTest > 0.0001) {
                correctedPairMass->Fill(sqrt(correctedMassTest));
								
                if(ptCorrected > 0.7 && ptCorrected < 1.0)
                  correctedPairMassLowPt->Fill(sqrt(correctedMassTest));
								
                if(ptCorrected > 1.0 && ptCorrected < 1.5)
                  correctedPairMassMidPt->Fill(sqrt(correctedMassTest));
								
              } // check on corrected mass > 0.0
              
            } // inner cluster loop
            
          } // outer cluster loop
          
        }  // check for at least two clusters
        
      } // loop on entries
      
      cout << "\n\n max array size = " << maxArraySize << endl << endl;
      
      c1->Divide(3,2);
      
      c1->cd(1);
      uncorrectedPairMass->SetStats(0);
      uncorrectedPairMass->Draw();
      
      TF1 *fitFcn1 = new TF1("fitFcn1",fitFunctionLinear, 0.07, 0.22, 5);
      cout << "\n\n Fitting with two parameter background function" << endl << endl;
      fitFcn1->SetParameters(150, 100., 1500., 0.13, 0.02);
      fitFcn1->SetParName(0, "Constant bgrnd");
      fitFcn1->SetParName(1, "Linear bgrnd");
      fitFcn1->SetParName(2, "Amplitude");
      fitFcn1->SetParName(3, "Centroid");
      fitFcn1->SetParName(4, "Sigma");
      fitFcn1->SetNpx(500);
      
      uncorrectedPairMass->Fit("fitFcn1", "", "", 0.07, 0.22);
      
      TF1 *peakFcn1 = new TF1("peakFcn1", gaussPeak, 0.08, 0.18, 3);
      peakFcn1->SetParameter(0, fitFcn1->GetParameter(2));
      peakFcn1->SetParameter(1, fitFcn1->GetParameter(3));
      peakFcn1->SetParameter(2, fitFcn1->GetParameter(4));
      
      TF1 *bgrndFcn1 = new TF1("bgrndFcn1", linearBackground, 0.07, 0.22, 2);
      bgrndFcn1->SetParameter(0, fitFcn1->GetParameter(0));
      bgrndFcn1->SetParameter(1, fitFcn1->GetParameter(1));
      
      peakFcn1->SetLineColor(2);
      peakFcn1->Draw("same");
      
      float lowMassLimit1 = fitFcn1->GetParameter(3) - 2.0*fabs(fitFcn1->GetParameter(4));
      float highMassLimit1 = fitFcn1->GetParameter(3) + 2.0*fabs(fitFcn1->GetParameter(4));
      float peakSum1 = 0.0;
      float bgrndSum1 = 0.0;
      float peakError1 = 0.0;
      
      for(int iBin=1; iBin<=200; iBin++) {
				
        float massValue = uncorrectedPairMass->GetBinCenter(iBin);
        if(massValue < lowMassLimit1)
          continue;
        if(massValue > highMassLimit1)
          break;
				
        float massContent = uncorrectedPairMass->GetBinContent(iBin);
        float bgrndValue = bgrndFcn1->Eval(massValue);
        peakSum1 += massContent - bgrndValue;
        peakError1 += massContent + bgrndValue;
        bgrndSum1 += bgrndValue;
				
      } // loop over mass bins
      cout << "\n For uncorrected allPt peak sum = " << peakSum1 << " +/- " << sqrt(peakError1);
      cout << ";  with background sum = " << bgrndSum1 << " +/- " << sqrt(bgrndSum1);
      cout << endl;
      
      char *peakLabel1 = new char[200];
      sprintf(peakLabel1, "Peak sum (#pm 3#sigma) = %d #pm %d", int(peakSum1), int(sqrt(peakError1)));
      TLatex *peakText1 = new TLatex(0.21, 0.28*uncorrectedPairMass->GetMaximum(), peakLabel1);
      peakText1->SetTextColor(2);
      peakText1->SetTextSize(0.04);
      peakText1->Draw();
      
      char *bgrndLabel1 = new char[200];
      sprintf(bgrndLabel1, "Bgrnd sum (#pm 3#sigma) = %d #pm %d", int(bgrndSum1), int(sqrt(bgrndSum1)));
      TLatex *bgrndText1 = new TLatex(0.21, 0.20*uncorrectedPairMass->GetMaximum(), bgrndLabel1);
      bgrndText1->SetTextColor(2);
      bgrndText1->SetTextSize(0.04);
      bgrndText1->Draw();
      
      TLine *pi0MassValue1 = new TLine(0.134976, 0.0, 0.134976, uncorrectedPairMass->GetMaximum());
      pi0MassValue1->SetLineColor(kMagenta);
      pi0MassValue1->Draw("same");
      
      (c1->cd(1))->SetGrid();
      
      c1->cd(4);
      correctedPairMass->SetStats(0);
      correctedPairMass->Draw();
      
      TF1 *fitFcn4 = new TF1("fitFcn4",fitFunctionLinear, 0.07, 0.22, 5);
      cout << "\n\n Fitting with two parameter background function" << endl << endl;
      fitFcn4->SetParameters(150, 100., 1500., 0.13, 0.02);
      fitFcn4->SetParName(0, "Constant bgrnd");
      fitFcn4->SetParName(1, "Linear bgrnd");
      fitFcn4->SetParName(2, "Amplitude");
      fitFcn4->SetParName(3, "Centroid");
      fitFcn4->SetParName(4, "Sigma");
      fitFcn4->SetNpx(500);
      
      correctedPairMass->Fit("fitFcn4", "", "", 0.07, 0.22);
      TLine *pi0MassValue4 = new TLine(0.134976, 0.0, 0.134976, correctedPairMass->GetMaximum());
      
      TF1 *peakFcn4 = new TF1("peakFcn4", gaussPeak, 0.08, 0.18, 3);
      peakFcn4->SetParameter(0, fitFcn4->GetParameter(2));
      peakFcn4->SetParameter(1, fitFcn4->GetParameter(3));
      peakFcn4->SetParameter(2, fitFcn4->GetParameter(4));
      
      peakFcn4->SetLineColor(2);
      peakFcn4->Draw("same");
      
      pi0MassValue4->SetLineColor(kMagenta);
      pi0MassValue4->Draw("same");
      
      TF1 *bgrndFcn4 = new TF1("bgrndFcn4", linearBackground, 0.07, 0.22, 2);
      bgrndFcn4->SetParameter(0, fitFcn4->GetParameter(0));
      bgrndFcn4->SetParameter(1, fitFcn4->GetParameter(1));
      
      pi0MassValue4->SetLineColor(kMagenta);
      pi0MassValue4->Draw("same");
      
      float lowMassLimit4 = fitFcn4->GetParameter(3) - 2.0*fabs(fitFcn4->GetParameter(4));
      float highMassLimit4 = fitFcn4->GetParameter(3) + 2.0*fabs(fitFcn4->GetParameter(4));
      float peakSum4 = 0.0;
      float bgrndSum4 = 0.0;
      float peakError4 = 0.0;
			
      for(int iBin=1; iBin<=200; iBin++) {
				
        float massValue = correctedPairMass->GetBinCenter(iBin);
        if(massValue < lowMassLimit4)
          continue;
        if(massValue > highMassLimit4)
          break;
				
        float massContent = correctedPairMass->GetBinContent(iBin);
        float bgrndValue = bgrndFcn4->Eval(massValue);
        peakSum4 += massContent - bgrndValue;
        peakError4 += massContent + bgrndValue;
        bgrndSum4 += bgrndValue;
				
      } // loop over mass bins
      cout << "\n For corrected allPt peak sum = " << peakSum4 << " +/- " << sqrt(peakError4);
      cout << ";  with background sum = " << bgrndSum4 << " +/- " << sqrt(bgrndSum4);
      cout << endl;
      
      char *peakLabel4 = new char[200];
      sprintf(peakLabel4, "Peak sum (#pm 3#sigma) = %d #pm %d", int(peakSum4), int(sqrt(peakError4)));
      TLatex *peakText4 = new TLatex(0.21, 0.28*correctedPairMass->GetMaximum(), peakLabel4);
      peakText4->SetTextColor(2);
      peakText4->SetTextSize(0.04);
      peakText4->Draw();
      
      char *bgrndLabel4 = new char[200];
      sprintf(bgrndLabel4, "Bgrnd sum (#pm 3#sigma) = %d #pm %d", int(bgrndSum4), int(sqrt(bgrndSum4)));
      TLatex *bgrndText4 = new TLatex(0.21, 0.20*correctedPairMass->GetMaximum(), bgrndLabel4);
      bgrndText4->SetTextColor(2);
      bgrndText4->SetTextSize(0.04);
      bgrndText4->Draw();
      
      (c1->cd(4))->SetGrid();
      
      c1->cd(2);
      uncorrectedPairMassLowPt->SetStats(0);
      uncorrectedPairMassLowPt->Draw();
      
      TF1 *fitFcn2 = new TF1("fitFcn2",fitFunctionLinear, 0.07, 0.22, 5);
      cout << "\n\n Fitting with two parameter background function" << endl << endl;
      fitFcn2->SetParameters(150, 100., 1500., 0.13, 0.02);
      fitFcn2->SetParName(0, "Constant bgrnd");
      fitFcn2->SetParName(1, "Linear bgrnd");
      fitFcn2->SetParName(2, "Amplitude");
      fitFcn2->SetParName(3, "Centroid");
      fitFcn2->SetParName(4, "Sigma");
      fitFcn2->SetNpx(500);
      
      uncorrectedPairMassLowPt->Fit("fitFcn2", "", "", 0.07, 0.22);
      
      TF1 *peakFcn2 = new TF1("peakFcn2", gaussPeak, 0.08, 0.18, 3);
      peakFcn2->SetParameter(0, fitFcn2->GetParameter(2));
      peakFcn2->SetParameter(1, fitFcn2->GetParameter(3));
      peakFcn2->SetParameter(2, fitFcn2->GetParameter(4));
      
      TF1 *bgrndFcn2 = new TF1("bgrndFcn2", linearBackground, 0.07, 0.22, 2);
      bgrndFcn2->SetParameter(0, fitFcn2->GetParameter(0));
      bgrndFcn2->SetParameter(1, fitFcn2->GetParameter(1));
      
      peakFcn2->SetLineColor(2);
      peakFcn2->Draw("same");
      
      float lowMassLimit2 = fitFcn2->GetParameter(3) - 2.0*fabs(fitFcn2->GetParameter(4));
      float highMassLimit2 = fitFcn2->GetParameter(3) + 2.0*fabs(fitFcn2->GetParameter(4));
      float peakSum2 = 0.0;
      float bgrndSum2 = 0.0;
      float peakError2 = 0.0;
      
      for(int iBin=1; iBin<=200; iBin++) {
				
        float massValue = uncorrectedPairMassLowPt->GetBinCenter(iBin);
        if(massValue < lowMassLimit2)
          continue;
        if(massValue > highMassLimit2)
          break;
				
        float massContent = uncorrectedPairMassLowPt->GetBinContent(iBin);
        float bgrndValue = bgrndFcn2->Eval(massValue);
        peakSum2 += massContent - bgrndValue;
        peakError2 += massContent + bgrndValue;
        bgrndSum2 += bgrndValue;
				
      } // loop over mass bins
      cout << "\n For uncorrected lowPt peak sum = " << peakSum2 << " +/- " << sqrt(peakError2);
      cout << ";  with background sum = " << bgrndSum2 << " +/- " << sqrt(bgrndSum2);
      cout << endl;
      
      char *peakLabel2 = new char[200];
      sprintf(peakLabel2, "Peak sum (#pm 3#sigma) = %d #pm %d", int(peakSum2), int(sqrt(peakError2)));
      TLatex *peakText2 = new TLatex(0.21, 0.28*uncorrectedPairMassLowPt->GetMaximum(), peakLabel2);
      peakText2->SetTextColor(2);
      peakText2->SetTextSize(0.04);
      peakText2->Draw();
      
      char *bgrndLabel2 = new char[200];
      sprintf(bgrndLabel2, "Bgrnd sum (#pm 3#sigma) = %d #pm %d", int(bgrndSum2), int(sqrt(bgrndSum2)));
      TLatex *bgrndText2 = new TLatex(0.21, 0.20*uncorrectedPairMassLowPt->GetMaximum(), bgrndLabel2);
      bgrndText2->SetTextColor(2);
      bgrndText2->SetTextSize(0.04);
      bgrndText2->Draw();
      
      TLine *pi0MassValue2 = new TLine(0.134976, 0.0, 0.134976, uncorrectedPairMassLowPt->GetMaximum());
      pi0MassValue2->SetLineColor(kMagenta);
      pi0MassValue2->Draw("same");
      (c1->cd(2))->SetGrid();
      
      c1->cd(5);
      correctedPairMassLowPt->SetStats(0);
      correctedPairMassLowPt->Draw();
      
      TF1 *fitFcn5 = new TF1("fitFcn5",fitFunctionLinear, 0.07, 0.22, 5);
      cout << "\n\n Fitting with two parameter background function" << endl << endl;
      fitFcn5->SetParameters(150, 100., 1500., 0.13, 0.02);
      fitFcn5->SetParName(0, "Constant bgrnd");
      fitFcn5->SetParName(1, "Linear bgrnd");
      fitFcn5->SetParName(2, "Amplitude");
      fitFcn5->SetParName(3, "Centroid");
      fitFcn5->SetParName(4, "Sigma");
      fitFcn5->SetNpx(500);
      
      correctedPairMassLowPt->Fit("fitFcn5", "", "", 0.07, 0.22);
      TLine *pi0MassValue5 = new TLine(0.134976, 0.0, 0.134976, correctedPairMassLowPt->GetMaximum());
      
      TF1 *peakFcn5 = new TF1("peakFcn5", gaussPeak, 0.08, 0.18, 3);
      peakFcn5->SetParameter(0, fitFcn5->GetParameter(2));
      peakFcn5->SetParameter(1, fitFcn5->GetParameter(3));
      peakFcn5->SetParameter(2, fitFcn5->GetParameter(4));
      
      peakFcn5->SetLineColor(2);
      peakFcn5->Draw("same");
      
      pi0MassValue5->SetLineColor(kMagenta);
      pi0MassValue5->Draw("same");
      
      TF1 *bgrndFcn5 = new TF1("bgrndFcn5", linearBackground, 0.07, 0.22, 2);
      bgrndFcn5->SetParameter(0, fitFcn5->GetParameter(0));
      bgrndFcn5->SetParameter(1, fitFcn5->GetParameter(1));
      
      float lowMassLimit5 = fitFcn5->GetParameter(3) - 2.0*fabs(fitFcn5->GetParameter(4));
      float highMassLimit5 = fitFcn5->GetParameter(3) + 2.0*fabs(fitFcn5->GetParameter(4));
      float peakSum5 = 0.0;
      float bgrndSum5 = 0.0;
      float peakError5 = 0.0;
			
      for(int iBin=1; iBin<=200; iBin++) {
				
        float massValue = correctedPairMassLowPt->GetBinCenter(iBin);
        if(massValue < lowMassLimit5)
          continue;
        if(massValue > highMassLimit5)
          break;
				
        float massContent = correctedPairMassLowPt->GetBinContent(iBin);
        float bgrndValue = bgrndFcn5->Eval(massValue);
        peakSum5 += massContent - bgrndValue;
        peakError5 += massContent + bgrndValue;
        bgrndSum5 += bgrndValue;
				
      } // loop over mass bins
      
      cout << "\n For corrected lowPt peak sum = " << peakSum5 << " +/- " << sqrt(peakError5);
      cout << ";  with background sum = " << bgrndSum5 << " +/- " << sqrt(bgrndSum5);
      cout << endl;
      
      char *peakLabel5 = new char[200];
      sprintf(peakLabel5, "Peak sum (#pm 3#sigma) = %d #pm %d", int(peakSum5), int(sqrt(peakError5)));
      TLatex *peakText5 = new TLatex(0.21, 0.28*correctedPairMassLowPt->GetMaximum(), peakLabel5);
      peakText5->SetTextColor(2);
      peakText5->SetTextSize(0.04);
      peakText5->Draw();
      
      char *bgrndLabel5 = new char[200];
      sprintf(bgrndLabel5, "Bgrnd sum (#pm 3#sigma) = %d #pm %d", int(bgrndSum5), int(sqrt(bgrndSum5)));
      TLatex *bgrndText5 = new TLatex(0.21, 0.20*correctedPairMassLowPt->GetMaximum(), bgrndLabel5);
      bgrndText5->SetTextColor(2);
      bgrndText5->SetTextSize(0.04);
      bgrndText5->Draw();
      
      (c1->cd(5))->SetGrid();
      
      c1->cd(3);
      uncorrectedPairMassMidPt->SetStats(0);
      uncorrectedPairMassMidPt->Draw();
      TLine *pi0MassValue3 = new TLine(0.134976, 0.0, 0.134976, uncorrectedPairMassMidPt->GetMaximum());
      
      TF1 *fitFcn3 = new TF1("fitFcn3",fitFunctionLinear, 0.07, 0.22, 5);
      cout << "\n\n Fitting with two parameter background function" << endl << endl;
      fitFcn3->SetParameters(150, 100., 1500., 0.13, 0.02);
      fitFcn3->SetParName(0, "Constant bgrnd");
      fitFcn3->SetParName(1, "Linear bgrnd");
      fitFcn3->SetParName(2, "Amplitude");
      fitFcn3->SetParName(3, "Centroid");
      fitFcn3->SetParName(4, "Sigma");
      fitFcn3->SetNpx(500);
      
      uncorrectedPairMassMidPt->Fit("fitFcn3", "", "", 0.07, 0.22);
      
      TF1 *peakFcn3 = new TF1("peakFcn3", gaussPeak, 0.08, 0.18, 3);
      peakFcn3->SetParameter(0, fitFcn3->GetParameter(2));
      peakFcn3->SetParameter(1, fitFcn3->GetParameter(3));
      peakFcn3->SetParameter(2, fitFcn3->GetParameter(4));
      
      TF1 *bgrndFcn3 = new TF1("bgrndFcn3", linearBackground, 0.07, 0.22, 2);
      bgrndFcn3->SetParameter(0, fitFcn3->GetParameter(0));
      bgrndFcn3->SetParameter(1, fitFcn3->GetParameter(1));
      
      peakFcn3->SetLineColor(2);
      peakFcn3->Draw("same");
      
      float lowMassLimit3 = fitFcn3->GetParameter(3) - 2.0*fabs(fitFcn3->GetParameter(4));
      float highMassLimit3 = fitFcn3->GetParameter(3) + 2.0*fabs(fitFcn3->GetParameter(4));
      float peakSum3 = 0.0;
      float bgrndSum3 = 0.0;
      float peakError3 = 0.0;
			
      for(int iBin=1; iBin<=200; iBin++) {
				
        float massValue = uncorrectedPairMassMidPt->GetBinCenter(iBin);
        if(massValue < lowMassLimit3)
          continue;
        if(massValue > highMassLimit3)
          break;
				
        float massContent = uncorrectedPairMassMidPt->GetBinContent(iBin);
        float bgrndValue = bgrndFcn3->Eval(massValue);
        peakSum3 += massContent - bgrndValue;
        peakError3 += massContent + bgrndValue;
        bgrndSum3 += bgrndValue;
				
      } // loop over mass bins
      cout << "\n For uncorrected midPt peak sum = " << peakSum3 << " +/- " << sqrt(peakError3);
      cout << ";  with background sum = " << bgrndSum3 << " +/- " << sqrt(bgrndSum3);
      cout << endl;
      
      char *peakLabel3 = new char[200];
      sprintf(peakLabel3, "Peak sum (#pm 3#sigma) = %d #pm %d", int(peakSum3), int(sqrt(peakError3)));
      TLatex *peakText3 = new TLatex(0.21, 0.28*uncorrectedPairMassMidPt->GetMaximum(), peakLabel3);
      peakText3->SetTextColor(2);
      peakText3->SetTextSize(0.04);
      peakText3->Draw();
      
      char *bgrndLabel3 = new char[200];
      sprintf(bgrndLabel3, "Bgrnd sum (#pm 3#sigma) = %d #pm %d", int(bgrndSum3), int(sqrt(bgrndSum3)));
      TLatex *bgrndText3 = new TLatex(0.21, 0.20*uncorrectedPairMassMidPt->GetMaximum(), bgrndLabel3);
      bgrndText3->SetTextColor(2);
      bgrndText3->SetTextSize(0.04);
      bgrndText3->Draw();
      
      pi0MassValue3->SetLineColor(kMagenta);
      pi0MassValue3->Draw("same");
      (c1->cd(3))->SetGrid();
      
      c1->cd(6);
      correctedPairMassMidPt->SetStats(0);
      correctedPairMassMidPt->Draw();
      
      TF1 *fitFcn6 = new TF1("fitFcn6",fitFunctionLinear, 0.07, 0.22, 5);
      cout << "\n\n Fitting with two parameter background function" << endl << endl;
      fitFcn6->SetParameters(50, 100., 100., 0.13, 0.02);
      fitFcn6->SetParName(0, "Constant bgrnd");
      fitFcn6->SetParName(1, "Linear bgrnd");
      fitFcn6->SetParName(2, "Amplitude");
      fitFcn6->SetParName(3, "Centroid");
      fitFcn6->SetParName(4, "Sigma");
      fitFcn6->SetNpx(500);
      
      correctedPairMassMidPt->Fit("fitFcn6", "", "", 0.07, 0.22);
      TLine *pi0MassValue6 = new TLine(0.134976, 0.0, 0.134976, correctedPairMassMidPt->GetMaximum());
      
      TF1 *peakFcn6 = new TF1("peakFcn6", gaussPeak, 0.08, 0.18, 3);
      peakFcn6->SetParameter(0, fitFcn6->GetParameter(2));
      peakFcn6->SetParameter(1, fitFcn6->GetParameter(3));
      peakFcn6->SetParameter(2, fitFcn6->GetParameter(4));
      
      TF1 *bgrndFcn6 = new TF1("bgrndFcn6", linearBackground, 0.07, 0.22, 2);
      bgrndFcn6->SetParameter(0, fitFcn6->GetParameter(0));
      bgrndFcn6->SetParameter(1, fitFcn6->GetParameter(1));
      
      peakFcn6->SetLineColor(2);
      peakFcn6->Draw("same");
      
      pi0MassValue6->SetLineColor(kMagenta);
      pi0MassValue6->Draw("same");
      
      float lowMassLimit6 = fitFcn6->GetParameter(3) - 2.0*fabs(fitFcn6->GetParameter(4));
      float highMassLimit6 = fitFcn6->GetParameter(3) + 2.0*fabs(fitFcn6->GetParameter(4));
      float peakSum6 = 0.0;
      float bgrndSum6 = 0.0;
      float peakError6 = 0.0;
			
      for(int iBin=1; iBin<=200; iBin++) {
				
        float massValue = correctedPairMassMidPt->GetBinCenter(iBin);
        if(massValue < lowMassLimit6)
          continue;
        if(massValue > highMassLimit6)
          break;
				
        float massContent = correctedPairMassMidPt->GetBinContent(iBin);
        float bgrndValue = bgrndFcn6->Eval(massValue);
        peakSum6 += massContent - bgrndValue;
        peakError6 += massContent + bgrndValue;
        bgrndSum6 += bgrndValue;
				
      } // loop over mass bins
      cout << "\n For corrected midPt peak sum = " << peakSum6 << " +/- " << sqrt(peakError6);
      cout << ";  with background sum = " << bgrndSum6 << " +/- " << sqrt(bgrndSum6);
      cout << endl;
      
      char *peakLabel6 = new char[200];
      sprintf(peakLabel6, "Peak sum (#pm 3#sigma) = %d #pm %d", int(peakSum6), int(sqrt(peakError6)));
      TLatex *peakText6 = new TLatex(0.21, 0.28*correctedPairMassMidPt->GetMaximum(), peakLabel6);
      peakText6->SetTextColor(2);
      peakText6->SetTextSize(0.04);
      peakText6->Draw();
      
      char *bgrndLabel6 = new char[200];
      sprintf(bgrndLabel6, "Bgrnd sum (#pm 3#sigma) = %d #pm %d", int(bgrndSum6), int(sqrt(bgrndSum6)));
      TLatex *bgrndText6 = new TLatex(0.21, 0.20*correctedPairMassMidPt->GetMaximum(), bgrndLabel6);
      bgrndText6->SetTextColor(2);
      bgrndText6->SetTextSize(0.04);
      bgrndText6->Draw();
      
      (c1->cd(6))->SetGrid();
      
    } // option 22, generate pi0 mass spectrum from all ECAL clusters
    
    if(iOption == 23 || iOption == -23 || iOption == 24 || iOption == -24 ||  // Look at 2-dimensional yields of the pi0, as a function of pT and psuedorapidity (23, 4 panels); 1-dimension (24)
       iOption == 25 || iOption == -25 || iOption == 26 || iOption == -26 ||  // add eta-548 MeV meson choice
       iOption == 231 || iOption == -231 ||   // Look at 2-dimensional yields of the pi0, as a function of pT and psuedorapidity in 1 panel    
       iOption == 232 || iOption == -232 ||   // Look at 2-dimensional yields of the pi0, as a function of pT and psuedorapidity in 2 panels
       iOption == 233 || // look at the reconstructed eta in four low pT bins
       iOption == 234 || iOption == 235 || iOption == 236 || iOption == 237) { // MC pairs correlations in delta-Eta and delta-Phi
      
      if(!mesonStore) {
        cerr << "\n\n Cannot use option 23 or option 24 or option 25 or option 26 or option = 231 or option = -231 or option = 232 or option = -232 since the mesonStore is set to false" << endl << endl;
        return;
      }
      
      int nBinsOneDimension = 100;
 
      Float_t etabinsy[11]  = { -1.5, -1.2, -0.9, -0.6, -0.3, 0, 0.3, 0.6, 0.9, 1.2, 1.5};
      Float_t ptbinsx[16]  = { 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.4, 2.8, 3.2, 4.0, 5.0}; 

      TH2D *generatorPi0Yields = new TH2D("generatorPi0Yields", "Generator #pi^{0} Yields(p_{T}, #eta)", 15, ptbinsx, 10, etabinsy);
      
      generatorPi0Yields->SetXTitle("p_{T} (GeV/c)");
      generatorPi0Yields->SetYTitle("#eta ");
      
      (generatorPi0Yields->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0Yields->GetXaxis())->SetTitleOffset(1.6);
      (generatorPi0Yields->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0Yields->GetXaxis())->CenterTitle();
      (generatorPi0Yields->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0Yields->GetYaxis())->SetTitleOffset(1.5);
      (generatorPi0Yields->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0Yields->GetYaxis())->CenterTitle();
      
      TH2D *reconstructedPi0Yields = new TH2D("reconstructedPi0Yields", "Reconstructed #pi^{0} Yields(p_{T}, #eta)", 15, ptbinsx, 10, etabinsy);
      
      reconstructedPi0Yields->SetXTitle("p_{T} (GeV/c)");
      reconstructedPi0Yields->SetYTitle("#eta");
      
      (reconstructedPi0Yields->GetXaxis())->SetLabelSize(0.045);
      (reconstructedPi0Yields->GetXaxis())->SetTitleOffset(1.6);
      (reconstructedPi0Yields->GetXaxis())->SetTitleSize(0.045);
      (reconstructedPi0Yields->GetXaxis())->CenterTitle();
      (reconstructedPi0Yields->GetYaxis())->SetLabelSize(0.045);
      (reconstructedPi0Yields->GetYaxis())->SetTitleOffset(1.6);
      (reconstructedPi0Yields->GetYaxis())->SetTitleSize(0.045);
      (reconstructedPi0Yields->GetYaxis())->CenterTitle();
      
      TH2D *efficiencyPi0Yields = new TH2D("efficiencyPi0Yields", "Efficiency(p_{T}, #eta) for #pi^{0} Reconstruction", 15, ptbinsx, 10, etabinsy);
      efficiencyPi0Yields->SetXTitle("p_{T} (GeV/c)");
      efficiencyPi0Yields->SetYTitle("#eta");
      
      (efficiencyPi0Yields->GetXaxis())->SetLabelSize(0.045);
      (efficiencyPi0Yields->GetXaxis())->SetTitleOffset(1.6);
      (efficiencyPi0Yields->GetXaxis())->SetTitleSize(0.045);
      (efficiencyPi0Yields->GetXaxis())->CenterTitle();
      (efficiencyPi0Yields->GetYaxis())->SetLabelSize(0.045);
      (efficiencyPi0Yields->GetYaxis())->SetTitleOffset(1.6);
      (efficiencyPi0Yields->GetYaxis())->SetTitleSize(0.045);
      (efficiencyPi0Yields->GetYaxis())->CenterTitle();
      
      TH1D *recoMass = new TH1D("recoMass", "Reconstructed mass #pi^{0}", 200, 0.0, 0.80);
      recoMass->SetXTitle("Invariant diphoton mass (GeV/c^{2})");;
      recoMass->SetYTitle("Counts per 4 MeV/c^{2} bin");
      
      (recoMass->GetXaxis())->SetLabelSize(0.045);
      (recoMass->GetXaxis())->SetTitleOffset(1.);
      (recoMass->GetXaxis())->SetTitleSize(0.045);
      (recoMass->GetXaxis())->CenterTitle();
      (recoMass->GetYaxis())->SetLabelSize(0.045);
      (recoMass->GetYaxis())->SetTitleOffset(1.2);
      (recoMass->GetYaxis())->SetTitleSize(0.045);
      (recoMass->GetYaxis())->CenterTitle();
      
      TH1D *generatorPi0YieldsPt = new TH1D("generatorPi0YieldsPt", "Generator #pi^{0} Yields(p_{T})", nBinsOneDimension, 0.5, 5.0);
      generatorPi0YieldsPt->SetXTitle("p_{T} (GeV/c)");
      generatorPi0YieldsPt->SetYTitle("Counts");
      
      (generatorPi0YieldsPt->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPt->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0YieldsPt->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPt->GetXaxis())->CenterTitle();
      (generatorPi0YieldsPt->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPt->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0YieldsPt->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPt->GetYaxis())->CenterTitle();
      
      TH1D *generatorPi0YieldsEta = new TH1D("generatorPi0YieldsEta", "Generator #pi^{0} Yields(#eta)", nBinsOneDimension, -1.5, 1.5);
      generatorPi0YieldsEta->SetXTitle("#eta");
      generatorPi0YieldsEta->SetYTitle("Counts");
      
      (generatorPi0YieldsEta->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsEta->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0YieldsEta->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsEta->GetXaxis())->CenterTitle();
      (generatorPi0YieldsEta->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsEta->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0YieldsEta->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsEta->GetYaxis())->CenterTitle();
      
      TH1D *reconstructedPi0YieldsPt = new TH1D("reconstructedPi0YieldsPt", "reconstructed #pi^{0} Yields(p_{T})", nBinsOneDimension, 0.5, 5.0);
      reconstructedPi0YieldsPt->SetXTitle("p_{T} (GeV/c)");
      reconstructedPi0YieldsPt->SetYTitle("Counts");
      
      TH1D *reconstructedPi0YieldsEta = new TH1D("reconstructedPi0YieldsEta", "reconstructed #pi^{0} Yields(#eta)", nBinsOneDimension, -1.5, 1.5);
      reconstructedPi0YieldsEta->SetXTitle("#eta)");
      reconstructedPi0YieldsEta->SetYTitle("Counts");
      
      TH1D *efficiencyPi0YieldsPt = new TH1D("efficiencyPi0YieldsPt", " #pi^{0} efficiency(p_{T})", nBinsOneDimension, 0.5, 5.0);
      efficiencyPi0YieldsPt->SetXTitle("p_{T} (GeV/c)");
      efficiencyPi0YieldsPt->SetYTitle("Efficiency (Reco/Gen)");
      
      TH1D *efficiencyPi0YieldsEta = new TH1D("efficiencyPi0YieldsEta", " #pi^{0} efficiency(#eta)", nBinsOneDimension, -1.5, 1.5);
      efficiencyPi0YieldsEta->SetXTitle("#eta");
      efficiencyPi0YieldsEta->SetYTitle("Efficiency (Reco/Gen)");
      
      (efficiencyPi0YieldsPt->GetXaxis())->SetLabelSize(0.045);
      (efficiencyPi0YieldsPt->GetXaxis())->SetTitleOffset(1.);
      (efficiencyPi0YieldsPt->GetXaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsPt->GetXaxis())->CenterTitle();
      (efficiencyPi0YieldsPt->GetYaxis())->SetLabelSize(0.040);
      (efficiencyPi0YieldsPt->GetYaxis())->SetTitleOffset(1.1);
      (efficiencyPi0YieldsPt->GetYaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsPt->GetYaxis())->CenterTitle();
      
      (efficiencyPi0YieldsEta->GetXaxis())->SetLabelSize(0.045);
      (efficiencyPi0YieldsEta->GetXaxis())->SetTitleOffset(1.);
      (efficiencyPi0YieldsEta->GetXaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsEta->GetXaxis())->CenterTitle();
      (efficiencyPi0YieldsEta->GetYaxis())->SetLabelSize(0.040);
      (efficiencyPi0YieldsEta->GetYaxis())->SetTitleOffset(1.1);
      (efficiencyPi0YieldsEta->GetYaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsEta->GetYaxis())->CenterTitle();

      const int nPtBins = 4;
      const float lowPtBinLimit[4] =  {0.7, 1.0, 1.5, 2.0};
      const float highPtBinLimit[4] = {1.0, 1.5, 2.0, 2.5};

      char *histogramName = new char[200];
      char *histogramTitle = new char[200];

      TH2D *hGenSignalPtBin[8];          // generator foreground
      TH2D *hGenBackgroundPtBin[8];      // generator mixed-event

      for(int kPt=0; kPt<nPtBinsComplete; kPt++) {

	sprintf(histogramName, "hGenSignalPtBin%d", kPt);
	if(simRun) {
	  sprintf(histogramTitle, "MC: Same-event #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f ", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);
	}
	if(!simRun) {
	  sprintf(histogramTitle, "pPb Data: Same-event #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f ", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);
	}
	hGenSignalPtBin[kPt] = new TH2D(histogramName, histogramTitle, 32+1,-5.0-0.15, 5.0+0.15, 32-1,-TMath::Pi()/2+TMath::Pi()/32, 3*TMath::Pi()/2-TMath::Pi()/32);

	hGenSignalPtBin[kPt]->SetStats(0);
        hGenSignalPtBin[kPt]->SetLineColor(1);
        hGenSignalPtBin[kPt]->SetXTitle("#Delta#eta");
        hGenSignalPtBin[kPt]->SetYTitle("#Delta#phi");
        (hGenSignalPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
        (hGenSignalPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
        (hGenSignalPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
        (hGenSignalPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
        (hGenSignalPtBin[kPt]->GetXaxis())->CenterTitle();
        (hGenSignalPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
        (hGenSignalPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
        (hGenSignalPtBin[kPt]->GetYaxis())->CenterTitle();

	sprintf(histogramName, "hGenBackgroundPtBin%d", kPt);
	sprintf(histogramTitle, "MC: Mixed-event #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f ", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);
	hGenBackgroundPtBin[kPt] = new TH2D(histogramName, histogramTitle, 32+1,-5.0-0.15, 5.0+0.15, 32-1,-TMath::Pi()/2+TMath::Pi()/32, 3*TMath::Pi()/2-TMath::Pi()/32);
	hGenBackgroundPtBin[kPt]->SetStats(0);
        hGenBackgroundPtBin[kPt]->SetLineColor(1);
        hGenBackgroundPtBin[kPt]->SetXTitle("#Delta#eta");
        hGenBackgroundPtBin[kPt]->SetYTitle("#Delta#phi");
        (hGenBackgroundPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
        (hGenBackgroundPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
        (hGenBackgroundPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
        (hGenBackgroundPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
        (hGenBackgroundPtBin[kPt]->GetXaxis())->CenterTitle();
        (hGenBackgroundPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
        (hGenBackgroundPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
        (hGenBackgroundPtBin[kPt]->GetYaxis())->CenterTitle();

      } // loop over 8 pt bins

      TH1D *recoEtaHistogramsPtBin[4];
      for(int kPt=0; kPt<nPtBins; kPt++) {
	sprintf(histogramName, "recoEtaHistogramPtBin%d", kPt);
	sprintf(histogramTitle, "GEN-Matched RECO: #eta(#pi^{0}) for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
        recoEtaHistogramsPtBin[kPt] = new TH1D(histogramName, histogramTitle, 100, -1.5, 1.5);

	recoEtaHistogramsPtBin[kPt]->SetStats(0);
        recoEtaHistogramsPtBin[kPt]->SetLineColor(1);
        recoEtaHistogramsPtBin[kPt]->SetXTitle("#eta");
        recoEtaHistogramsPtBin[kPt]->SetYTitle("Counts per 0.03 #eta bin");
        (recoEtaHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
        (recoEtaHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
        (recoEtaHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
        (recoEtaHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
        (recoEtaHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
        (recoEtaHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
        (recoEtaHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
        (recoEtaHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();
      }      

      bool allowConversions = true;
      if(iOption == -23 || iOption == -24 || iOption == -25 || iOption == -26 || iOption == -231 || iOption == -232) {
        allowConversions = false;
				
        generatorPi0Yields->SetTitle("Generator #pi^{0} Yields(#eta, p_{T}), Decay Photons Do Not Convert");
        reconstructedPi0Yields->SetTitle("Reconstructed #pi^{0} Yields(#eta, p_{T}), Decay Photons Did Not Convert");
        efficiencyPi0Yields->SetTitle("Efficiency(#eta, p_{T}) for #pi^{0} Reconstruction, Decay Photons Did Not Convert");
        generatorPi0YieldsPt->SetTitle("Generator #pi^{0} Yields(p_{T}), NO photon conversions");
        generatorPi0YieldsEta->SetTitle("Generator #pi^{0} Yields(#eta), NO photon conversions");
        efficiencyPi0YieldsPt->SetTitle("#pi^{0} efficiency(p_{T}), NO photon conversions");
        efficiencyPi0YieldsEta->SetTitle("#pi^{0} efficiency(#eta), NO photon conversions");
      }
			
      if(iOption == 25 || iOption == 26) {
        recoMass->SetTitle("Reconstructed mass #eta(547.5 MeV)");
        generatorPi0Yields->SetTitle("Generator #eta(547.5 MeV) Yields(#eta, p_{T}), Decay Photons May Convert");
        reconstructedPi0Yields->SetTitle("Reconstructed #eta(547.5 MeV) Yields(#eta, p_{T}), Decay Photons May Convert");
        efficiencyPi0Yields->SetTitle("Efficiency(#eta, p_{T}) for #eta(547.5 MeV) Reconstruction, Decay Photons May Convert");
        generatorPi0YieldsPt->SetTitle("Generator #eta(547.5 MeV) Yields(p_{T}), All ECAL clusters");
        generatorPi0YieldsEta->SetTitle("Generator #eta(547.5 MeV) Yields(#eta), All ECAL clusters");
        efficiencyPi0YieldsPt->SetTitle("#eta(547.5 MeV) efficiency(p_{T}), All ECAL clusters");
        efficiencyPi0YieldsEta->SetTitle("#eta(547.5 MeV) efficiency(#eta), All ECAL clusters");
      }
			
      if(iOption == -25 || iOption == -26) {
        recoMass->SetTitle("Reconstructed mass #eta(547.5 MeV)");
        generatorPi0Yields->SetTitle("Generator #eta(547.5 MeV) Yields(#eta, p_{T}), Decay Photons Do NOT Convert");
        reconstructedPi0Yields->SetTitle("Reconstructed #eta(547.5 MeV) Yields(#eta, p_{T}), Decay Photons Do NOT Convert");
        efficiencyPi0Yields->SetTitle("Efficiency(#eta, p_{T}) for #eta(547.5 MeV) Reconstruction, Decay Photons Do NOT Convert");
        generatorPi0YieldsPt->SetTitle("Generator #eta(547.5 MeV) Yields(p_{T}), NO photon conversions");
        generatorPi0YieldsEta->SetTitle("Generator #eta(547.5 MeV) Yields(#eta), NO photon conversions");
        efficiencyPi0YieldsPt->SetTitle("#eta(547.5 MeV) efficiency(p_{T}), NO photon conversions");
        efficiencyPi0YieldsEta->SetTitle("#eta(547.5 MeV) efficiency(#eta), NO photon conversions");
      }
			
      int countSkippedConversions = 0;
      int countPrimaryMesons = 0;
      int countRecoMesons = 0;
      float averageRecoMass = 0;
			
      int pdgIdMesonChoice = 111;   // default for pi0
      float massCentroid = 0.134;
      float massWindow = 0.060;
      if(iOption == 25 || iOption == -25 || iOption == 26 || iOption == -26) {
        pdgIdMesonChoice = 221;      // add eta-548 MeV meson choice
        massCentroid = 0.54751;
        massWindow = 0.150;
      }
			
      int countTestPrint = 0;
      int countSuppressedMatches = 0;
      int countMissingMerge = 0;
      int countMissingAngleMatch = 0;
      int countLowEnergySkipped = 0;
      int countSkippedDecays = 0;
      int countOutOfRangeCrystal = 0;

      bool thisMesonConverted[5000];
      bool thisMesonAccepted[5000];

      const int MAXBACKGROUNDSIZE = 2000;
      float etaThisEvent[2000];
      float phiThisEvent[2000];

      int nLast_ass = 0;
      int nBuffersFilled = 0;
      int currentBufferIndex = 0;
      int nLastBuffer[10];
      float etaLastEvent[2000][NBUFFERDEPTH];
      float phiLastEvent[2000][NBUFFERDEPTH];

      int nEventsTotal = 0;
      int nTrgTotal = 0;

      //
      // Interpolation constants for pi0 efficiency when  useClusterCrystalLimitLowPtOnly  is true
      //
      const float ptFirst = 0.85;
      const float fFirst = 22645./74733. ;  // ratio of single crystal to three crystal same parent yields in 0.7-1.0 GeV/C bin
      const float ptSecond = 1.25;
      const float fSecond = 23555./118053. ;  // ratio of single crystal to three crystal same parent yields in 1.0-1.5 GeV/c bin
      const float lowPtEfficiencyInterpolation = (fSecond - fFirst)/(ptSecond - ptFirst);

      for (Long64_t i=0; i<entriesToProcess; i++) {
				
        hTree->GetEntry(i);
	//
	// Check array sizes
	//
	if(nCry > CRYARRAY) {
	  cerr << "\n nCry is too large " << nCry << ", beyond limit " << CRYARRAY << endl;
	  return;
	}
	if(nClu > CLUARRAY) {
	  cerr << "\n nClu is too large " << nClu << ", beyond limit " << CLUARRAY << endl;
	  return;
	}
	if(nPairTracksSize > PAIRTRACKARRAY) {
	  cerr << "\n nPairTracksSize is too large " << nPairTracksSize << ", beyond limit " << PAIRTRACKARRAY << endl;
	  return;
	}
	if(nHITracks > RECOTRACKARRAY) {
	  cerr << "\n nHITracks is too large " << nHITracks << ", beyond limit " << RECOTRACKARRAY << endl;
	  return;
	}
	if(nMC > MCARRAY) {
	  cerr << "\n nMC is too large " << nMC << ", beyond limit " << MCARRAY << endl;
	  return;
	}
	if(mergedTrackTruthSize > MERGETRUTHARRAY) {
	  cerr << "\n mergedTrackTruth is too large " << mergedTrackTruthSize << ", beyond limit " << MERGETRUTHARRAY << endl;
	  return;
	}
	if(nChMesonSize > CHMESONARRAY) {
	  cerr << "\n nChMesonSize is too large " << nChMesonSize << ", beyond limit " << CHMESONARRAY << endl;
	  return;
	}
	if(nMesonSize > MESONARRAY) {
	  cerr << "\n nMesonSize is too large " << nMesonSize << ", beyond limit " << MESONARRAY << endl;
	  return;
	}
	if(nSimTracks > SIMTRACKARRAY) {
	  cerr << "\n nSimTracks is too large " << nSimTracks << ", beyond limit " << SIMTRACKARRAY << endl;
	  return;
	}
	if(nPhotonSize > PHOTONGENARRAY) {
	  cerr << "\n nPhotonSize is too large " << nPhotonSize << ", beyond limit " << PHOTONGENARRAY << endl;
	  return;
	}
				
        if(i%nEntries10 == 0 || i < 10) {
          cout << "\n The entry " << i << " with event " << Event << " and nMesonSize = " << nMesonSize;
        }

	nEventsTotal++;
	int nMult_ass = 0;
	int nMult_trg = 0;

	float fillFactor = 0.0;
	if(iOption >= 234 && iOption <= 237) {
	  //
	  // Getting the event trigger multiplicity count
	  //
	  for(int jMeson=0; jMeson< nMesonSize; jMeson++) {

	    int thisPdgId = pdgIdMeson[jMeson];
            thisMesonAccepted[jMeson] = true;
            if(thisPdgId != 111)
              thisMesonAccepted[jMeson] = false;

	    if(checkRecoMass) {
	      if(massRecoMeson[jMeson] < lowLimitPi0Mass || massRecoMeson[jMeson] > highLimitPi0Mass)
		thisMesonAccepted[jMeson] = false;	
	    }

	    if(checkDecayEnergy) {
	      if(daughtersFromMeson[jMeson] != 2) {
		 thisMesonAccepted[jMeson] = false;
	      }
	      else {
		float decay1Theta = 2.0*atan(exp(-etaDecay1Meson[jMeson]));
		float decay1Energy = ptDecay1Meson[jMeson]/sin(decay1Theta);
		float decay2Theta = 2.0*atan(exp(-etaDecay2Meson[jMeson]));
		float decay2Energy = ptDecay2Meson[jMeson]/sin(decay2Theta);
		if(decay1Energy < lowEnergyCutParameter || decay2Energy < lowEnergyCutParameter)
		  thisMesonAccepted[jMeson] = false;
	      }
	    }

	    thisMesonConverted[jMeson] = false;

	    float etaThisMeson = etaMeson[jMeson];
	    if(useRecoEta)
	      etaThisMeson = etaRecoMeson[jMeson];

	    float ptThisMeson = ptMeson[jMeson];
	    if(useRecoPt)
	      ptThisMeson = ptRecoMeson[jMeson];

	    if(fabs(etaThisMeson) >= etaLowLimit && ptThisMeson > 0.700 && ptThisMeson < 5.0) {

	      if(useConversionSuppression && (convertDecay1Meson[jMeson] > 0 || convertDecay2Meson[jMeson] > 0)) {
		if(randomValue->Rndm() < conversionSuppressionFraction) {
		  thisMesonConverted[jMeson] = true;
		} // check on meson conversion fraction
	      } // checking for any conversion

              if(usePi0EfficiencyTable) {
                //
                // should do a first order, bi-linear interpolation
                //
                float efficiency = efficiencyPi0YieldsRead->GetBinContent(efficiencyPi0YieldsRead->FindBin(ptMeson[jMeson], etaMeson[jMeson]));
                 if(randomValue->Rndm() > efficiency)
                   thisMesonAccepted[jMeson] = false;  // this meson is lost
              }
	      if(!thisMesonConverted[jMeson] && thisMesonAccepted[jMeson])
		nMult_trg++;
 
	    } // check on pt and eta cuts

	  } //first loop over meson array

	  if(nMult_trg > 0) {
	    nTrgTotal += nMult_trg;
	    fillFactor = 1.0/4.0/nMult_trg;  // filling factor used by Monika
	  }

	  for(int jChMeson=0; jChMeson< nChMesonSize; jChMeson++) {

	    int thisPdgId = pdgIdChMeson[jChMeson];
	    if(thisPdgId==211 || thisPdgId==-211 || thisPdgId==321 || thisPdgId==-321 || thisPdgId==2212 || thisPdgId==-2212) {
	      float pt_ass = ptChMeson[jChMeson];
	      float eta_ass = etaChMeson[jChMeson];

	      if(useTrackEfficiencyTable) {
		float chEfficiency = efficiencyTrackYieldsRead->GetBinContent(efficiencyTrackYieldsRead->FindBin(eta_ass, pt_ass));
		if(randomValue->Rndm() > chEfficiency)
		  continue;  // this charged particle was lost
	      } // check on using charged particle efficiency table
	      
	      if(pt_ass >= ptMin_ass && pt_ass <= ptMax_ass && fabs(eta_ass) < 2.4) {

		float phi_ass = phiChMeson[jChMeson];

		if(nMult_ass < MAXBACKGROUNDSIZE) {
		  etaThisEvent[nMult_ass] = eta_ass;
		  phiThisEvent[nMult_ass] = phi_ass;
		  nMult_ass++;
		} // check size
		else {
		  cerr << "\n Too many charged particles" << endl;
		  return;
		} // safety check

	      } // check kinematic values
	    }  // check particle ID
	  } // loop over charged particle mesons

	} // check on doing pair correlations, to get kinematic arrays

        for(int jMeson=0; jMeson< nMesonSize; jMeson++) {
					
          if(pdgIdMeson[jMeson] == pdgIdMesonChoice && daughtersFromMeson[jMeson] == 2 && fabs(etaMeson[jMeson]) <= etaHighLimit &&
             fabs(etaMeson[jMeson]) >= etaLowLimit && ptMeson[jMeson] > 0.5 && ptMeson[jMeson] < 5.0) {

	    if(thisMesonConverted[jMeson]) {
              countSkippedConversions++;
              continue;
            } // check on conversions

	    if(iOption >= 234 && iOption <= 237 && nMult_trg > 0) {
              if(!thisMesonAccepted[jMeson])  // check if meson failed efficiency cut or is not a pi0
                continue;  // meson failed efficiency cut

	      //
	      // Filling particle pair correlation histograms
	      //

	      float pt_trg = ptMeson[jMeson];
	      if(useRecoPt)
		pt_trg = ptRecoMeson[jMeson];

	      float eta_trg = etaMeson[jMeson];
	      if(useRecoEta)
		eta_trg = etaRecoMeson[jMeson];

	      if(pt_trg >= ptMin_trg && pt_trg <= ptMax_trg && fabs(eta_trg) <1.5) {

		int kPtIndex = -1;
		for(int kPt=0; kPt<nPtBinsComplete; kPt++) {

		  if(pt_trg > lowPtBinCompleteLimit[kPt] && pt_trg <= highPtBinCompleteLimit[kPt]) {
		    kPtIndex = kPt;
		    break;
		  }
		}

		if(kPtIndex == -1)
		  continue;

		if(kPtIndex >= 0 && kPtIndex < nPtBinsComplete) {
		  nTriggers_PtBin[kPtIndex]++;
		}
		else {
		  cerr << "\n Programming error: invalid value for integer kPtIndex = " << kPtIndex << endl;
		  return;
		}

		int useBufferDepth = 1 + kPtIndex;
		if(useTripleRecoDepth || useConversionSuppression || checkRecoMass || usePi0EfficiencyTable || useTrackEfficiencyTable)
		  useBufferDepth *= 3;

		if(useBufferDepth > NBUFFERDEPTH)
		  useBufferDepth = NBUFFERDEPTH;

		float phi_trg = phiMeson[jMeson];

		//
		// Look for associated charged particles in same event
		//
		for(int jChMeson=0; jChMeson< nMult_ass; jChMeson++) {

		  float eta_ass = etaThisEvent[jChMeson];
		  float phi_ass = phiThisEvent[jChMeson];

		  float deltaEta = eta_trg - eta_ass;

		  // How does this code different from the standard CMS function for Delta-Phi?
		  double deltaPhiSharma = phi_ass - phi_trg;
		  double deltaPhiCMS = deltaPhi(phi_ass, phi_trg);

		  double phiDelta = deltaPhiSharma;
		  if(useDeltaPhiCMS)
		    phiDelta = deltaPhiCMS;

		  if(phiDelta > TMath::Pi()) phiDelta = phiDelta - 2*TMath::Pi();
		  if(phiDelta < -TMath::Pi()) phiDelta = phiDelta + 2*TMath::Pi();
		  if(phiDelta > -TMath::Pi() && phiDelta < -TMath::Pi()/2.0) phiDelta = phiDelta + 2*TMath::Pi();

		  if(deltaEta == 0 && phiDelta == 0)
		    continue;

		  //
		  // Monika's hSignal histogram filling
		  //
		  if(useEtaSymmetry) {
		    hGenSignalPtBin[kPtIndex]->Fill(fabs(deltaEta),fabs(phiDelta),fillFactor);
		    hGenSignalPtBin[kPtIndex]->Fill(-fabs(deltaEta),fabs(phiDelta),fillFactor);
		    hGenSignalPtBin[kPtIndex]->Fill(fabs(deltaEta),-fabs(phiDelta),fillFactor);
		    hGenSignalPtBin[kPtIndex]->Fill(-fabs(deltaEta),-fabs(phiDelta),fillFactor);
		    hGenSignalPtBin[kPtIndex]->Fill(fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactor);
		    hGenSignalPtBin[kPtIndex]->Fill(-fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactor);
		  }
		  else {
		    hGenSignalPtBin[kPtIndex]->Fill(deltaEta, fabs(phiDelta), 2.0*fillFactor);
		    hGenSignalPtBin[kPtIndex]->Fill(deltaEta, -fabs(phiDelta), 2.0*fillFactor);
		    hGenSignalPtBin[kPtIndex]->Fill(deltaEta, 2*TMath::Pi()-fabs(phiDelta), 2.0*fillFactor);
		  }
		    		       
		} // loop jChMeson for same event charged particle mesons (and proton)

		//
		// Look for associated charged particles in the buffer events
		//
		if(nBuffersFilled >= NBUFFERDEPTH) {
		  for(int kBuffer=0; kBuffer<useBufferDepth; kBuffer++) {

		    nLast_ass = nLastBuffer[kBuffer];
		    if(nLast_ass < 1)
		      continue;

		    float fillFactorAssociated = 1.0/nMult_trg/nLast_ass;
		    
		    for(int jChMeson=0; jChMeson< nLast_ass; jChMeson++) {		  
		      //
		      // Look for associated charged particles in buffer event
		      //

		      float eta_ass = etaLastEvent[jChMeson][kBuffer];
		      float phi_ass = phiLastEvent[jChMeson][kBuffer];
		    
		      float deltaEta = eta_trg - eta_ass;

		      // How does this code different from the standard CMS function for Delta-Phi?
		      double deltaPhiSharma = phi_ass - phi_trg;
		      double deltaPhiCMS = deltaPhi(phi_ass, phi_trg);

		      double phiDelta = deltaPhiSharma;
		      if(useDeltaPhiCMS)
			phiDelta = deltaPhiCMS;

		      if(phiDelta > TMath::Pi()) phiDelta = phiDelta - 2*TMath::Pi();
		      if(phiDelta < -TMath::Pi()) phiDelta = phiDelta + 2*TMath::Pi();
		      if(phiDelta > -TMath::Pi() && phiDelta < -TMath::Pi()/2.0) phiDelta = phiDelta + 2*TMath::Pi();

		      if(deltaEta == 0 && phiDelta == 0)
			continue;

		      //
		      // Monika's mixed-event histogram filling
		      //
		      if(useEtaSymmetry) {
			hGenBackgroundPtBin[kPtIndex]->Fill(fabs(deltaEta),fabs(phiDelta),fillFactorAssociated);
			hGenBackgroundPtBin[kPtIndex]->Fill(-fabs(deltaEta),fabs(phiDelta),fillFactorAssociated);
			hGenBackgroundPtBin[kPtIndex]->Fill(fabs(deltaEta),-fabs(phiDelta),fillFactorAssociated);
			hGenBackgroundPtBin[kPtIndex]->Fill(-fabs(deltaEta),-fabs(phiDelta),fillFactorAssociated);
			hGenBackgroundPtBin[kPtIndex]->Fill(fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactorAssociated);
			hGenBackgroundPtBin[kPtIndex]->Fill(-fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactorAssociated);
		      }
		      else {
			hGenBackgroundPtBin[kPtIndex]->Fill(deltaEta, fabs(phiDelta), 2.0*fillFactorAssociated);
			hGenBackgroundPtBin[kPtIndex]->Fill(deltaEta, -fabs(phiDelta), 2.0*fillFactorAssociated);
			hGenBackgroundPtBin[kPtIndex]->Fill(deltaEta, 2*TMath::Pi()-fabs(phiDelta), 2.0*fillFactorAssociated);
		      }
   
		    } // loop jChMeson for buffer event charged particle mesons (and proton)

		  } // loop over buffer events

		} // check if all the buffer event arrays have been filled

	      } // check for pt_trg and eta values

	      continue;  // don't do further processing when iOption = 234 to 237

	    } // check iOption 234-237 for filling particle pair correlations

	    generatorPi0YieldsPt->Fill(ptMeson[jMeson]);
	    generatorPi0YieldsEta->Fill(etaMeson[jMeson]);
						
	    generatorPi0Yields->Fill(ptMeson[jMeson], etaMeson[jMeson]);
	    countPrimaryMesons++;
						
	    if(fabs(etaRecoMeson[jMeson]) < 1.49 && ptRecoMeson[jMeson] > 0.50 && ptRecoMeson[jMeson] < 5.0) {
							
	      float recoMassValue = massRecoMeson[jMeson];
	      bool skipThisDecay = false;
	      if(useEnergyCorrection) { // This correction determination needs access to the ECAL information
	        int jMerge1 = mergeDecay1Meson[jMeson];  // need to check what is the efficiency for getting a match with mergedTrackTruth
	        int jMerge2 = mergeDecay2Meson[jMeson];
	        if(jMerge1 >= 0 && jMerge1 < mergedTrackTruthSize &&
	  	   jMerge2 >= 0 && jMerge2 < mergedTrackTruthSize &&
		   bestEcalAngleMatch[jMerge1] >= 0.0 && bestEcalAngleMatch[jMerge1] < 0.03 &&
		   bestEcalAngleMatch[jMerge2] >= 0.0 && bestEcalAngleMatch[jMerge2] < 0.03) {
		  int jClu1 = bestEcalIndexMatch[jMerge1];
		  int jClu2 = bestEcalIndexMatch[jMerge2];
		  int crystalIndex1 = nCryClu[jClu1];
		  int crystalIndex2 = nCryClu[jClu2];
		  if(useClusterCrystalLimit && (crystalIndex1 < lowCrystalLimit ||
				                crystalIndex1 > highCrystalLimit ||
			   		        crystalIndex2 < lowCrystalLimit ||
				   	        crystalIndex2 > highCrystalLimit)) {
		    countOutOfRangeCrystal++;
		    skipThisDecay = true;
		    cout << "\n First check" << endl;
		    return;
		  } // check for use of crystal limits
		
		  crystalIndex1--;  // get to 0 - 8 range
		  crystalIndex2--;  // get to 0 - 8 range
									
		  int nGoodRecoMatch1 = nGoodRecoMatches[jClu1];
		  int nGoodRecoMatch2 = nGoodRecoMatches[jClu2];
									
		  if(useTrackMatchSuppression && (nGoodRecoMatch1 > 0 || nGoodRecoMatch2 > 0)) {
		    skipThisDecay = true;
		    countSuppressedMatches++;
		    cout << "\n Third check" << endl;
		    return;
		  } // check for use of tracksuppression
									
		  if(countTestPrint < 0 && (nGoodRecoMatch1 > 0 || nGoodRecoMatch2 > 0)) {
										
		    cout << "\n jMeson " << jMeson;
		    cout << ", jMerge1 " << jMerge1;
		    cout << ", jClu1 " << jClu1;
		    cout << ", nGoodRecoMatch1 " << nGoodRecoMatch1;
		    cout << ", jMerge2 " << jMerge2;
		    cout << ", jClu2 " << jClu2;
		    cout << ", nGoodRecoMatch2 " << nGoodRecoMatch2;
		    cout << ", pdgIdMeson " << pdgIdMeson[jMeson];
		    cout << ", recoMassValue " << recoMassValue;
		    countTestPrint++;
		    if(countTestPrint >= 10) {
		      cout << "\n End of debug print " << endl;
		      return;
		    }
		  } // test print
									
		  float ptEcalOld1 = bestEcalPtMatch[jMerge1];
		  float ptEcalOld2 = bestEcalPtMatch[jMerge2];
		  if(ptEcalOld1 > lowEnergyCutParameter && ptEcalOld2 > lowEnergyCutParameter) {
										
		    float ecalEta1 = bestEcalDEtaMatch[jMerge1] + etaMerge[jMerge1];
		    float theta1 = 2.0*atan(exp(-ecalEta1));
		    float sinTheta1 = sin(theta1);
		    float cosTheta1 = cos(theta1);
		    float phi1 = bestEcalPhiMatch[jMerge1];
										
		    float ecalEta2 = bestEcalDEtaMatch[jMerge2] + etaMerge[jMerge2];
		    float theta2 = 2.0*atan(exp(-ecalEta2));
		    float sinTheta2 = sin(theta2);
		    float cosTheta2 = cos(theta2);
		    float phi2 = bestEcalPhiMatch[jMerge2];
										
		    float energyOld1 = ptEcalOld1/sinTheta1;
		    float energyOld2 = ptEcalOld2/sinTheta2;
                    
		    float energy1 = crystalCorrectionFunction(crystalIndex1, energyOld1);
		    float energy2 = crystalCorrectionFunction(crystalIndex2, energyOld2);
										
		    //
		    // The pT values will need to be changed by the same correction amount
		    //
										
		    float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
		    float recoMassTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
		    if(recoMassTest > 0.0)
		      recoMassValue = sqrt(recoMassTest);
										
		  } // check on pT value for each cluster
		  else {
		    countLowEnergySkipped++;
		    skipThisDecay = true; // an ECAL cluster energy is too low
		    cout << "\n Fourth check" << endl;
		    return;
		  } // pT is too low

		} // check on using energy correction
		else {
		  if(jMerge1 < 0 || jMerge1 >= mergedTrackTruthSize ||
		     jMerge2 < 0 || jMerge2 >= mergedTrackTruthSize) {
		    countMissingMerge++;
		  }
		  else {
		    countMissingAngleMatch++;
		  }
		  skipThisDecay = true; // missing an entry in the merged track truth collection
		}

	      } // check on use energy correction

	      if(skipThisDecay) {
		countSkippedDecays++;
		continue;
	      }
							
	      recoMass->Fill(recoMassValue);
              int specialPrint = 1;  // change to static int 
              const int maxSpecialPrint = 0;
							
	      if(fabs(recoMassValue - massCentroid) < massWindow) {

		float pt = ptRecoMeson[jMeson];
                float specialWeight = 1.0;
		if(useClusterCrystalLimitLowPtOnly && pt < clusterCrystalLimitLowPtOnly) {
                  specialWeight = fFirst + (pt - ptFirst)*lowPtEfficiencyInterpolation;
                  if(specialPrint < maxSpecialPrint) {
                    cout << "\n ptReco " << pt << " with special efficiency " << specialWeight;
                    specialPrint++;
                    if(specialPrint >= maxSpecialPrint) {
                      cout << endl;
                      return;
                    } // check for final print

                  } // check for using a special print
		} // check for using a special weight

		reconstructedPi0YieldsPt->Fill(ptMeson[jMeson], specialWeight);
		reconstructedPi0YieldsEta->Fill(etaMeson[jMeson]);
								
		reconstructedPi0Yields->Fill(ptMeson[jMeson], etaMeson[jMeson], specialWeight);

		for(int kPt=0; kPt<nPtBins; kPt++) {
		  if(pt >= lowPtBinLimit[kPt] &&  pt < highPtBinLimit[kPt]) {
		    recoEtaHistogramsPtBin[kPt]->Fill(etaRecoMeson[jMeson]);
		    break;
		  } // check on pt value
		} // loop over pt values
								
		averageRecoMass += recoMassValue;
		countRecoMesons++;

	      } // check on reco mass within a certain window
							
	    } // check on reco meson eta and pt values
						
	  } // check on primary pi0
	} // loop over stored mesons

	if(i%nEntries10 == 0 || i < 10) {

	  if(iOption != 231)
	    cout << "; nMult_trg = " << nMult_trg << ",  nMult_ass = " << nMult_ass << ",  nTrgTotal = " << nTrgTotal;
	  else
	    cout << "; countRecoMesons " << countRecoMesons << ",  countPrimaryMesons " << countPrimaryMesons;
	  
        }

	//
	// transfer this event to the buffer event arrays
	//
	if(currentBufferIndex < 0 || currentBufferIndex >= NBUFFERDEPTH) {
	  cerr << "\n Error in currentBufferIndex value " << currentBufferIndex << endl;
	  return;
	}
	for(int jChMeson=0; jChMeson<nMult_ass; jChMeson++) {
	  etaLastEvent[jChMeson][currentBufferIndex] = etaThisEvent[jChMeson];
	  phiLastEvent[jChMeson][currentBufferIndex] = phiThisEvent[jChMeson];
	}
	nLastBuffer[currentBufferIndex] = nMult_ass;
	nBuffersFilled++;

	currentBufferIndex++;
	if(currentBufferIndex == NBUFFERDEPTH)
	  currentBufferIndex = 0;

      } // loop on events in hTree entries
			
      cout << "\n Loop for reading entries has completed";
      cout << "\n Primary meson count = " << countPrimaryMesons << ",  reconstructed meson count = " << countRecoMesons;
      cout << "\n Number of suppressed ECAL-track matches = " << countSuppressedMatches;
      cout << "\n Number of missing merge matches = " << countMissingMerge;
      cout << ",  number of missing angle matches = " << countMissingAngleMatch;
      cout << "\n Number of decays with one or both photons too low in energy = " << countLowEnergySkipped;
      cout << ", with pT cut at " << lowEnergyCutParameter << " GeV/c";
      cout << "\n Number of decays with one or both photons not in crystal number range = " << countOutOfRangeCrystal;
      cout << "\n Number of skipped decays = " << countSkippedDecays;
      cout << "\n Number of total trigger particles for pair correlations = " << nTrgTotal;
			
      if(countRecoMesons > 0)
	cout << "\n Average reco mass = " << averageRecoMass/countRecoMesons;
      if(!allowConversions)
	cout << "\n Number of mesons with decay photons that converted = " << countSkippedConversions;
			
      cout << endl << endl;

      if(iOption == 234) {
	c1->Divide(2,2);
	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);
	  hGenSignalPtBin[kPt]->Draw("SURF1");
	}
	return;
      }

      if(iOption == 235) {
	c1->Divide(2,2);
	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);
	  hGenBackgroundPtBin[kPt]->Draw("SURF1");
	}
	return;
      }

      if((iOption == 236 || iOption == 237) && nTrgTotal > 0) {

	float etaMin = 2.0;
	float etaMax = 3.6;
    
	TString Name = "projClone";
	TString Name2 = "pi0HadProj";
	TString Name4 = "FourierDecompose";
	TString Name1, Name3, Name5;
    
	TH2D *projCorrFunc[9];
	TH1D *pi0HadCorrProj[9];
	TF1 *FourierDecompose[9];
	const int n = 9;

	double Parameter2[n];
	double Par2Error[n];
	double Parameter3[n];
	double Par3Error[n];

	c1->Divide(3,3);

	double etabinwidth = hGenSignalPtBin[0]->GetXaxis()->GetBinWidth(1);
	double phibinwidth = hGenSignalPtBin[0]->GetYaxis()->GetBinWidth(1);
	double binWidthFactor = 1.0/etabinwidth/phibinwidth;
	const float v2ChargedInverse = 1.0/0.232;  // v2 of the EPOS generator charged particles, 0.3 - 3.0 GeV/c, according to Z. Chen (May 4, 2014, K0-short analysis)

	for(long kPt=0; kPt<nPtBinsComplete; kPt++) {

	  v2FitValue[kPt] = 0;
	  v2FitError[kPt] = 0;

	  c1->cd(kPt+1);

	  hGenSignalPtBin[kPt]->Divide(hGenBackgroundPtBin[kPt]);
	  sprintf(histogramTitle, "MC: Signal #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f ", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);

	  float errorBase = 0.001*sqrt(float(nMult_trgAllEventsPt[kPt])/float(nTriggers_PtBin[kPt]));

	  int x0 = hGenBackgroundPtBin[kPt]->GetXaxis()->FindBin(0.0);
	  int y0 = hGenBackgroundPtBin[kPt]->GetYaxis()->FindBin(0.0);
	  double B0 = hGenBackgroundPtBin[kPt]->GetBinContent(x0,y0);
	  if(B0 <= 0.0 || nEventsTotal <= 0) {
	    cerr << "\n Error B0 = " << B0 << ",  nEventsTotal = " << nEventsTotal << endl;
	    return;
	  }
	  hGenSignalPtBin[kPt]->SetTitle(histogramTitle);
	  hGenSignalPtBin[kPt]->Scale(B0/nEventsTotal);
	  hGenSignalPtBin[kPt]->Scale(binWidthFactor);
	  hGenSignalPtBin[kPt]->GetZaxis()->SetNdivisions(505);

	  hGenSignalPtBin[kPt]->GetXaxis()->SetRange(5,29);

	  if(iOption == 236)
	    hGenSignalPtBin[kPt]->Draw("SURF1");

	  if(iOption == 237) {
	    Name1 = Name + kPt;
	    Name3 = Name2 + kPt;
	    Name5 = Name4 + kPt;

	    projCorrFunc[kPt] = (TH2D*)hGenSignalPtBin[kPt]->Clone(Name1);
 
	    int etabin10m = projCorrFunc[kPt]->GetXaxis()->FindBin(etaMin+0.01);
	    int etabin10p = projCorrFunc[kPt]->GetXaxis()->FindBin(etaMax-0.01);

	    pi0HadCorrProj[kPt] = (TH1D *) projCorrFunc[kPt]->ProjectionY(Name3,etabin10m,etabin10p,"e");
	    pi0HadCorrProj[kPt]->GetXaxis()->SetRange(8,24);

	    pi0HadCorrProj[kPt]->SetMarkerColor(4);
	    pi0HadCorrProj[kPt]->SetMarkerStyle(20);
	    pi0HadCorrProj[kPt]->SetMarkerSize(1.0);

	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitle("#Delta#phi");
	    pi0HadCorrProj[kPt]->GetXaxis()->SetLabelFont(42);
	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitleSize(0.06);
	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitleOffset(0.67);
	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitleFont(42);

	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitle("Associated yield");
	    pi0HadCorrProj[kPt]->GetYaxis()->SetLabelFont(42);
	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitleSize(0.06);
	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitleOffset(0.77);
	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitleFont(42);

	    int nBinsX = pi0HadCorrProj[kPt]->GetNbinsX();
	    int nHalfBinsX = nBinsX/2;
	    float errorFactor = (1.0+ pow(float(kPt),1.25))*errorBase;

	    if(kPt > 5)
	      errorFactor *= 2.0;

	    for(int kBin=1; kBin<=nBinsX; kBin++) {
	      double value = pi0HadCorrProj[kPt]->GetBinContent(kBin);
	      pi0HadCorrProj[kPt]->SetBinError(kBin, errorFactor*(2.0-fabs(float(kBin-nHalfBinsX)/float(nHalfBinsX)))*value);
	    }

	    pi0HadCorrProj[kPt]->SetStats(0);
	    float maximumHistogramValue = pi0HadCorrProj[kPt]->GetMaximum();
	    float minimumHistogramValue = pi0HadCorrProj[kPt]->GetMinimum();
	    pi0HadCorrProj[kPt]->SetMaximum(maximumHistogramValue + 0.50*(maximumHistogramValue - minimumHistogramValue));
	    pi0HadCorrProj[kPt]->Draw("E1");
	    (c1->cd(kPt+1))->SetGrid();

	    if(useV1V2Fit) {
	      FourierDecompose[kPt] = new TF1(Name5, v1v2Fit, -1.4, 4.88, 3);
	      FourierDecompose[kPt]->SetParNames("Norm","v1", "v2");
	    }

	    if(useV2FitOnly) {
	      FourierDecompose[kPt] = new TF1(Name5, v2Fit, -1.4, 4.88, 2);
	      FourierDecompose[kPt]->SetParNames("Norm","v2");
	      FourierDecompose[kPt]->SetParameters(1.0, 0.2);
	    }

	    if(!useV2FitOnly && !useV1V2Fit) {
	      FourierDecompose[kPt] = new TF1(Name5, FourierFunction, -1.4, 4.88, 4);
	      FourierDecompose[kPt]->SetParNames("Norm", "v1", "v2", "v3");
	      FourierDecompose[kPt]->SetParameters(1.0, 0.1, 0.2, 0.3);
	    }

	    pi0HadCorrProj[kPt]->Fit(Name5, "", "", -1.4, 4.84);

	    double v1 = 0;
	    double v1Error = 0;

	    if(useV1V2Fit) {
	      v1 = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(1);
	      v1Error = v2ChargedInverse*FourierDecompose[kPt]->GetParError(1);

	      Parameter2[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(2);
	      Par2Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(2);

	    } // using a v1 + v2 fit function

	    if(useV2FitOnly) {
	      Parameter2[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(1);
	      Par2Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(1);
	    } // using a pure v2 fit function
	    
	    if(!useV2FitOnly && !useV1V2Fit) {
	      Parameter2[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(2);
	      Par2Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(2);
	      Parameter3[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(3);
	      Par3Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(3);
	    }

	    TLegend *legend = new TLegend(0.15, 0.69, 0.88, 0.85);
	    char *legendHeader = new char[200];
	    if(useEPOS)
	      sprintf(legendHeader, "GEN-EPOS pPb: #pi^{0} triggers for this p_{T} bin = %d", nTriggers_PtBin[kPt]); 
	    if(useHijing)
	      sprintf(legendHeader, "GEN-HIJING pPb: #pi^{0} triggers for this p_{T} bin = %d", nTriggers_PtBin[kPt]); 
	    legend->SetHeader(legendHeader);
	    legend->SetTextSize(0.04);
	    legend->SetTextColor(kBlue);

	    v2FitValue[kPt] = Parameter2[kPt];
	    v2FitError[kPt] = Par2Error[kPt];

	    char *fitResult = new char[200];

	    if(useV1V2Fit) {
	      sprintf(fitResult, "v_{2} = %4.3f #pm %4.3f, v_{1} = %4.3f #pm %4.3f", Parameter2[kPt], Par2Error[kPt], v1, v1Error); 
	    }

	    if(useV2FitOnly) {
	      sprintf(fitResult, "v_{2} = %4.3f #pm %4.3f (pure v_{2} fit)", Parameter2[kPt], Par2Error[kPt]); 
	    }

	    if(!useV2FitOnly && !useV1V2Fit) {
	      sprintf(fitResult, "v_{2} = %4.3f #pm %4.3f, v_{3} = %4.3f #pm %4.3f", Parameter2[kPt], Par2Error[kPt], Parameter3[kPt], Par3Error[kPt]); 
	    }
	    legend->AddEntry(Name5, fitResult, "l");
	    legend->Draw();

	    if(kPt == 0) {

	      //
	      // Extra labeling for top left plot
	      //
	      float maximumHistogramValue1 = pi0HadCorrProj[kPt]->GetMaximum();

	      char *genLabel1 = new char[60];
	      sprintf(genLabel1, "Total #pi^{0} trigger particles =  %d", nTrgTotal);
	      TLatex *genText1 = new TLatex(0.62, minimumHistogramValue + 0.60*(maximumHistogramValue1-minimumHistogramValue), genLabel1);
	      genText1->SetTextColor(2);
	      genText1->SetTextSize(0.045);
	      genText1->Draw();

	      if(useConversionSuppression) {
		TLatex *genText2 = new TLatex(0.62, minimumHistogramValue + 0.50*(maximumHistogramValue1-minimumHistogramValue), "Conversion photons suppressed for MC");
		genText2->SetTextColor(2);
		genText2->SetTextSize(0.042);
		genText2->Draw();
	      }

	      if(usePi0EfficiencyTable) {
		TLatex *genText2 = new TLatex(0.62, minimumHistogramValue + 0.50*(maximumHistogramValue1-minimumHistogramValue), "#pi^{0} efficiency losses used for MC");
		genText2->SetTextColor(2);
		genText2->SetTextSize(0.042);
		genText2->Draw();
	      }

	      if(checkRecoMass) {
		char *genLabel2 = new char[100];
		sprintf(genLabel2, "Check reco mass: %5.3f<m_{#gamma#gamma}<%5.3f GeV/c^{2}", lowLimitPi0Mass, highLimitPi0Mass);
		TLatex *genText2 = new TLatex(0.62, minimumHistogramValue + 0.50*(maximumHistogramValue1-minimumHistogramValue), genLabel2);
		genText2->SetTextColor(2);
		genText2->SetTextSize(0.042);
		genText2->Draw();
	      }

	      if(!useHijing && !useConversionSuppression && !usePi0EfficiencyTable && !checkRecoMass && !checkDecayEnergy && !useTrackEfficiencyTable) {
		TLatex *genText2 = new TLatex(0.62, minimumHistogramValue + 0.50*(maximumHistogramValue1-minimumHistogramValue), "No acceptance modifications for MC");
		genText2->SetTextColor(2);
		genText2->SetTextSize(0.042);
		genText2->Draw();
	      }

	      if(useRecoPt || useRecoEta) {
		TLatex *genText3 = new TLatex(0.62, minimumHistogramValue + 0.40*(maximumHistogramValue1-minimumHistogramValue), "Using reco p_{T} and #eta for MC");
		if(!useRecoEta)
		  genText3 = new TLatex(0.62, minimumHistogramValue + 0.40*(maximumHistogramValue1-minimumHistogramValue), "Using reco p_{T} for MC");
		if(!useRecoPt)
		  genText3 = new TLatex(0.62, minimumHistogramValue + 0.40*(maximumHistogramValue1-minimumHistogramValue), "Using reco #eta for MC");

		genText3->SetTextColor(2);
		genText3->SetTextSize(0.042);
		genText3->Draw();
	      }

	      if(checkDecayEnergy) {
		TLatex *genText4 = new TLatex(0.72, minimumHistogramValue + 0.40*(maximumHistogramValue1-minimumHistogramValue), "Check decay photon energy");
		genText4->SetTextColor(2);
		genText4->SetTextSize(0.042);
		genText4->Draw();
	      }

	      if(useTrackEfficiencyTable) {
		TLatex *genText4 = new TLatex(0.62, minimumHistogramValue + 0.40*(maximumHistogramValue1-minimumHistogramValue), "Track efficiency losses used for MC");
		genText4->SetTextColor(2);
		genText4->SetTextSize(0.042);
		genText4->Draw();
	      }

	    } // extra labeling for top left plot

	    cout << "\n " << kPt << ") v2Fit = " << v2FitValue[kPt] << " +/- " << v2FitError[kPt];
	  } // check for iOption = 237
	  cout << endl;

	} // loop over kPt

	if(iOption == 237) {
	  for(int kPt=0; kPt<nPtBinsComplete; kPt++) {
	    cout << "\n " << kPt << ") v2Fit = " << v2FitValue[kPt] << " +/- " << v2FitError[kPt];
	  }
	  cout << endl << endl;
	}

	return;
      } // iOption = 236 or 237

      if(iOption == 233) {
	c1->Divide(2,2);
	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);
	  recoEtaHistogramsPtBin[kPt]->Draw();
	  (c1->cd(kPt+1))->SetGrid();
	  recoEtaHistogramsPtBin[kPt]->SetMinimum(0);
	  double maxHistogramValue = recoEtaHistogramsPtBin[kPt]->GetMaximum();
	  if(kPt == 0) {
	    double maxHistogramValue1 = 1.45*maxHistogramValue;
	    recoEtaHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue1);
	    char *runLabelText1 = new char[200];
	    sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", int(entriesToProcess));
	    if(simRunEPOS) {
	      sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", int(entriesToProcess));
	    }
	    TLatex *runLabel1 = new TLatex(-1.25, 0.93*maxHistogramValue1, runLabelText1);
	    runLabel1->SetTextColor(2);
	    runLabel1->SetTextSize(0.055);
	    runLabel1->Draw();
            
	    char *runLabelText2 = new char[200];
	    if(useHighPurityTracks) {
	      sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	    }
	    else {
	      sprintf(runLabelText2, "%d < NHITracks < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	    }
	    TLatex *runLabel2 = new TLatex(0.02, 0.86*maxHistogramValue1, runLabelText2);
	    runLabel2->SetTextColor(1);
	    runLabel2->SetTextSize(0.045);
	    runLabel2->Draw();

	    char *runLabelText3 = new char[200];
	    sprintf(runLabelText3, "%5.3f < m_{#gamma#gamma} < %5.3f GeV/c^{2}", massCentroid - massWindow, massCentroid + massWindow);
            
	    TLatex *runLabel3 = new TLatex(-1.25, 0.78*maxHistogramValue1, runLabelText3);
	    runLabel3->SetTextColor(2);
	    runLabel3->SetTextSize(0.050);
	    runLabel3->Draw();

	  } // check on first pt bin

	  char *runLabelText4 = new char[200];
	  if(useConversionSuppression) {
	    sprintf(runLabelText4, "Photon conversions suppressed: RMS = %5.3f", recoEtaHistogramsPtBin[kPt]->GetRMS());
	  }
	  else {
	    sprintf(runLabelText4, "Photon conversions not suppressed: RMS = %5.3f", recoEtaHistogramsPtBin[kPt]->GetRMS());
	  }
	  TLatex *runLabel4 = new TLatex(-1.25, 0.15*maxHistogramValue, runLabelText4);
	  runLabel4->SetTextColor(2);
	  runLabel4->SetTextSize(0.050);
	  runLabel4->Draw();

	} // loop over pt bins
	
	return;

      } // iOption = 233

      if(iOption == 231 || iOption == -231) {
	efficiencyPi0Yields->SetStats(0);
	efficiencyPi0Yields->SetMaximum(0.6);
	for(int xBin=0; xBin<25; xBin++) {
	  for(int yBin=0; yBin<25; yBin++) {
	    float numerator = reconstructedPi0Yields->GetBinContent(xBin, yBin);
	    float denominator = generatorPi0Yields->GetBinContent(xBin, yBin);
	    
	    if(denominator > 0.0)
	      efficiencyPi0Yields->SetBinContent(xBin, yBin, numerator/denominator);
	  } // loop over x bins
	} // loop over y bins
	efficiencyPi0Yields->Draw("surf3");

	char *efficiencyTitle = new char[200];
	char *efficiencyFileName = new char[200];
	if(useHighPurityTracks) {
	  sprintf(efficiencyTitle, "Efficiency (pt,eta) for pi0 in events with HighPurity Tracks = %d - %d, use S4/S9 = %4.2f and |1-S25|/S9 cut = %4.2f, created on %s", lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, asciiDate); 
	  sprintf(efficiencyFileName, "pi0EfficiencyHiPurity%d-%d_S4To9%3.2f_S25To9%2.1f_%s", lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, asciiDate); 
	}
	else {
	  sprintf(efficiencyTitle, "Efficiency (pt,eta) for pi0 in events with NHITracks = %d - %d, use S4/S9 = %4.2f and |1-S25|/S9 cut = %4.2f, created on %s", lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, asciiDate);
	  sprintf(efficiencyFileName, "pi0EfficiencyNHITrack%d-%d_S4To9%3.2f_S25To9%2.1f_%s", lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, asciiDate); 
	}

	TFile *pi0EfficiencyFile = new TFile(efficiencyFileName, "recreate", efficiencyTitle);
        generatorPi0YieldsEta->Write();
        generatorPi0YieldsPt->Write();
        reconstructedPi0YieldsEta->Write();
        reconstructedPi0YieldsPt->Write();
	generatorPi0Yields->Write();
	reconstructedPi0Yields->Write();
	efficiencyPi0Yields->Write();
	pi0EfficiencyFile->Close();
	return;
      } // iOption = 231 or iOption = -231
	
      bool twoPanel = false;
      bool fourPanel = false;
      if(iOption == 23 || iOption == -23 || iOption == 25 || iOption == -25) {
	c1->Divide(2,2);
	fourPanel = true;
      }
      if(iOption == 232 || iOption == -232) {
	c1->Divide(2,1);
	twoPanel = true;
      }
   
      if(iOption == 23 || iOption == -23 || iOption == 25 || iOption == -25 || iOption == 232 || iOption == -232) {
	
	c1->cd(1);
	if(fourPanel) {
	  recoMass->SetStats(0);
	  float recoHistogramMax = recoMass->GetMaximum();
				
	  TF1 *massFcn1 = new TF1("massFcn1", gaussPeak, massCentroid - 1.2*massWindow, massCentroid + 1.2*massWindow, 3);
	  massFcn1->SetParameter(0, recoHistogramMax);
	  massFcn1->SetParameter(1, massCentroid);
	  massFcn1->SetParameter(2, 0.02*massCentroid);
				
	  recoMass->Fit(massFcn1, "", "", massCentroid - 1.2*massWindow, massCentroid + 1.2*massWindow);
				
	  TLatex *recoMassLabel1;
	  if(iOption == 25 || iOption == -25)
	    recoMassLabel1 = new TLatex(0.15, 0.85*recoHistogramMax, "200K pPb HIJING Events (July 1, 2013)");
	  else
	    recoMassLabel1 = new TLatex(0.15, 0.85*recoHistogramMax, "600K pPb HIJING Events (July 1, 2013)");
				
	  recoMassLabel1->SetTextColor(4);
	  recoMassLabel1->SetTextSize(0.05);
	  recoMassLabel1->Draw();
        
	  TLatex *recoMassLabel2 = new TLatex(0.15, 0.75*recoHistogramMax, "ECAL cluster (#eta,#phi) matched to decay photon (#eta,#phi)");
	  recoMassLabel2->SetTextColor(4);
	  recoMassLabel2->SetTextSize(0.040);
	  recoMassLabel2->Draw();
				
	  TLatex *recoMassLabel3 = new TLatex(0.15, 0.65*recoHistogramMax, "No p_{T} cut");
	  recoMassLabel3->SetTextColor(4);
	  recoMassLabel3->SetTextSize(0.040);
	  recoMassLabel3->Draw();
				
	  if(useEnergyCorrection) {
	    TLatex *recoMassLabel4 = new TLatex(0.15, 0.55*recoHistogramMax, "Using cluster energy correction function");
	    recoMassLabel4->SetTextColor(4);
	    recoMassLabel4->SetTextSize(0.040);
	    recoMassLabel4->Draw();
	  }
				
	  TLatex *recoMassLabel5a = new TLatex(0.16, 0.45*recoHistogramMax, "Fit results:");
	  recoMassLabel5a->SetTextColor(4);
	  recoMassLabel5a->SetTextSize(0.040);
	  recoMassLabel5a->Draw();
				
	  char *fitLabelb = new char[200];
	  sprintf(fitLabelb, "<m> = %4.1f MeV", 1000.0*massFcn1->GetParameter(1));
	  TLatex *recoMassLabel5b = new TLatex(0.16, 0.38*recoHistogramMax, fitLabelb);
	  recoMassLabel5b->SetTextColor(4);
	  recoMassLabel5b->SetTextSize(0.040);
	  recoMassLabel5b->Draw();
				
	  char *fitLabelc = new char[200];
	  sprintf(fitLabelc, "#sigma = %4.1f MeV", 1000.0*fabs(massFcn1->GetParameter(2)));
	  TLatex *recoMassLabel5c = new TLatex(0.16, 0.31*recoHistogramMax, fitLabelc);
	  recoMassLabel5c->SetTextColor(4);
	  recoMassLabel5c->SetTextSize(0.040);
	  recoMassLabel5c->Draw();
				
	  TLatex *recoMassLabel6;
	  if(useTrackMatchSuppression)
	    recoMassLabel6 = new TLatex(0.17, 0.21*recoHistogramMax, "Suppress track-matched ECAL clusters");
	  else
	    recoMassLabel6 = new TLatex(0.17, 0.21*recoHistogramMax, "Allow track-matched ECAL clusters");
        
	  recoMassLabel6->SetTextColor(4);
	  recoMassLabel6->SetTextSize(0.040);
	  recoMassLabel6->Draw();
				
	  TLine *pi0MassValue1;
	  if(iOption == 25 || iOption == -25)
	    pi0MassValue1 = new TLine(0.54751, 0.0, 0.54751, recoHistogramMax);
	  else
	    pi0MassValue1 = new TLine(0.134976, 0.0, 0.134976, recoHistogramMax);
				
	  pi0MassValue1->SetLineColor(kMagenta);
	  pi0MassValue1->Draw("same");
				
	  (c1->cd(1))->SetGrid();
        
	  c1->cd(2);
	} // four panel plot

	generatorPi0Yields->SetStats(0);
	generatorPi0Yields->Draw("surf3");
	if(fourPanel) {
	  (c1->cd(2))->SetLogz();
	  c1->cd(3);
	}
	if(twoPanel) {
	  (c1->cd(1))->SetLogz();
	  c1->cd(2);
	}
        
	reconstructedPi0Yields->SetStats(0);
	reconstructedPi0Yields->Draw("surf3");
	if(fourPanel) {
	  (c1->cd(3))->SetLogz();
	}
	if(twoPanel) {
	  (c1->cd(2))->SetLogz();
	}

	if(fourPanel) {
	  c1->cd(4);
	  efficiencyPi0Yields->SetStats(0);
	  efficiencyPi0Yields->SetMaximum(1.2);
	  for(int xBin=0; xBin<25; xBin++) {
	    for(int yBin=0; yBin<25; yBin++) {
	      float numerator = reconstructedPi0Yields->GetBinContent(xBin, yBin);
	      float denominator = generatorPi0Yields->GetBinContent(xBin, yBin);
						
	      if(denominator > 0.0)
		efficiencyPi0Yields->SetBinContent(xBin, yBin, numerator/denominator);
	    } // loop over x bins
	  } // loop over y bins
	  efficiencyPi0Yields->Draw("surf3");
	} // four panel plots

	return;
				
      } // iOption = 23 or -23 or 25 or -25 or 232 or -232



      if(iOption == 24 || iOption == -24 || iOption == 26 || iOption == -26) {
				
	cout << "\n\n  Plotting one-dimensional histograms"  << endl << endl;
				
	c1->cd(1);
	generatorPi0YieldsPt->SetStats(0);
	generatorPi0YieldsPt->SetLineColor(kBlue);
	generatorPi0YieldsPt->SetLineWidth(2);
	generatorPi0YieldsPt->SetMinimum(1.0);
	generatorPi0YieldsPt->Draw();
				
	reconstructedPi0YieldsPt->SetFillColor(kGreen);
	reconstructedPi0YieldsPt->Draw("same");
	(c1->cd(1))->SetLogy();
	(c1->cd(1))->SetGrid();
				
	c1->cd(2);
	generatorPi0YieldsEta->SetStats(0);
	generatorPi0YieldsEta->SetLineColor(kBlue);
	generatorPi0YieldsEta->SetLineWidth(2);
	generatorPi0YieldsEta->SetMinimum(0);
	generatorPi0YieldsEta->Draw();
				
	reconstructedPi0YieldsEta->SetFillColor(kGreen);
	reconstructedPi0YieldsEta->Draw("same");
	(c1->cd(2))->SetGrid();
				
	for(int xBin=1; xBin<=nBinsOneDimension; xBin++) {
	  float numerator = reconstructedPi0YieldsPt->GetBinContent(xBin);
	  float denominator = generatorPi0YieldsPt->GetBinContent(xBin);
	  if(denominator > 0)
	    efficiencyPi0YieldsPt->SetBinContent(xBin, numerator/denominator);
					
	  numerator = reconstructedPi0YieldsEta->GetBinContent(xBin);
	  denominator = generatorPi0YieldsEta->GetBinContent(xBin);
	  if(denominator > 0)
	    efficiencyPi0YieldsEta->SetBinContent(xBin, numerator/denominator);
	} // loop over bins
        
	c1->cd(3);
	efficiencyPi0YieldsPt->SetLineWidth(2);
	if(!allowConversions)
	  efficiencyPi0YieldsPt->SetMaximum(1.0);
	else
	  efficiencyPi0YieldsPt->SetMaximum(0.5);
				
	efficiencyPi0YieldsPt->SetStats(0);
	efficiencyPi0YieldsPt->SetLineColor(kRed);
	efficiencyPi0YieldsPt->Draw();
	(c1->cd(3))->SetGrid();
				
	c1->cd(4);
	efficiencyPi0YieldsEta->SetLineWidth(2);
	efficiencyPi0YieldsEta->SetMaximum(0.5);
	efficiencyPi0YieldsEta->SetStats(0);
	efficiencyPi0YieldsEta->SetLineColor(kRed);
	efficiencyPi0YieldsEta->Draw();
	(c1->cd(4))->SetGrid();
				
      } // iOption = 24 or -24 or 26 or -26
			
      return;
		
    }  // Look at 2-dimensional yields of the pi0 [eta(545)], as a function of pT and eta with iOption = 23 [=25], or 1-dimensional yields = 24 [=26]
       
	
    if(iOption == 27) {
      
      int nBinsOneDimension = 100;
      
      TH1D *generatorPi0YieldsPt = new TH1D("generatorPi0YieldsPt", "Generator #pi^{0} Yields(p_{T}) Before and After Cuts", nBinsOneDimension, 0.0, 5.0);
      generatorPi0YieldsPt->SetXTitle("p_{T} (GeV/c)");
      generatorPi0YieldsPt->SetYTitle("Counts");
      
      (generatorPi0YieldsPt->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPt->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0YieldsPt->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPt->GetXaxis())->CenterTitle();
      (generatorPi0YieldsPt->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPt->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0YieldsPt->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPt->GetYaxis())->CenterTitle();
      
      TH1D *generatorPi0YieldsPtCut = new TH1D("generatorPi0YieldsPtCut", "Generator #pi^{0} Yields(p_{T}) After Photon Decay Energy Cut", nBinsOneDimension, 0.0, 5.0);
      generatorPi0YieldsPtCut->SetXTitle("p_{T} (GeV/c)");
      generatorPi0YieldsPtCut->SetYTitle("Counts");
      
      (generatorPi0YieldsPtCut->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPtCut->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0YieldsPtCut->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPtCut->GetXaxis())->CenterTitle();
      (generatorPi0YieldsPtCut->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPtCut->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0YieldsPtCut->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPtCut->GetYaxis())->CenterTitle();
      
      TH1D *generatorPi0YieldsPtCutNoConvert = new TH1D("generatorPi0YieldsPtCutNoConvert", "Generator #pi^{0} Yields(p_{T}) Energy and NoConversion Cut", nBinsOneDimension, 0.0, 5.0);
      generatorPi0YieldsPtCutNoConvert->SetXTitle("p_{T} (GeV/c)");
      generatorPi0YieldsPtCutNoConvert->SetYTitle("Counts");
      
      (generatorPi0YieldsPtCutNoConvert->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPtCutNoConvert->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0YieldsPtCutNoConvert->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPtCutNoConvert->GetXaxis())->CenterTitle();
      (generatorPi0YieldsPtCutNoConvert->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPtCutNoConvert->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0YieldsPtCutNoConvert->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPtCutNoConvert->GetYaxis())->CenterTitle();
      
      TH1D *generatorEtaYieldsPt = new TH1D("generatorEtaYieldsPt", "Generator #eta(547.5 MeV) Yields(p_{T}) Before and After Cuts", nBinsOneDimension, 0.0, 5.0);
      generatorEtaYieldsPt->SetXTitle("p_{T} (GeV/c)");
      generatorEtaYieldsPt->SetYTitle("Counts");
      
      (generatorEtaYieldsPt->GetXaxis())->SetLabelSize(0.045);
      (generatorEtaYieldsPt->GetXaxis())->SetTitleOffset(1.);
      (generatorEtaYieldsPt->GetXaxis())->SetTitleSize(0.045);
      (generatorEtaYieldsPt->GetXaxis())->CenterTitle();
      (generatorEtaYieldsPt->GetYaxis())->SetLabelSize(0.045);
      (generatorEtaYieldsPt->GetYaxis())->SetTitleOffset(1.2);
      (generatorEtaYieldsPt->GetYaxis())->SetTitleSize(0.045);
      (generatorEtaYieldsPt->GetYaxis())->CenterTitle();
      
      TH1D *generatorEtaYieldsPtCut = new TH1D("generatorEtaYieldsPtCut", "Generator #eta(547.5 MeV) Yields(p_{T}) After Photon Decay Energy Cut", nBinsOneDimension, 0.0, 5.0);
      generatorEtaYieldsPtCut->SetXTitle("p_{T} (GeV/c)");
      generatorEtaYieldsPtCut->SetYTitle("Counts");
      
      (generatorEtaYieldsPtCut->GetXaxis())->SetLabelSize(0.045);
      (generatorEtaYieldsPtCut->GetXaxis())->SetTitleOffset(1.);
      (generatorEtaYieldsPtCut->GetXaxis())->SetTitleSize(0.045);
      (generatorEtaYieldsPtCut->GetXaxis())->CenterTitle();
      (generatorEtaYieldsPtCut->GetYaxis())->SetLabelSize(0.045);
      (generatorEtaYieldsPtCut->GetYaxis())->SetTitleOffset(1.2);
      (generatorEtaYieldsPtCut->GetYaxis())->SetTitleSize(0.045);
      (generatorEtaYieldsPtCut->GetYaxis())->CenterTitle();
      
      TH1D *generatorEtaYieldsPtCutNoConvert = new TH1D("generatorEtaYieldsPtCutNoConvert", "Generator #eta(547.5 MeV) Yields(p_{T}) Energy and NoConversion Cut", nBinsOneDimension, 0.0, 5.0);
      generatorEtaYieldsPtCutNoConvert->SetXTitle("p_{T} (GeV/c)");
      generatorEtaYieldsPtCutNoConvert->SetYTitle("Counts");
      
      (generatorEtaYieldsPtCutNoConvert->GetXaxis())->SetLabelSize(0.045);
      (generatorEtaYieldsPtCutNoConvert->GetXaxis())->SetTitleOffset(1.);
      (generatorEtaYieldsPtCutNoConvert->GetXaxis())->SetTitleSize(0.045);
      (generatorEtaYieldsPtCutNoConvert->GetXaxis())->CenterTitle();
      (generatorEtaYieldsPtCutNoConvert->GetYaxis())->SetLabelSize(0.045);
      (generatorEtaYieldsPtCutNoConvert->GetYaxis())->SetTitleOffset(1.2);
      (generatorEtaYieldsPtCutNoConvert->GetYaxis())->SetTitleSize(0.045);
      (generatorEtaYieldsPtCutNoConvert->GetYaxis())->CenterTitle();
      
      TH1D *generatorPi0RatioPtCut = new TH1D("generatorPi0RatioPtCut", "Generator #pi^{0} Ratio(p_{T}) After Cuts", nBinsOneDimension, 0.0, 5.0);
      generatorPi0RatioPtCut->SetXTitle("p_{T} (GeV/c)");
      generatorPi0RatioPtCut->SetYTitle("Ratios");
      
      (generatorPi0RatioPtCut->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0RatioPtCut->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0RatioPtCut->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0RatioPtCut->GetXaxis())->CenterTitle();
      (generatorPi0RatioPtCut->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0RatioPtCut->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0RatioPtCut->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0RatioPtCut->GetYaxis())->CenterTitle();
      
      TH1D *generatorPi0RatioPtCutNoConvert = new TH1D("generatorPi0RatioPtCutNoConvert", "Generator #pi^{0} Ratio(p_{T}) Energy and NoConversion Cut", nBinsOneDimension, 0.0, 5.0);
      generatorPi0RatioPtCutNoConvert->SetXTitle("p_{T} (GeV/c)");
      generatorPi0RatioPtCutNoConvert->SetYTitle("Ratios");
      
      (generatorPi0RatioPtCutNoConvert->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0RatioPtCutNoConvert->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0RatioPtCutNoConvert->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0RatioPtCutNoConvert->GetXaxis())->CenterTitle();
      (generatorPi0RatioPtCutNoConvert->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0RatioPtCutNoConvert->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0RatioPtCutNoConvert->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0RatioPtCutNoConvert->GetYaxis())->CenterTitle();
      
      TH1D *generatorEtaRatioPtCut = new TH1D("generatorEtaRatioPtCut", "Generator #eta(547.5 MeV) Ratio(p_{T}) After Cuts", nBinsOneDimension, 0.0, 5.0);
      generatorEtaRatioPtCut->SetXTitle("p_{T} (GeV/c)");
      generatorEtaRatioPtCut->SetYTitle("Ratios");
      
      (generatorEtaRatioPtCut->GetXaxis())->SetLabelSize(0.045);
      (generatorEtaRatioPtCut->GetXaxis())->SetTitleOffset(1.);
      (generatorEtaRatioPtCut->GetXaxis())->SetTitleSize(0.045);
      (generatorEtaRatioPtCut->GetXaxis())->CenterTitle();
      (generatorEtaRatioPtCut->GetYaxis())->SetLabelSize(0.045);
      (generatorEtaRatioPtCut->GetYaxis())->SetTitleOffset(1.2);
      (generatorEtaRatioPtCut->GetYaxis())->SetTitleSize(0.045);
      (generatorEtaRatioPtCut->GetYaxis())->CenterTitle();
      
      TH1D *generatorEtaRatioPtCutNoConvert = new TH1D("generatorEtaRatioPtCutNoConvert", "Generator #eta(547.5 MeV) Ratio(p_{T}) Energy and NoConversion Cut", nBinsOneDimension, 0.0, 5.0);
      generatorEtaRatioPtCutNoConvert->SetXTitle("p_{T} (GeV/c)");
      generatorEtaRatioPtCutNoConvert->SetYTitle("Ratios");
      
      (generatorEtaRatioPtCutNoConvert->GetXaxis())->SetLabelSize(0.045);
      (generatorEtaRatioPtCutNoConvert->GetXaxis())->SetTitleOffset(1.);
      (generatorEtaRatioPtCutNoConvert->GetXaxis())->SetTitleSize(0.045);
      (generatorEtaRatioPtCutNoConvert->GetXaxis())->CenterTitle();
      (generatorEtaRatioPtCutNoConvert->GetYaxis())->SetLabelSize(0.045);
      (generatorEtaRatioPtCutNoConvert->GetYaxis())->SetTitleOffset(1.2);
      (generatorEtaRatioPtCutNoConvert->GetYaxis())->SetTitleSize(0.045);
      (generatorEtaRatioPtCutNoConvert->GetYaxis())->CenterTitle();
			
      for (Long64_t i=0; i<entriesToProcess; i++) {
				
	hTree->GetEntry(i);
				
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " and nMesonSize = " << nMesonSize;
	}
				
	for(int jMeson=0; jMeson< nMesonSize; jMeson++) {
	  if(fabs(etaMeson[jMeson]) < 1.49 && daughtersFromMeson[jMeson] == 2) {
	    if(pdgIdMeson[jMeson] == 111) {
	      generatorPi0YieldsPt->Fill(ptMeson[jMeson]);
	      if(ptDecay1Meson[jMeson] > 0.30 && ptDecay2Meson[jMeson] > 0.30) {
		generatorPi0YieldsPtCut->Fill(ptMeson[jMeson]);
		if(convertDecay1Meson[jMeson] == 0 && convertDecay2Meson[jMeson] == 0) {
		  generatorPi0YieldsPtCutNoConvert->Fill(ptMeson[jMeson]);
		} // check on no conversion
	      } // check on energy threshild
	    } //  check for pi0
						
	    if(pdgIdMeson[jMeson] == 221) {
	      generatorEtaYieldsPt->Fill(ptMeson[jMeson]);
	      if(ptDecay1Meson[jMeson] > 0.30 && ptDecay2Meson[jMeson] > 0.30) {
		generatorEtaYieldsPtCut->Fill(ptMeson[jMeson]);
		if(convertDecay1Meson[jMeson] == 0 && convertDecay2Meson[jMeson] == 0) {
		  generatorEtaYieldsPtCutNoConvert->Fill(ptMeson[jMeson]);
		} // check on no conversion
	      } // check on energy threshold
	    } //  check for eta meson
						
	  } // check on pseudorapidity value and 2-daughter branch
					
	} // loop over mesons
				
      } // loop over tree entries
      
      for(int iBin=1; iBin<=nBinsOneDimension; iBin++) {
        
	float denominator = generatorPi0YieldsPt->GetBinContent(iBin);
	if(denominator > 0.0) {
	  float numerator = generatorPi0YieldsPtCut->GetBinContent(iBin);
	  generatorPi0RatioPtCut->SetBinContent(iBin,numerator/denominator);
	  numerator = generatorPi0YieldsPtCutNoConvert->GetBinContent(iBin);
	  generatorPi0RatioPtCutNoConvert->SetBinContent(iBin,numerator/denominator);
	} // check on non-zero denominator for pi0
        
	denominator = generatorEtaYieldsPt->GetBinContent(iBin);
	if(denominator > 0.0) {
	  float numerator = generatorEtaYieldsPtCut->GetBinContent(iBin);
	  generatorEtaRatioPtCut->SetBinContent(iBin,numerator/denominator);
	  numerator = generatorEtaYieldsPtCutNoConvert->GetBinContent(iBin);
	  generatorEtaRatioPtCutNoConvert->SetBinContent(iBin,numerator/denominator);
	} // check on non-zero denominator
      } // loop over pT bins
      
      c1->Divide(2,2);
      
      c1->cd(1);
      generatorPi0YieldsPt->SetStats(0);
      generatorPi0YieldsPt->SetLineColor(kBlue);
      generatorPi0YieldsPt->SetMinimum(1.);
      generatorPi0YieldsPt->Draw();
      generatorPi0YieldsPtCut->SetStats(0);
      generatorPi0YieldsPtCut->SetLineColor(kRed);
      generatorPi0YieldsPtCut->Draw("same");
      generatorPi0YieldsPtCutNoConvert->SetStats(0);
      generatorPi0YieldsPtCutNoConvert->SetLineColor(kGreen);
      generatorPi0YieldsPtCutNoConvert->Draw("same");
      (c1->cd(1))->SetLogy();
      (c1->cd(1))->SetGrid();
      
      c1->cd(2);
      generatorEtaYieldsPt->SetStats(0);
      generatorEtaYieldsPt->SetLineColor(kBlue);
      generatorEtaYieldsPt->SetMinimum(1.);
      generatorEtaYieldsPt->Draw();
      generatorEtaYieldsPtCut->SetStats(0);
      generatorEtaYieldsPtCut->SetLineColor(kRed);
      generatorEtaYieldsPtCut->Draw("same");
      generatorEtaYieldsPtCutNoConvert->SetStats(0);
      generatorEtaYieldsPtCutNoConvert->SetLineColor(kGreen);
      generatorEtaYieldsPtCutNoConvert->Draw("same");
      (c1->cd(2))->SetLogy();
      (c1->cd(2))->SetGrid();
      
      c1->cd(3);
      generatorPi0RatioPtCut->SetStats(0);
      generatorPi0RatioPtCut->SetLineColor(kRed);
      generatorPi0RatioPtCut->SetMaximum(1.2);
      generatorPi0RatioPtCut->Draw();
      generatorPi0RatioPtCutNoConvert->SetStats(0);
      generatorPi0RatioPtCutNoConvert->SetLineColor(kGreen);
      generatorPi0RatioPtCutNoConvert->Draw("same");
      (c1->cd(3))->SetGrid();
      
      c1->cd(4);
      generatorEtaRatioPtCut->SetStats(0);
      generatorEtaRatioPtCut->SetLineColor(kRed);
      generatorEtaRatioPtCut->SetMaximum(1.2);
      generatorEtaRatioPtCut->Draw();
      generatorEtaRatioPtCutNoConvert->SetStats(0);
      generatorEtaRatioPtCutNoConvert->SetLineColor(kGreen);
      generatorEtaRatioPtCutNoConvert->Draw("same");
      (c1->cd(4))->SetGrid();
      
    } // iOption = 27, pT before and after 300 MeV/c cut for decay photons
	  
    if(iOption == 28 || iOption == -28) { // plotting photon conversion spectra using photon variables
      c1->Divide(2,1);
		  
      //
      // Initial results indicate a -3.0e-04*zPrimaryVtx correction factor is needed as a function of zPrimaryVtx
      //
      TH1D *etaPhoton = new TH1D("etaPhoton", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhoton = new TH1D("ptPhoton", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
		  
      TH1D *etaPhotonNoConv = new TH1D("etaPhotonNoConv", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhotonNoConv = new TH1D("ptPhotonNoConv", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
		  
      TH1D *etaPhotonNoConvLine = new TH1D("etaPhotonNoConv", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhotonNoConvLine = new TH1D("ptPhotonNoConv", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
		  
      TH1D *etaPhotonConv = new TH1D("etaPhotonConv", "Primary photon #eta according to conversion history", 150, -1.50, +1.50);
      TH1D *ptPhotonConv = new TH1D("ptPhotonConv", "Primary photon p_{T} according to conversion history", 150, 0.0, 6.0);
		  
      int countPrimaryPhotons = 0;
      int countNoConvPhotons = 0;
      int countConvPhotons = 0;
		  
      for (Long64_t i=0; i<entriesToProcess; i++) {
			  
	hTree->GetEntry(i);
			  
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
	  cout << "; current primary count photons = " << countPrimaryPhotons;
	  cout << ", no conversion photons " << countNoConvPhotons << " and conversion photons " << countConvPhotons;
	  cout << ", nPhotonSize " << nPhotonSize;
	}
			  
	for(int jPhoton=0; jPhoton<nPhotonSize; jPhoton++) {
				  
	  float etaPhotonValue = etaPhotonGen[jPhoton];
	  float ptPhotonValue = ptPhotonGen[jPhoton];
          
	  if(((iOption == 28 && motherPdgIdPhotonGen[jPhoton] == 111) ||
	      (iOption == -28 && motherPdgIdPhotonGen[jPhoton] == 221)) &&
	     fabs(etaPhotonValue) < 1.49  && ptPhotonValue > 0.3) {
					  
	    countPrimaryPhotons++;
            
	    etaPhoton->Fill(etaPhotonValue);
	    ptPhoton->Fill(ptPhotonValue);
					  
	    if(convertPhotonGen[jPhoton] == 0) {
	      etaPhotonNoConv->Fill(etaPhotonValue);
	      ptPhotonNoConv->Fill(ptPhotonValue);
	      etaPhotonNoConvLine->Fill(etaPhotonValue);
	      ptPhotonNoConvLine->Fill(ptPhotonValue);
	      countNoConvPhotons++;
	    }
	    else {
	      etaPhotonConv->Fill(etaPhotonValue);
	      ptPhotonConv->Fill(ptPhotonValue);
	      countConvPhotons++;
	    }
					  
	  }  // check for parent meson
				  
	} // loop over photonStore entries
			  
      } // loop over entries
		  
      c1->cd(1);
      float histogramMaximum = 1.2*etaPhoton->GetMaximum();
      etaPhoton->SetMaximum(histogramMaximum);
      etaPhoton->SetStats(0);
      etaPhoton->SetFillColor(kBlue);
      etaPhoton->SetXTitle("#eta value for primary vertex photon");
      etaPhoton->SetYTitle("Counts per 0.02 #eta bin size");
		  
      (etaPhoton->GetXaxis())->SetLabelSize(0.035);
      (etaPhoton->GetXaxis())->SetTitleOffset(0.8);
      (etaPhoton->GetXaxis())->SetTitleSize(0.040);
      (etaPhoton->GetXaxis())->CenterTitle();
      (etaPhoton->GetYaxis())->SetLabelSize(0.030);
      (etaPhoton->GetYaxis())->SetTitleOffset(1.2);
      (etaPhoton->GetYaxis())->SetTitleSize(0.040);
      (etaPhoton->GetYaxis())->CenterTitle();
		  
      etaPhotonNoConv->SetFillColor(kGreen);
      etaPhotonNoConvLine->SetLineColor(kGreen);
      etaPhotonNoConvLine->SetLineWidth(2);
      etaPhotonConv->SetFillColor(kRed);
		  
      etaPhoton->SetMinimum(0);
      etaPhoton->Draw();
		  
      etaPhotonNoConv->Draw("same");
      etaPhotonConv->Draw("same");
      etaPhotonNoConvLine->Draw("same");
		  
      (c1->cd(1))->SetGrid();
		  
      TLatex *runLabel1a = new TLatex(-0.75, 0.95*histogramMaximum, "MC pPb for 2013");
      TLatex *runLabel1b;
      if(iOption == 28)
	runLabel1b = new TLatex(-0.75, 0.90*histogramMaximum, "#pi^{0} parent meson");
      else
	runLabel1b = new TLatex(-0.95, 0.90*histogramMaximum, "#eta(547.5 MeV) parent meson");
		  
      runLabel1a->SetTextColor(kBlack);
      runLabel1a->SetTextSize(0.05);
      runLabel1a->Draw();
		  
      runLabel1b->SetTextColor(kBlack);
      runLabel1b->SetTextSize(0.045);
      runLabel1b->Draw();
		  
      c1->cd(2);
      ptPhoton->SetStats(0);
      ptPhoton->SetFillColor(kBlue);
      ptPhoton->SetXTitle("p_{T} value for primary vertex photon (GeV/c)");
      ptPhoton->SetYTitle("Counts per 0.04 GeV/c bin size");
		  
      ptPhotonNoConv->SetFillColor(kGreen);
      ptPhotonNoConvLine->SetLineColor(kGreen);
      ptPhotonNoConvLine->SetLineWidth(2);
      ptPhotonConv->SetFillColor(kRed);
		  
      // ptPhoton->SetMaximum(100000.);
      ptPhoton->SetMinimum(1.);
      ptPhoton->Draw();
		  
      (ptPhoton->GetXaxis())->SetLabelSize(0.035);
      (ptPhoton->GetXaxis())->SetTitleOffset(0.8);
      (ptPhoton->GetXaxis())->SetTitleSize(0.040);
      (ptPhoton->GetXaxis())->CenterTitle();
      (ptPhoton->GetYaxis())->SetLabelSize(0.035);
      (ptPhoton->GetYaxis())->SetTitleOffset(1.2);
      (ptPhoton->GetYaxis())->SetTitleSize(0.040);
      (ptPhoton->GetYaxis())->CenterTitle();
		  
      ptPhotonNoConv->Draw("same");
      ptPhotonConv->Draw("same");
      ptPhotonNoConvLine->Draw("same");
		  
      (c1->cd(2))->SetGrid();
      (c1->cd(2))->SetLogy();
		  
      return;
		  
    } // iOption = 28, plotting photon conversion spectra, using photon variables
		
    if(iOption == 29 || iOption == -29 || // Produces a 2x4 panel mass plots figure for the pT-binned pi0 (eta) yields
       iOption == 30 || iOption == -30) { // Produces a 2x4 panel pT resolution plots figure for the pT-binned pi0 (eta) yields
      
      TH1D *recoMassPt[13];
      TH1D *recoResolutionPt[13];
      char *histogramName = new char[200];
      char *histogramTitle = new char[200];
			
      int pdgIdMesonChoice = 111;   // default for pi0
			
      if(iOption == -29 || iOption == -30) {
				
	pdgIdMesonChoice = 221;
				
	for(int kPt=0; kPt<nBinsPt; kPt++) {
					
	  sprintf(histogramName, "etaMassPtBin%d", kPt);
	  sprintf(histogramTitle, "#eta reco mass for %3.1f<p_{T}<%3.1f GeV/c", lowPtBin[kPt], highPtBin[kPt]);
	  recoMassPt[kPt] = new TH1D(histogramName, histogramTitle, 75, 0.30, 0.90);
	  sprintf(histogramName, "etaResolutionPtBin%d", kPt);
	  sprintf(histogramTitle, "#eta p_{T} resolution for %3.1f<p_{T}<%3.1f GeV/c", lowPtBin[kPt], highPtBin[kPt]);
	  recoResolutionPt[kPt] = new TH1D(histogramName, histogramTitle, 50, -0.50, 0.50);
					
	} // loop over pt bins
      } // check for eta choice
      
      if(iOption == 29 || iOption == 30) {
	for(int kPt=0; kPt<nBinsPt; kPt++) {
          
	  sprintf(histogramName, "pi0MassPtBin%d", kPt);
	  sprintf(histogramTitle, "#pi^{0} reco mass for %3.1f<p_{T}<%3.1f GeV/c", lowPtBin[kPt], highPtBin[kPt]);
	  recoMassPt[kPt] = new TH1D(histogramName, histogramTitle, 75, 0.0, 0.30);
          
	  sprintf(histogramName, "pi0ResolutionPtBin%d", kPt);
	  sprintf(histogramTitle, "#pi^{0} p_{T} resolution for %3.1f<p_{T}<%3.1f GeV/c", lowPtBin[kPt], highPtBin[kPt]);
	  recoResolutionPt[kPt] = new TH1D(histogramName, histogramTitle, 50, -0.50, 0.50);
          
	} // loop over pt bins
      } // check for pi0 choice
      
      int countSkippedPt = 0;
      int countGeneratorMesons = 0;
      int countNullPtMeasured = 0;
      int countLowPtMeasured = 0;
      int countAcceptedPtMeasured = 0;
			
      int countSuppressedMatches = 0;
      int countMissingMerge = 0;
      int countMissingAngleMatch = 0;
      int countLowEnergySkipped = 0;
      int countSkippedDecays = 0;
			
      float minimumPtMeson = 0.80*lowPtBin[0];
			
      for (Long64_t i=0; i<entriesToProcess; i++) {
				
	hTree->GetEntry(i);
				
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " and nMesonSize = " << nMesonSize;
	}
				
	for(int jMeson=0; jMeson< nMesonSize; jMeson++) {
	  if(pdgIdMesonChoice != pdgIdMeson[jMeson] ||  ptMeson[jMeson] < minimumPtMeson || fabs(etaMeson[jMeson]) > 1.49 || daughtersFromMeson[jMeson] != 2)
	    continue;
					
	  countGeneratorMesons++;
					
	  float recoMassValue = massRecoMeson[jMeson];
          
	  int kPtIndex = -1;
	  float ptMeasured = ptRecoMeson[jMeson];
	  bool skipThisDecay = false;
	  if(useEnergyCorrection) {
	    int jMerge1 = mergeDecay1Meson[jMeson];  // need to check what is the efficiency for getting a match with mergedTrackTruth
	    int jMerge2 = mergeDecay2Meson[jMeson];
	    if(jMerge1 >= 0 && jMerge1 < mergedTrackTruthSize &&
	       jMerge2 >= 0 && jMerge2 < mergedTrackTruthSize &&
	       bestEcalAngleMatch[jMerge1] >= 0.0 && bestEcalAngleMatch[jMerge1] < 0.03 &&
	       bestEcalAngleMatch[jMerge2] >= 0.0 && bestEcalAngleMatch[jMerge2] < 0.03) {
	      int jClu1 = bestEcalIndexMatch[jMerge1];
	      int jClu2 = bestEcalIndexMatch[jMerge2];
              
	      int crystalIndex1 = nCryClu[jClu1];
	      int crystalIndex2 = nCryClu[jClu2];
	      if(useClusterCrystalLimit && (crystalIndex1 < lowCrystalLimit ||
					    crystalIndex1 > highCrystalLimit ||
					    crystalIndex2 < lowCrystalLimit ||
					    crystalIndex2 > highCrystalLimit)) {
		skipThisDecay = true;
	      }
	      crystalIndex1--;  // get to 0 - 8 range
	      crystalIndex2--;  // get to 0 - 8 range
              
	      int nGoodRecoMatch1 = nGoodRecoMatches[jClu1];
	      int nGoodRecoMatch2 = nGoodRecoMatches[jClu2];
							
	      if(useTrackMatchSuppression && (nGoodRecoMatch1 > 0 || nGoodRecoMatch2 > 0)) {
		skipThisDecay = true;
		countSuppressedMatches++;
	      }
							
	      float ptEcalOld1 = bestEcalPtMatch[jMerge1];
	      float ptEcalOld2 = bestEcalPtMatch[jMerge2];
              
	      float ecalEta1 = bestEcalDEtaMatch[jMerge1] + etaMerge[jMerge1];
	      float theta1 = 2.0*atan(exp(-ecalEta1));
	      float sinTheta1 = sin(theta1);
              
	      float ecalEta2 = bestEcalDEtaMatch[jMerge2] + etaMerge[jMerge2];
	      float theta2 = 2.0*atan(exp(-ecalEta2));
	      float sinTheta2 = sin(theta2);
              
	      float energy1 = ptEcalOld1/sinTheta1;
	      float energy2 = ptEcalOld2/sinTheta2;
              
	      if(energy1 > lowEnergyCutParameter && energy2 > lowEnergyCutParameter) {
								
		float cosTheta1 = cos(theta1);
		float phi1 = bestEcalPhiMatch[jMerge1];
		float cosPhi1 = cos(phi1);
		float sinPhi1 = sin(phi1);
								
		float cosTheta2 = cos(theta2);
		float phi2 = bestEcalPhiMatch[jMerge2];
		float cosPhi2 = cos(phi2);
		float sinPhi2 = sin(phi2);
                
		energy1 = crystalCorrectionFunction(crystalIndex1, energy1);
		energy2 = crystalCorrectionFunction(crystalIndex2, energy2);
                
		float ptEcalNew1 = energy1*sinTheta1;
		float pxEcalNew1 = ptEcalNew1*cosPhi1;
		float pyEcalNew1 = ptEcalNew1*sinPhi1;
								
		float ptEcalNew2 = energy2*sinTheta2;
		float pxEcalNew2 = ptEcalNew2*cosPhi2;
		float pyEcalNew2 = ptEcalNew2*sinPhi2;
								
		ptMeasured = sqrt((pxEcalNew1+pxEcalNew2)*(pxEcalNew1+pxEcalNew2) +
				  (pyEcalNew1+pyEcalNew2)*(pyEcalNew1+pyEcalNew2));
								
		float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
		float recoMassTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
		if(recoMassTest > 0.0)
		  recoMassValue = sqrt(recoMassTest);
								
	      } // check on pT value for each cluster
	      else {
		countLowEnergySkipped++;
		skipThisDecay = true; // an ECAL cluster energy is too low
	      }
	    } // check on both entries in the mergedTrackTruth collection with good angle matching
	    else {
	      if(jMerge1 < 0 || jMerge1 >= mergedTrackTruthSize ||
		 jMerge2 < 0 || jMerge2 >= mergedTrackTruthSize) {
		countMissingMerge++;
	      }
	      else {
		countMissingAngleMatch++;
	      }
	      skipThisDecay = true; // missing an entry in the merged track truth collection
	    }
						
	  } // check on using pT correction
					
	  if(skipThisDecay) {
	    countSkippedDecays++;
	    continue;
	  }
					
	  if(ptMeasured > 0.0) {
						
	    if(ptMeasured < lowPtBin[0])
	      countLowPtMeasured++;
						
	    for (int kPt=0; kPt<nBinsPt; kPt++) {
	      if(ptMeasured >= lowPtBin[kPt] && ptMeasured < highPtBin[kPt]) {
		kPtIndex = kPt;
		countAcceptedPtMeasured++;
		break;
	      }
	    } // look for pT bin index
	  }
	  else {
	    countNullPtMeasured++;
	  }
					
	  if(kPtIndex == -1) {
	    countSkippedPt++;
	    continue;
	  } // safety check;
					
	  float ptResolution = (ptMeson[jMeson] - ptMeasured)/ptMeson[jMeson];
	  if(fabs(ptResolution) < 0.5)
	    recoResolutionPt[kPtIndex]->Fill(ptResolution);
					
	  recoMassPt[kPtIndex]->Fill(recoMassValue);
					
	} // loop over mesons
      } // loop over entries
			
      cout << "\n Number of generator mesons = " << countGeneratorMesons;
      cout << "\n Number of accepted ptMeasured values = " << countAcceptedPtMeasured;
      cout << "\n Number of null ptMeasured values = " << countNullPtMeasured;
      cout << "\n Number of low ptMeasured values = " << countLowPtMeasured;
      cout << "\n Number of skipped ptMeasured values = " << countSkippedPt;
			
      cout << "\n\n Number of suppressed ECAL-track matches = " << countSuppressedMatches;
      cout << "\n Number of missing merge matches = " << countMissingMerge;
      cout << ",  number of missing angle matches = " << countMissingAngleMatch;
      cout << "\n Number of decays with one or both photons too low in energy = " << countLowEnergySkipped;
      cout << ", with low energy cut at " << lowEnergyCutParameter << " GeV/c";
      cout << "\n Number of skipped decays = " << countSkippedDecays;
			
      cout << endl;
			
      c1->Divide(2,5);
      for(int kPt=0; kPt<10; kPt++) {
        
	c1->cd(kPt+1);
        
	if(iOption == 29 || iOption == -29)
	  recoMassPt[kPt]->Fit("gaus", "", "", 0.08, 0.19);
        
	if(iOption == 30 || iOption == -30)
	  recoResolutionPt[kPt]->Fit("gaus", "", "", -0.4, 0.4);
        
	(c1->cd(kPt+1))->SetGrid();
        
      }
      
    } // iOption = 29 (-29), produces a 2x4 panel figure for the pT-binned pi0 (eta) yields
    
    
    if(iOption == 31 || iOption == -31 || iOption == 32 || iOption == -32 || iOption == 33 ||  iOption == -33 || iOption == 53 || iOption == 331 ||
       (iOption >= 54 && iOption <= 60)|| iOption == 61 || (iOption >= 70 && iOption <= 72) || // 2x2 panel of the mass spectra for pT bins 1.0-1.5, 1.5-2.0, 2.0-2.5, and 2.5-3.0
       (iOption >= 334 && iOption <= 337)) { // pair correlations histograms for RECO
      
      //
      // iOption = 31 -> same events
      // iOption = 32 -> mixed events
      // iOption = 33 -> same and normalized mixed events
      // iOption = -31 -> plot the cluster (weighted time - seed time) information
      // iOption = -32 -> plot the cluster time information
      // iOption = -33 -> plot the cluster time information
      // iOption = 331 produce efficiency table using dynamically reconstructed pi0 with same parent tag and gen particle information in simTrack
      //
      // iOption = 61 -> produce foreground and conversion suppressed reco eta distributions in four low pT bins
      //

      char *histogramName = new char[200];
      char *histogramTitle = new char[200];
      
      //
      // Repeat of efficiency histograms from 231 option
      //
      int nBinsOneDimension = 100;
 
      Float_t etabinsy[11]  = { -1.5, -1.2, -0.9, -0.6, -0.3, 0, 0.3, 0.6, 0.9, 1.2, 1.5};
      Float_t ptbinsx[16]  = { 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.4, 2.8, 3.2, 4.0, 5.0}; 

      TH2D *generatorPi0Yields = new TH2D("generatorPi0Yields", "Generator #pi^{0} Yields(p_{T}, #eta)", 15, ptbinsx, 10, etabinsy);
      
      generatorPi0Yields->SetXTitle("p_{T} (GeV/c)");
      generatorPi0Yields->SetYTitle("#eta ");
      
      (generatorPi0Yields->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0Yields->GetXaxis())->SetTitleOffset(1.6);
      (generatorPi0Yields->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0Yields->GetXaxis())->CenterTitle();
      (generatorPi0Yields->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0Yields->GetYaxis())->SetTitleOffset(1.5);
      (generatorPi0Yields->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0Yields->GetYaxis())->CenterTitle();
      
      TH2D *reconstructedPi0Yields = new TH2D("reconstructedPi0Yields", "Reconstructed #pi^{0} Yields(p_{T}, #eta)", 15, ptbinsx, 10, etabinsy);
      
      reconstructedPi0Yields->SetXTitle("p_{T} (GeV/c)");
      reconstructedPi0Yields->SetYTitle("#eta");
      
      (reconstructedPi0Yields->GetXaxis())->SetLabelSize(0.045);
      (reconstructedPi0Yields->GetXaxis())->SetTitleOffset(1.6);
      (reconstructedPi0Yields->GetXaxis())->SetTitleSize(0.045);
      (reconstructedPi0Yields->GetXaxis())->CenterTitle();
      (reconstructedPi0Yields->GetYaxis())->SetLabelSize(0.045);
      (reconstructedPi0Yields->GetYaxis())->SetTitleOffset(1.6);
      (reconstructedPi0Yields->GetYaxis())->SetTitleSize(0.045);
      (reconstructedPi0Yields->GetYaxis())->CenterTitle();
      
      TH2D *efficiencyPi0Yields = new TH2D("efficiencyPi0Yields", "Efficiency(p_{T}, #eta) for #pi^{0} Reconstruction", 15, ptbinsx, 10, etabinsy);
      efficiencyPi0Yields->SetXTitle("p_{T} (GeV/c)");
      efficiencyPi0Yields->SetYTitle("#eta");
      
      (efficiencyPi0Yields->GetXaxis())->SetLabelSize(0.045);
      (efficiencyPi0Yields->GetXaxis())->SetTitleOffset(1.6);
      (efficiencyPi0Yields->GetXaxis())->SetTitleSize(0.045);
      (efficiencyPi0Yields->GetXaxis())->CenterTitle();
      (efficiencyPi0Yields->GetYaxis())->SetLabelSize(0.045);
      (efficiencyPi0Yields->GetYaxis())->SetTitleOffset(1.6);
      (efficiencyPi0Yields->GetYaxis())->SetTitleSize(0.045);
      (efficiencyPi0Yields->GetYaxis())->CenterTitle();

      TH1D *generatorPi0YieldsPt = new TH1D("generatorPi0YieldsPt", "Generator #pi^{0} Yields(p_{T})", nBinsOneDimension, 0.5, 5.0);
      generatorPi0YieldsPt->SetXTitle("p_{T} (GeV/c)");
      generatorPi0YieldsPt->SetYTitle("Counts");
      
      (generatorPi0YieldsPt->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPt->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0YieldsPt->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPt->GetXaxis())->CenterTitle();
      (generatorPi0YieldsPt->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsPt->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0YieldsPt->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsPt->GetYaxis())->CenterTitle();
      
      TH1D *generatorPi0YieldsEta = new TH1D("generatorPi0YieldsEta", "Generator #pi^{0} Yields(#eta)", nBinsOneDimension, -1.5, 1.5);
      generatorPi0YieldsEta->SetXTitle("#eta");
      generatorPi0YieldsEta->SetYTitle("Counts");
      
      (generatorPi0YieldsEta->GetXaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsEta->GetXaxis())->SetTitleOffset(1.);
      (generatorPi0YieldsEta->GetXaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsEta->GetXaxis())->CenterTitle();
      (generatorPi0YieldsEta->GetYaxis())->SetLabelSize(0.045);
      (generatorPi0YieldsEta->GetYaxis())->SetTitleOffset(1.2);
      (generatorPi0YieldsEta->GetYaxis())->SetTitleSize(0.045);
      (generatorPi0YieldsEta->GetYaxis())->CenterTitle();
      
      TH1D *reconstructedPi0YieldsPt = new TH1D("reconstructedPi0YieldsPt", "reconstructed #pi^{0} Yields(p_{T})", nBinsOneDimension, 0.5, 5.0);
      reconstructedPi0YieldsPt->SetXTitle("p_{T} (GeV/c)");
      reconstructedPi0YieldsPt->SetYTitle("Counts");
      
      TH1D *reconstructedPi0YieldsEta = new TH1D("reconstructedPi0YieldsEta", "reconstructed #pi^{0} Yields(#eta)", nBinsOneDimension, -1.5, 1.5);
      reconstructedPi0YieldsEta->SetXTitle("#eta)");
      reconstructedPi0YieldsEta->SetYTitle("Counts");
      
      TH1D *efficiencyPi0YieldsPt = new TH1D("efficiencyPi0YieldsPt", " #pi^{0} efficiency(p_{T})", nBinsOneDimension, 0.5, 5.0);
      efficiencyPi0YieldsPt->SetXTitle("p_{T} (GeV/c)");
      efficiencyPi0YieldsPt->SetYTitle("Efficiency (Reco/Gen)");
      
      TH1D *efficiencyPi0YieldsEta = new TH1D("efficiencyPi0YieldsEta", " #pi^{0} efficiency(#eta)", nBinsOneDimension, -1.5, 1.5);
      efficiencyPi0YieldsEta->SetXTitle("#eta");
      efficiencyPi0YieldsEta->SetYTitle("Efficiency (Reco/Gen)");
      
      (efficiencyPi0YieldsPt->GetXaxis())->SetLabelSize(0.045);
      (efficiencyPi0YieldsPt->GetXaxis())->SetTitleOffset(1.);
      (efficiencyPi0YieldsPt->GetXaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsPt->GetXaxis())->CenterTitle();
      (efficiencyPi0YieldsPt->GetYaxis())->SetLabelSize(0.040);
      (efficiencyPi0YieldsPt->GetYaxis())->SetTitleOffset(1.1);
      (efficiencyPi0YieldsPt->GetYaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsPt->GetYaxis())->CenterTitle();
      
      (efficiencyPi0YieldsEta->GetXaxis())->SetLabelSize(0.045);
      (efficiencyPi0YieldsEta->GetXaxis())->SetTitleOffset(1.);
      (efficiencyPi0YieldsEta->GetXaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsEta->GetXaxis())->CenterTitle();
      (efficiencyPi0YieldsEta->GetYaxis())->SetLabelSize(0.040);
      (efficiencyPi0YieldsEta->GetYaxis())->SetTitleOffset(1.1);
      (efficiencyPi0YieldsEta->GetYaxis())->SetTitleSize(0.045);
      (efficiencyPi0YieldsEta->GetYaxis())->CenterTitle();

      //
      // Looking at K0-short
      //

      const double kaonResidualWindow = 0.10;
      const double kaonResidualMaxR = 10.0;
      const double kaonResidualMinE = 0.2;
      const double kaonResidualMaxE = 5.0;
      const double kaonResidualMinEta = -1.4;
      const double kaonResidualMaxEta = +1.4;

      const int kaonResidualBins = 100;
  
      TH2D *dPhi_dEtaKaon = new TH2D("dPhi_dEtaKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#phi vs #Delta#eta", kaonResidualBins, -kaonResidualWindow, kaonResidualWindow, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow);    // kaon residuals
      TH1D *hBestAngleMatchKaon = new TH1D("hBestAngleMatch", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #sqrt{(#Delta#eta)^{2} + (#Delta#phi)^{2}}", kaonResidualBins, 0.0, kaonResidualWindow); // kaon residuals
      TH1D *hBestPhiMatchKaon = new TH1D("hBestPhiMatch", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#phi", kaonResidualBins, -kaonResidualWindow, kaonResidualWindow); // kaon residuals
      TH1D *hBestEtaMatchKaon = new TH1D("hBestEtaMatch", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#eta", kaonResidualBins, -kaonResidualWindow, kaonResidualWindow); // kaon residuals

      TH2D *dPhi_dSimEtaKaon = new TH2D("dPhi_dSimEtaKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#phi vs #eta-Sim", kaonResidualBins, kaonResidualMinEta, kaonResidualMaxEta, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow);
      TH2D *dEta_dSimEtaKaon = new TH2D("dEta_dSimEtaKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#eta vs #eta-Sim", kaonResidualBins, kaonResidualMinEta, kaonResidualMaxEta, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow);

      TH2D *dPhi_dZKaon = new TH2D("dPhi_dZKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#phi vs Z-Vertex", kaonResidualBins, -15.0, 15.0, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow);    // kaon residuals
      TH2D *dEta_dZKaon = new TH2D("dEta_dZKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#eta vs Z-Vertex", kaonResidualBins, -15.0, 15.0, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow);    // kaon residuals
      TH2D *dPhi_dRKaon = new TH2D("dPhi_dRKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#phi vs R-Vertex", kaonResidualBins,  0.0, kaonResidualMaxR, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow);    // kaon re
      TH2D *dEta_dRKaon = new TH2D("dEta_dRKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#phi vs R-Vertex", kaonResidualBins,  0.0, kaonResidualMaxR, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow);    // kaon re
      TH2D *dPhi_dEKaon = new TH2D("dPhi_dEKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#phi vs Energy", kaonResidualBins, kaonResidualMinE, kaonResidualMaxE, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow); // kaon residuals
      TH2D *dEta_dEKaon = new TH2D("dEta_dEKaon", "K^{0}_{S} Granddaughter Decay Photon Matching Residual: #Delta#eta vs Energy", kaonResidualBins, kaonResidualMinE, kaonResidualMaxE, kaonResidualBins, -kaonResidualWindow, kaonResidualWindow); // kaon residuals

      /*
      //
      // No conversion matching residuals (for future use)
      //
 
     const double noConvResidualWindow = 0.10;
     const double noConvResidualMinE = 0.2;
     const double noConvResidualMaxE = 5.0;
     const int noConvResidualBins = 100;

     TH2D *dPhi_dEtaNoConv = new TH2D("dPhi_dEtaNoConv", "No Conversion Photon Matching Residual: #Delta#phi vs #Delta#eta", noConvResidualBins, -noConvResidualWindow, noConvResidualWindow, noConvResidualBins, -noConvResidualWindow, noConvResidualWindow); // no conv residuals
      TH1D *hBestAngleMatchNoConv = new TH1D("hBestAngleMatch", "No Conversion Photon Matching Residual: #sqrt{(#Delta#eta)^{2} + (#Delta#phi)^{2}}", noConvResidualBins, 0.0, noConvResidualWindow); // noConv residuals
      TH1D *hBestPhiMatchNoConv = new TH1D("hBestPhiMatch", "No Conversion Photon Matching Residual: #Delta#phi", noConvResidualBins, -noConvResidualWindow, noConvResidualWindow); // noConv residuals
      TH1D *hBestEtaMatchNoConv = new TH1D("hBestEtaMatch", "No Conversion Photon Matching Residual: #Delta#eta", noConvResidualBins, -noConvResidualWindow, noConvResidualWindow); // noConv residuals

      TH2D *dPhi_dZNoConv = new TH2D("dPhi_dZNoConv", "No Conversion Photon Matching Residual: #Delta#phi vs Z-Vertex", noConvResidualBins, -15.0, 15.0, noConvResidualBins, -noConvResidualWindow, noConvResidualWindow);    // kaon residuals
      TH2D *dEta_dZNoConv = new TH2D("dEta_dZNoConv", "No Conversion Photon Matching Residual: #Delta#eta vs Z-Vertex", noConvResidualBins, -15.0, 15.0, noConvResidualBins, -noConvResidualWindow, noConvResidualWindow);    // kaon residuals
      TH2D *dPhi_dENoConv = new TH2D("dPhi_dENoConv","No Conversion Photon Matching Residual: #Delta#phi vs Energy",noConvResidualBins,noConvResidualMinE,noConvResidualMaxE,noConvResidualBins,-noConvResidualWindow,noConvResidualWindow); // no conv resid
      TH2D *dEta_dENoConv = new TH2D("dEta_dENoConv","No Conversion Photon Matching Residual: #Delta#eta vs Energy",noConvResidualBins,noConvResidualMinE,noConvResidualMaxE,noConvResidualBins,-noConvResidualWindow, noConvResidualWindow); // noconv resid

      */

      TH2D *hRecoSignalPtBin[8];          // reco foreground
      TH2D *hRecoBackgroundPtBin[8];      // reco mixed-event

      for(int kPt=0; kPt<nPtBinsComplete; kPt++) {

	sprintf(histogramName, "hRecoSignalPtBin%d", kPt);
	sprintf(histogramTitle, "RECO: Same-event #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f ", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);
	hRecoSignalPtBin[kPt] = new TH2D(histogramName, histogramTitle, 32+1,-5.0-0.15, 5.0+0.15, 32-1,-TMath::Pi()/2+TMath::Pi()/32, 3*TMath::Pi()/2-TMath::Pi()/32);

	hRecoSignalPtBin[kPt]->SetStats(0);
        hRecoSignalPtBin[kPt]->SetLineColor(1);
        hRecoSignalPtBin[kPt]->SetXTitle("#Delta#eta");
        hRecoSignalPtBin[kPt]->SetYTitle("#Delta#phi");
        (hRecoSignalPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
        (hRecoSignalPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
        (hRecoSignalPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
        (hRecoSignalPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
        (hRecoSignalPtBin[kPt]->GetXaxis())->CenterTitle();
        (hRecoSignalPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
        (hRecoSignalPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
        (hRecoSignalPtBin[kPt]->GetYaxis())->CenterTitle();

	sprintf(histogramName, "hRecoBackgroundPtBin%d", kPt);
	sprintf(histogramTitle, "RECO: Mixed-event #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f ", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);
	hRecoBackgroundPtBin[kPt] = new TH2D(histogramName, histogramTitle, 32+1,-5.0-0.15, 5.0+0.15, 32-1,-TMath::Pi()/2+TMath::Pi()/32, 3*TMath::Pi()/2-TMath::Pi()/32);
	hRecoBackgroundPtBin[kPt]->SetStats(0);
        hRecoBackgroundPtBin[kPt]->SetLineColor(1);
        hRecoBackgroundPtBin[kPt]->SetXTitle("#Delta#eta");
        hRecoBackgroundPtBin[kPt]->SetYTitle("#Delta#phi");
        (hRecoBackgroundPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
        (hRecoBackgroundPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
        (hRecoBackgroundPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
        (hRecoBackgroundPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
        (hRecoBackgroundPtBin[kPt]->GetXaxis())->CenterTitle();
        (hRecoBackgroundPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
        (hRecoBackgroundPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
        (hRecoBackgroundPtBin[kPt]->GetYaxis())->CenterTitle();

      } // loop over 8 pt bins for pair correlations
      
      int nPtBins = 4;

      const float lowPtBinLimitQ2[4] =  {1.5, 2.0, 0.7, 1.0};   // Q2 pT bins
      const float highPtBinLimitQ2[4] = {2.0, 2.5, 1.0, 1.5};   // Q2 pT bins

      const float lowPtBinLimitQ3[4] =  {2.5, 3.0, 3.5, 4.0};   // Q3 pT bins
      const float highPtBinLimitQ3[4] = {3.0, 3.5, 4.0, 5.0};   // Q3 pT bins

      const float lowPtBinLimitQ4[4] =  {3.5, 4.0, 2.5, 3.0};   // Q4 pT bins
      const float highPtBinLimitQ4[4] = {4.0, 5.0, 3.0, 3.5};   // Q4 pT bins

      float lowPtBinLimit[4] =  {0.7, 1.0, 1.5, 2.0};   // Q1 pT bins as the default
      float highPtBinLimit[4] = {1.0, 1.5, 2.0, 2.5};   // Q1 pT bins as the default

      if(pTQuartile < 1 || pTQuartile > 4) {
	cerr << "\n Invalid value for pTQuartile " << pTQuartile << endl;
	return;
      } // safety check

      if(pTQuartile == 1) {
	cout << "\n using first pair of pT bins" << endl;
      }

      if(pTQuartile == 2) {
	cout << "\n using second pair of pT bins" << endl;
	for (int kPt=0; kPt<4; kPt++) {
	  lowPtBinLimit[kPt] = lowPtBinLimitQ2[kPt];
	  highPtBinLimit[kPt] = highPtBinLimitQ2[kPt];
	}
      } // check for second quartile

      if(pTQuartile == 3) {
	cout << "\n using third pair of pT bins" << endl;
	for (int kPt=0; kPt<4; kPt++) {
	  lowPtBinLimit[kPt] = lowPtBinLimitQ3[kPt];
	  highPtBinLimit[kPt] = highPtBinLimitQ3[kPt];
	}
      } // check for third quartile

      if(pTQuartile == 4) {
	cout << "\n using fourth pair of pT bins" << endl;
	for (int kPt=0; kPt<4; kPt++) {
	  lowPtBinLimit[kPt] = lowPtBinLimitQ4[kPt];
	  highPtBinLimit[kPt] = highPtBinLimitQ4[kPt];
	}
      } // check for fourth quartile

      int nRecEnergyBins = 4;
      float lowRecEnergyLimit[4] =  {0.3, 1.0, 2.0, 3.0};
      float highRecEnergyLimit[4] = {1.0, 2.0, 3.0, 4.0};
      TH1D *inclusiveClusters[4];
      TH1D *noConvClusters[4];
      TH1D *convClusters[4];

      TH1D *inclusiveWidth[4];
      TH1D *noConvWidth[4];
      TH1D *convWidth[4];

      TH1D *inclusiveSumWidth[4];
      TH1D *noConvSumWidth[4];
      TH1D *convSumWidth[4];

      for (int kEn=0; kEn<nRecEnergyBins; kEn++) {

	sprintf(histogramName, "inclusiveWidthBin%d", kEn);
	sprintf(histogramTitle, "s25WidthX: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	inclusiveWidth[kEn] = new TH1D(histogramName, histogramTitle, 100, 0.0, 1.5);
	inclusiveWidth[kEn]->SetLineColor(kBlue);
	inclusiveWidth[kEn]->SetLineWidth(2);
	inclusiveWidth[kEn]->SetXTitle("s25WidthX");
	inclusiveWidth[kEn]->SetYTitle("Counts");
	inclusiveWidth[kEn]->SetStats(0);

	sprintf(histogramName, "noConvWidthXBin%d", kEn);
	sprintf(histogramTitle, "NoConv s25WidthX: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	noConvWidth[kEn] = new TH1D(histogramName, histogramTitle, 100, 0.0, 1.5);
	noConvWidth[kEn]->SetLineColor(kGreen);
	noConvWidth[kEn]->SetLineWidth(2);
	noConvWidth[kEn]->SetXTitle("s25WidthX");
	noConvWidth[kEn]->SetYTitle("Counts");
	noConvWidth[kEn]->SetStats(0);

	sprintf(histogramName, "convWidthXBin%d", kEn);
	sprintf(histogramTitle, "Conv s25WidthX: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	convWidth[kEn] = new TH1D(histogramName, histogramTitle, 100, 0.0, 1.5);
	convWidth[kEn]->SetLineColor(kRed);
	convWidth[kEn]->SetLineWidth(2);
	convWidth[kEn]->SetXTitle("s25WidthX");
	convWidth[kEn]->SetYTitle("Counts");
	convWidth[kEn]->SetStats(0);

	sprintf(histogramName, "inclusiveSumWidthBin%d", kEn);
	sprintf(histogramTitle, "s25WidthX+s25WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	inclusiveSumWidth[kEn] = new TH1D(histogramName, histogramTitle, 100, 0.0, 3.0);
	inclusiveSumWidth[kEn]->SetLineColor(kBlue);
	inclusiveSumWidth[kEn]->SetLineWidth(2);
	inclusiveSumWidth[kEn]->SetXTitle("s25WidthX+s25WidthY");
	inclusiveSumWidth[kEn]->SetYTitle("Counts");
	inclusiveSumWidth[kEn]->SetStats(0);

	sprintf(histogramName, "noConvWidthXYBin%d", kEn);
	sprintf(histogramTitle, "NoConv s25WidthX+s25WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	noConvSumWidth[kEn] = new TH1D(histogramName, histogramTitle, 100, 0.0, 3.0);
	noConvSumWidth[kEn]->SetLineColor(kGreen);
	noConvSumWidth[kEn]->SetLineWidth(2);
	noConvSumWidth[kEn]->SetXTitle("s25WidthX+s25WidthY");
	noConvSumWidth[kEn]->SetYTitle("Counts");
	noConvSumWidth[kEn]->SetStats(0);

	sprintf(histogramName, "convWidthXYBin%d", kEn);
	sprintf(histogramTitle, "NoConv s25WidthX+s25WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	convSumWidth[kEn] = new TH1D(histogramName, histogramTitle, 100, 0.0, 3.0);
	convSumWidth[kEn]->SetLineColor(kRed);
	convSumWidth[kEn]->SetLineWidth(2);
	convSumWidth[kEn]->SetXTitle("s25WidthX+s25WidthY");
	convSumWidth[kEn]->SetYTitle("Counts");
	convSumWidth[kEn]->SetStats(0);

	if(iOption == 56) {
	  sprintf(histogramTitle, "Inclusive s25WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  inclusiveWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "No Conv s25WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  noConvWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "Conv s25WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  convWidth[kEn]->SetTitle(histogramTitle);
	  inclusiveWidth[kEn]->SetXTitle("s25WidthY");
	  noConvWidth[kEn]->SetXTitle("s25WidthY");
	  convWidth[kEn]->SetXTitle("s25WidthY");
	}

	if(iOption == 57) {
	  sprintf(histogramTitle, "Inclusive s9WidthX: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  inclusiveWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "No Conv s9WidthX: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  noConvWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "Conv s9WidthX: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  convWidth[kEn]->SetTitle(histogramTitle);
	  inclusiveWidth[kEn]->SetXTitle("s9WidthX");
	  noConvWidth[kEn]->SetXTitle("s9WidthX");
	  convWidth[kEn]->SetXTitle("s9WidthX");
	}

	if(iOption == 58) {
	  sprintf(histogramTitle, "Inclusive s9WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  inclusiveWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "No Conv s9WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  noConvWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "Conv s9WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  convWidth[kEn]->SetTitle(histogramTitle);
	  inclusiveWidth[kEn]->SetXTitle("s9WidthY");
	  noConvWidth[kEn]->SetXTitle("s9WidthY");
	  convWidth[kEn]->SetXTitle("s9WidthY");
	}

	if(iOption == 60) {
	  sprintf(histogramTitle, "Inclusive s9WidthX+s9WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  inclusiveSumWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "No Conv s9WidthX+s9WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  noConvSumWidth[kEn]->SetTitle(histogramTitle);
	  sprintf(histogramTitle, "Conv s9WidthX+s9WidthY: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	  convSumWidth[kEn]->SetTitle(histogramTitle);
	  inclusiveWidth[kEn]->SetXTitle("s9WidthX+s9WidthY");
	  noConvSumWidth[kEn]->SetXTitle("s9WidthX+s9WidthY");
	  convSumWidth[kEn]->SetXTitle("s9WidthX+s9WidthY");
	}

	sprintf(histogramName, "inclusiveClustersBin%d", kEn);
	sprintf(histogramTitle, "Clusters: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	inclusiveClusters[kEn] = new TH1D(histogramName, histogramTitle, 20, 0.0, 10.0);
	inclusiveClusters[kEn]->SetLineColor(kBlue);
	inclusiveClusters[kEn]->SetXTitle("Number of crysals in cluster");
	inclusiveClusters[kEn]->SetYTitle("Custer Count");
	inclusiveClusters[kEn]->SetStats(0);

	sprintf(histogramName, "noConvClustersBin%d", kEn);
	sprintf(histogramTitle, "Unconverted Photon Clusters: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	noConvClusters[kEn] = new TH1D(histogramName, histogramTitle, 20, 0.0, 10.0);
	noConvClusters[kEn]->SetLineColor(kGreen);
	noConvClusters[kEn]->SetStats(0);

	sprintf(histogramName, "convClustersBin%d", kEn);
	sprintf(histogramTitle, "Converted Photon Clusters: %3.1f<recEnr<%3.1f GeV", lowRecEnergyLimit[kEn], highRecEnergyLimit[kEn]);
	convClusters[kEn] = new TH1D(histogramName, histogramTitle, 20, 0.0, 10.0);
	convClusters[kEn]->SetLineColor(kRed);
	convClusters[kEn]->SetStats(0);

      } // loop over energy bins


      TH2D *WeightedTimingClusterEvsT = new TH2D("WeightedTimingClusterEvsT", "Energy vs Weighted Time Differential for Clusters Forming a #pi^{0} with 1.0 < p_{T} < 3.0 GeV/c", 240, -60., 60., 100, 0., 5.0);
      WeightedTimingClusterEvsT->SetStats(0);
      WeightedTimingClusterEvsT->SetXTitle("Weighted Time - Seed Time for Cluster (ns)");
      WeightedTimingClusterEvsT->SetYTitle("Cluster energy (GeV, corrected)");

      TH2D *TimingClusterEvsTCut = new TH2D("TimingClusterEvsTCut", "Cut for Energy vs Time for Clusters Forming a #pi^{0} with 1.0 < p_{T} < 3.0 GeV/c", 240, -60., 60., 100, 0., 5.0);
      TimingClusterEvsTCut->SetStats(0);
      TimingClusterEvsTCut->SetXTitle("Timing of seed crystal (ns)");
      TimingClusterEvsTCut->SetYTitle("Cluster energy (GeV, corrected)");
      
      TH2D *TimingClusterEvsT = new TH2D("TimingClusterEvsT", "Energy vs Time for Clusters Forming a #pi^{0} with 1.0 < p_{T} < 3.0 GeV/c", 240, -60., 60., 100, 0., 5.0);
      TimingClusterEvsT->SetStats(0);
      TimingClusterEvsT->SetXTitle("Timing of seed crystal (ns)");
      TimingClusterEvsT->SetYTitle("Cluster energy (GeV, corrected)");

      TH2D *TimingClusterEvsTBgrnd = new TH2D("TimingClusterEvsTBgrnd", "Energy vs Time for Clusters Forming a 225 < m_{#gamma#gamma} < 275 MeV/c^{2}, with 1.0 < p_{T} < 3.0 GeV/c", 240, -60., 60., 100, 0., 5.0);
      TimingClusterEvsTBgrnd->SetStats(0);
      TimingClusterEvsTBgrnd->SetXTitle("Timing of seed crystal (ns)");
      TimingClusterEvsTBgrnd->SetYTitle("Cluster energy (GeV, corrected)");

      TH1D *sameEventEtaHistogramsPtBin[4];

      TH1D *sameEventMassHistogramsPtBin[4];
      TH1D *mixedEventMassHistogramsPtBin[4];
      TH1D *unCorrectedPtBin[4];
      TH1D *correctedPtBin[4];

      TGaxis::SetMaxDigits(4);

      for(int kPt=0; kPt<nPtBins; kPt++) {

	sprintf(histogramName, "unCorrectedPtBin%d", kPt);
	sprintf(histogramTitle, "Nominal distribution: %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	unCorrectedPtBin[kPt] = new TH1D(histogramName, histogramTitle, 120, 0.0, 6.0);

	sprintf(histogramName, "correctedPtBin%d", kPt);
	sprintf(histogramTitle, "Corrected distribution: %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	correctedPtBin[kPt] = new TH1D(histogramName, histogramTitle, 120, 0.0, 6.0);

	sprintf(histogramName, "sameEventMassHistogramPtBin%d", kPt);
	sprintf(histogramTitle, "m_{#gamma#gamma} for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	sameEventMassHistogramsPtBin[kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, highMass);
        
	sameEventMassHistogramsPtBin[kPt]->SetStats(0);
	sameEventMassHistogramsPtBin[kPt]->SetLineColor(1);
	sameEventMassHistogramsPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	sameEventMassHistogramsPtBin[kPt]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->SetNoExponent(kTRUE);
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();
        
	sprintf(histogramName, "sameEventEtaHistogramPtBin%d", kPt);
	sprintf(histogramTitle, "RECO: #eta(#pi^{0}) for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	sameEventEtaHistogramsPtBin[kPt] = new TH1D(histogramName, histogramTitle, 100, -1.5, 1.5);

	sameEventEtaHistogramsPtBin[kPt]->SetStats(0);
	sameEventEtaHistogramsPtBin[kPt]->SetLineColor(1);
	sameEventEtaHistogramsPtBin[kPt]->SetXTitle("#eta");
	sameEventEtaHistogramsPtBin[kPt]->SetYTitle("Counts per 0.03 #eta bin");
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();

	sprintf(histogramName, "mixedEventMassHistogramPtBin%d", kPt);
	sprintf(histogramTitle, "Mixed-event m_{#gamma#gamma} for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	mixedEventMassHistogramsPtBin[kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, highMass);
        
	mixedEventMassHistogramsPtBin[kPt]->SetStats(0);
	mixedEventMassHistogramsPtBin[kPt]->SetLineColor(kMagenta);
	mixedEventMassHistogramsPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	mixedEventMassHistogramsPtBin[kPt]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();
        
      } // histogram initialization
      
      sprintf(histogramTitle, "Background-subtracted m_{#gamma#gamma} for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[0], highPtBinLimit[0]);
      TH1D *subtractedMassHistogramsPtBin0  = new TH1D("subtractedMassHistogramPtBin0", histogramTitle, nMassBins, 0.0, highMass);
      subtractedMassHistogramsPtBin0->SetStats(0);
      subtractedMassHistogramsPtBin0->SetLineColor(1);
      subtractedMassHistogramsPtBin0->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      subtractedMassHistogramsPtBin0->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
      (subtractedMassHistogramsPtBin0->GetXaxis())->SetLabelSize(0.05);
      (subtractedMassHistogramsPtBin0->GetYaxis())->SetLabelSize(0.05);
      
      (subtractedMassHistogramsPtBin0->GetXaxis())->SetTitleSize(0.06);
      (subtractedMassHistogramsPtBin0->GetXaxis())->SetTitleOffset(0.75);
      (subtractedMassHistogramsPtBin0->GetXaxis())->CenterTitle();
      (subtractedMassHistogramsPtBin0->GetYaxis())->SetTitleSize(0.06);
      (subtractedMassHistogramsPtBin0->GetYaxis())->SetTitleOffset(0.75);
      (subtractedMassHistogramsPtBin0->GetYaxis())->CenterTitle();
      sprintf(histogramTitle, "Background-subtracted m_{#gamma#gamma} for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[1], highPtBinLimit[1]);
      TH1D *subtractedMassHistogramsPtBin1  = new TH1D("subtractedMassHistogramPtBin1", histogramTitle, nMassBins, 0.0, highMass);
      subtractedMassHistogramsPtBin1->SetStats(0);
      subtractedMassHistogramsPtBin1->SetLineColor(1);
      subtractedMassHistogramsPtBin1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      subtractedMassHistogramsPtBin1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
      (subtractedMassHistogramsPtBin1->GetXaxis())->SetLabelSize(0.05);
      (subtractedMassHistogramsPtBin1->GetYaxis())->SetLabelSize(0.05);
      
      (subtractedMassHistogramsPtBin1->GetXaxis())->SetTitleSize(0.06);
      (subtractedMassHistogramsPtBin1->GetXaxis())->SetTitleOffset(0.75);
      (subtractedMassHistogramsPtBin1->GetXaxis())->CenterTitle();
      (subtractedMassHistogramsPtBin1->GetYaxis())->SetTitleSize(0.06);
      (subtractedMassHistogramsPtBin1->GetYaxis())->SetTitleOffset(0.75);
      (subtractedMassHistogramsPtBin1->GetYaxis())->CenterTitle();
      
      int maxArraySize = 0;
      int kArrayLast = 0;
      int kDebugPrint = 0;
      
      float minimumSeparationSameEvent = 100.0;
      float minimumSeparationMixedEvent = 100.0;
      int countMixedEventSeparationCut = 0;
      int countSameEventSeparationCut = 0;
      int countZVertexCut = 0;
      int countMatchedClusters = 0;
      int acceptedEvents = 0;
      int countConvertedPhotons = 0;
      int countNonDecayParents = 0;
      int countDecayParents = 0;
      int countTotalClusters = 0;
      int countSameEventAsymmetryCut = 0;
      int countMixedEventAsymmetryCut = 0;
      int countIsolationCut = 0;
			
      //  const float PI0PAIROPENCUT = 0.25;  for future use
      const int MAXRECOPI0MASS = 1000;
      int countTotalRecoPi0Mass = 0;
      int countTrueDecayPhotons = 0;
      int countTrueDecayMesons = 0;
      // int countTrueNonDecayMesons = 0;  variable is not used
      int countTaggedRecoPi0Mass = 0;
      int countTaggedClusters = 0;

      //
      // For 2D pair correlations
      //

      const int MAXBACKGROUNDSIZE = 2000;
      float etaThisEvent[2000];
      float phiThisEvent[2000];
      float efficiencyThisEvent[2000];

      int nLast_ass = 0;
      int nBuffersFilled = 0;
      int currentBufferIndex = 0;
      int nLastBuffer[10];
      float etaLastEvent[2000][NBUFFERDEPTH];
      float phiLastEvent[2000][NBUFFERDEPTH];
      float efficiencyLastEvent[2000][NBUFFERDEPTH];

      int nEventsTotal = 0;
      int nTrgTotal = 0;

      int sampledEvents = nEntries;
      
      cout << "\n Being hTree scan for iOption = " << iOption << " with first entry number " << skipEntries;
      if(useRotatedBackground)
	cout << ", rotated-cluster background method will be used";
      else
	cout << ", mixed-event background method will be used";
      
      cout << endl;
      
      for (Long64_t i=skipEntries; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);

	//
	// Check array sizes
	//
	if(nCry > CRYARRAY) {
	  cerr << "\n nCry is too large " << nCry << ", beyond limit " << CRYARRAY << endl;
	  return;
	}
	if(nClu > CLUARRAY) {
	  cerr << "\n nClu is too large " << nClu << ", beyond limit " << CLUARRAY << endl;
	  return;
	}
	if(nPairTracksSize > PAIRTRACKARRAY) {
	  cerr << "\n nPairTracksSize is too large " << nPairTracksSize << ", beyond limit " << PAIRTRACKARRAY << endl;
	  return;
	}
	if(nHITracks > RECOTRACKARRAY) {
	  cerr << "\n nHITracks is too large " << nHITracks << ", beyond limit " << RECOTRACKARRAY << endl;
	  return;
	}
	if(nMC > MCARRAY) {
	  cerr << "\n nMC is too large " << nMC << ", beyond limit " << MCARRAY << endl;
	  return;
	}
	if(mergedTrackTruthSize > MERGETRUTHARRAY) {
	  cerr << "\n mergedTrackTruth is too large " << mergedTrackTruthSize << ", beyond limit " << MERGETRUTHARRAY << endl;
	  return;
	}
	if(nChMesonSize > CHMESONARRAY) {
	  cerr << "\n nChMesonSize is too large " << nChMesonSize << ", beyond limit " << CHMESONARRAY << endl;
	  return;
	}
	if(nMesonSize > MESONARRAY) {
	  cerr << "\n nMesonSize is too large " << nMesonSize << ", beyond limit " << MESONARRAY << endl;
	  return;
	}
	if(nSimTracks > SIMTRACKARRAY) {
	  cerr << "\n nSimTracks is too large " << nSimTracks << ", beyond limit " << SIMTRACKARRAY << endl;
	  return;
	}
	if(nPhotonSize > PHOTONGENARRAY) {
	  cerr << "\n nPhotonSize is too large " << nPhotonSize << ", beyond limit " << PHOTONGENARRAY << endl;
	  return;
	}

	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " has nClu = " << nClu;
	}

	if(printPairContributors) {
	  cout << "\n At event " << Event  << " which has " << nClu << " accepted clusters, nHITracks " << nHITracks;
	  cout << ", and nHighPurityTracks " << nHighPurityTracks << "    [printContributors]";
	}  


	if(useHighPurityTracks) {
	  if(nHighPurityTracks < lowMultiplicity || nHighPurityTracks > highMultiplicity)
	    continue;
	}
	else {
	  if(nHITracks < lowMultiplicity || nHITracks > highMultiplicity)
	    continue;
	}

	if(zPrimaryVtx < zVertexLowLimit || zPrimaryVtx > zVertexHighLimit)
	  continue;

	for(int jMeson=0; jMeson< nMesonSize; jMeson++) {
	  //
	  // hardcode for pi0 here
	  //
	  if(pdgIdMeson[jMeson] == 111 && daughtersFromMeson[jMeson] == 2 && fabs(etaMeson[jMeson]) <= etaHighLimit &&
             fabs(etaMeson[jMeson]) >= etaLowLimit && ptMeson[jMeson] > 0.5 && ptMeson[jMeson] < 5.0) {

	    generatorPi0YieldsPt->Fill(ptMeson[jMeson]);
	    generatorPi0YieldsEta->Fill(etaMeson[jMeson]);
	    generatorPi0Yields->Fill(ptMeson[jMeson], etaMeson[jMeson]);

	  } // check on accepting meson
						
	} // loop over mesons

	nEventsTotal++;
	int nMult_ass = 0;
	int nMult_trg = 0;
	int nTracksSize = nPairTracksSize;

	acceptedEvents++;

	int kArray = 0;
	const int ARRAYMAX = 1000;
	int kToJCluMap[ARRAYMAX];   // for future use
	int motherGenIndexSimCluster[ARRAYMAX];
	// int motherGenIdSimCluster[ARRAYMAX];  for future use
	// int taggedCluster[ARRAYMAX];  for future use, these are for looking at pairs of reconstructed pi0
	bool convertedCluster[ARRAYMAX];
	float ecalEnergyUncorrectedArray[ARRAYMAX];
	float ecalEnergy[ARRAYMAX];
	float ecalTheta[ARRAYMAX];
	float ecalPhi[ARRAYMAX];
	float ecalTime[ARRAYMAX];
	float weightedTime[ARRAYMAX];
	int kCrystal[ARRAYMAX];
        
	// int kToJCluMapLast[ARRAYMAX];  variable is not used
	int motherGenIndexSimClusterLast[ARRAYMAX];
	// int motherGenIdSimClusterLast[ARRAYMAX];  for future use
	bool convertedClusterLast[ARRAYMAX];
	float ecalEnergyUncorrectedArrayLast[ARRAYMAX];
	float ecalEnergyLast[ARRAYMAX];
	float ecalThetaLast[ARRAYMAX];
	float ecalPhiLast[ARRAYMAX];
	int kCrystalLast[ARRAYMAX];
	
	int countRecoPi0Mass = 0;
	// int firstPairMember[1000];  for future use
	// int secondPairMember[1000]; for future use
	float ptRecoPi0Mass[1000];
	float etaRecoPi0Mass[1000];
	float phiRecoPi0Mass[1000];

	int nMatchKaon = 0;
	int jClusterToSim[CLUARRAY];
	int jClusterToMatchKaon[CLUARRAY];
	float bestClusterAngleMatchKaon[CLUARRAY];
	for(int jClu=0; jClu<nClu; jClu++) {
	  jClusterToSim[jClu] = -1;
	  jClusterToMatchKaon[jClu] = -1;
	  bestClusterAngleMatchKaon[jClu] = 100.0;;
	}
	int trackParentMatchKaon[ARRAYMAX];
	int trackGParentMatchKaon[ARRAYMAX];
	if(checkKaon || plotKaonResiduals) {
	  //
	  // Cycle through njSim to look for photons whose grandparents are K0-Short (PdgId = 310)
	  // Those photons will be geometrically matched to the ECAL eta and phi
	  // The match information will include the track numbers of the parent pi0 and the track number of the grandparent kaon
	  //
	  for(int jSim=0; jSim<=njSim; jSim++) {
	    if(rSim[jSim] > kaonResidualMaxR || eSim[jSim] < kaonResidualMinE || eSim[jSim] > kaonResidualMaxE || etaSim[jSim] < kaonResidualMinEta || etaSim[jSim] > kaonResidualMaxEta)
	      continue;

	    if(nMatchKaon >= ARRAYMAX) {
	      cerr << "\n nMatchKaon too large" << endl;
	      return;
	    }
	    if(pdgIdSim[jSim] == 22 && parentIdSim[jSim] == 111 && gParentIdSim[jSim] == 310) { // photon with pi0 parent and K0-short grandparent
	      float simEta = etaSim[jSim];
	      float simPhi = phiSim[jSim];
	      if(printKaonResiduals && Event == 846644) {
		cout << "\n K0-short at jSim " << jSim << ",  simEta " << simEta << ",  simPhi " << simPhi << ",  eSim " << eSim[jSim];
	      }
	      for(int jClu=0; jClu<nClu; jClu++) {
		float cluEta = etaClu[jClu];
		float cluPhi = phiClu[jClu];

		float diffEta = cluEta - simEta;
		float diffPhi = deltaPhi(simPhi, cluPhi);

		if(fabs(diffEta) > kaonResidualWindow || fabs(diffPhi) > kaonResidualWindow)
		  continue;

		float angleDiff = sqrt(diffEta*diffEta + diffPhi*diffPhi);
		if(angleDiff < bestClusterAngleMatchKaon[jClu]) {
		  bestClusterAngleMatchKaon[jClu] = angleDiff;
		  jClusterToSim[jClu] = jSim;
		  jClusterToMatchKaon[jClu] = nMatchKaon;
		} // check for better angle match
		if(printKaonResiduals && Event == 846644) {
		  cout << "\n jClu " << jClu << ",  angleDiff " << angleDiff << ",  bestAngleMath " << bestClusterAngleMatchKaon[jClu];
		  cout << ",  jClusterToMatchKaon " << jClusterToMatchKaon[jClu];
		}
	      } // loop over clusters
	      trackParentMatchKaon[nMatchKaon] = parentTrackSim[jSim];
	      trackGParentMatchKaon[nMatchKaon] = gParentTrackSim[jSim];
	      nMatchKaon++;
	    } // good photon candidate in njSim collection
	  } // loop over njSim

	  for(int jClu=0; jClu<nClu; jClu++) {
	    int jSim = jClusterToSim[jClu];
	    float diffPhi = deltaPhi(phiClu[jClu], phiSim[jSim]);

	    if(bestClusterAngleMatchKaon[jClu] < 0 || fabs(diffPhi) > 0.1)
	      continue;

	    if(bestClusterAngleMatchKaon[jClu] < kaonResidualWindow)
	      hBestAngleMatchKaon->Fill(bestClusterAngleMatchKaon[jClu]);
	    
	    float diffEta =  etaClu[jClu] - etaSim[jSim]; 
	    
	    if(fabs(diffEta) < kaonResidualWindow && fabs(diffPhi) < kaonResidualWindow) {
		dPhi_dEtaKaon->Fill(diffEta, diffPhi);
	    }

	    hBestPhiMatchKaon->Fill(diffPhi);
	    hBestEtaMatchKaon->Fill(diffEta);

	    double simZ = zSim[jSim];
	    if(fabs(simZ) < 15.0) {
	      dPhi_dZKaon->Fill(simZ, diffPhi);
	      dEta_dZKaon->Fill(simZ, diffEta);
	    }

	    double simR = rSim[jSim];
	    dPhi_dRKaon->Fill(simR, diffPhi);
	    dEta_dRKaon->Fill(simR, diffEta);

	    double simE = eSim[jSim];
	    dPhi_dEKaon->Fill(simE, diffPhi);
	    dEta_dEKaon->Fill(simE, diffEta);

	    double simEtaD = etaSim[jSim];
	    dPhi_dSimEtaKaon->Fill(simEtaD, diffPhi);
	    dEta_dSimEtaKaon->Fill(simEtaD, diffEta);

	  }  // loop over clusters to fill residual histograms

	  if(printKaonResiduals && Event == 846644) {
	    cout << "\n Number nMatchKaon " << nMatchKaon << ",  njSim " << njSim << ",  Event " << Event;
	    for(int jClu=0; jClu<nClu; jClu++) {
	      int jSim = jClusterToSim[jClu];
	      cout << "\n " << jClu << ")  jClusterToSim " << jSim;
	      int jMatchKaon =  jClusterToMatchKaon[jClu];
	      cout << ",  jClusterToMatchKaon " << jMatchKaon;
	      cout << ",  bestClusterAngleMatchKaon " <<  bestClusterAngleMatchKaon[jClu];
	      float diffEta =  etaClu[jClu] - etaSim[jSim]; 
	      float diffPhi = deltaPhi(phiClu[jClu], phiSim[jSim]);
	      float angleDiff = sqrt(diffEta*diffEta + diffPhi*diffPhi);
	      cout << ", angle diff " << angleDiff;
	      cout << ",  etaClu " << etaClu[jClu] << ",  etaSim " << etaSim[jSim]; 
	      cout << ",  phiClu " << phiClu[jClu] << ",  phiSim " << phiSim[jSim]; 
	      cout << ",  trackParentMatchKaon " << trackParentMatchKaon[jMatchKaon];
	      cout << ",  trackGParentMatchKaon " << trackGParentMatchKaon[jMatchKaon];
	      cout << ",  S9Clu " << S9Clu[jClu] << ", eSim " << eSim[jSim]; 
	    }
	    cout << "\n Temporary stop" << endl << endl;
	    return;
	  }

	} // check if a K0-Short match is to be tested

	for(int jClu=0; jClu<nClu; jClu++) {

	  /*

	  //
	  // The tracks and vertex cut checks had stopped working in the outer loop over entries ??
	  //

	  if(useHighPurityTracks) {
	    if(nHighPurityTracks < lowMultiplicity || nHighPurityTracks > highMultiplicity)
	      continue;
	  }
	  else {
	    if(nHITracks < lowMultiplicity || nHITracks > highMultiplicity)
	      continue;
	  }

	  if(zPrimaryVtx < zVertexLowLimit || zPrimaryVtx > zVertexHighLimit)
	    continue;
		
	  */

	  if(useSeedTimeCut && fabs(seedTimeClu[jClu]) > seedTimeCut)
	    continue;

	  //
	  //  Where is ecalEnergy assigned?
	  //
	  if(useEnergyVsTimingCut) {

	    if(ecalEnergy[jClu] > 0.0) {
	      float energyInverse = 1.0/ecalEnergy[jClu];
	      float tCut = 4.0 - 10.8452*energyInverse + 14.9102*energyInverse*energyInverse -3.065*energyInverse*energyInverse*energyInverse;

	      if(ecalEnergy[jClu] > 1.123)
		tCut = 4.0;

	      if(tCut > 20)
		tCut = 20;

	      tCut *= 0.35;

	      if(fabs(seedTimeClu[jClu]) > tCut)
		continue;
	    } // check on energy threshold

	  } // check on using 2-D timing cut

	  if(useTrackMatchSuppression && nGoodRecoMatches[jClu] > 0) {
	    countMatchedClusters++;
	    continue;  // skip clusters which have a match to a charged particle track
	  }
          
	  if(useClusterCrystalLimit && !useClusterCrystalLimitLowPtOnly) {
	    if(nCryClu[jClu] < lowCrystalLimit || nCryClu[jClu] > highCrystalLimit)
	      continue;
	  } // check on using crystal number limits
          
	  if(useClusterPairCrystalSumLimit && !useClusterCrystalLimitLowPtOnly && nCryClu[jClu] >= highClusterPairCrystalSumLimit)
	    continue;  // already over the cluster pair crystal sum limit with one cluster
			
	  bool failIsolationCut = false;
	  if(useClusterIsolationCut) {
	    float phi1 = ecalPhi[jClu];
	    float cosphi1 = cos(phi1);
	    float sinphi1 = sin(phi1);
            
	    float xCluster1 = rECal*cosphi1;
	    float yCluster1 = rECal*sinphi1;
	    float zCluster1 = rECal/tan(ecalTheta[jClu]);
            
	    for(int mClu=0; mClu<nClu; mClu++) {
	      if(mClu != jClu) {

		float phi2 = ecalPhi[mClu];
		float cosphi2 = cos(phi2);
		float sinphi2 = sin(phi2);
                
		float xCluster2 = rECal*cosphi2;
		float yCluster2 = rECal*sinphi2;
		float zCluster2 = rECal/tan(ecalTheta[mClu]);
                
		float dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		  (yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		  (zCluster2 - zCluster1)*(zCluster2- zCluster1);
                
		if(dSeparationSquared < clusterIsolationCutSizeSquared) {
		  failIsolationCut = true;
		  break;
		}
                
	      }
	    } // loop over all other clusters
            
	  } // check on using isolation cut
          
	  if(failIsolationCut) {
	    countIsolationCut++;
	    continue;
	  }
          
	  bool convertedPhoton = false;
	  bool decayFromGrandParentResonance = false;
				
	  if(useConversionSuppression && simulationTruthChoice == 1) {
	    //
	    // check if this cluster is associated with an unconverted photon in the mergedTrackTruth collection
	    //
	    bool foundUnconvertedPhoton = false;
	    for(int jMerge=0; jMerge<mergedTrackTruthSize; jMerge++) {
	      if(primaryTrackMerge[jMerge] == 1 && pdgIdMerge[jMerge] == 22) {
		if(numberDecayVerticesMerge[jMerge] == 0) {
		  int indexEcal = bestEcalIndexMatch[jMerge];
		  if(indexEcal > -1 && indexEcal < nClu) {
		    if(indexEcal == jClu && bestEcalAngleMatch[jMerge] >= 0.0 && bestEcalAngleMatch[jMerge] < 0.010) {
		      foundUnconvertedPhoton = true;
		      break;
		    } // check if angle match is good
		  } // check for valid indexEcal
		} // check that this photon did not convert
	      } // check that the merge entry is a primary photon
	    } // loop over jMerge
	    convertedPhoton = !foundUnconvertedPhoton;
	  } // check on using conversion suppression with the mergedTrackTruth collection

	  //
	  // New standard choice is to use simulationTruthChoice to look at conversion suppression
	  //	
	  if(testConversion && simulationTruthChoice == 2) {
	    //
	    // check if this cluster is associated with an unconverted photon in the simTracks collection
	    //
	    if(countNoConvertSimMatchEcal[jClu] == 0 ||  bestNoConvertSimAngleEcal[jClu] > 0.018) { // these are cluster branch elements, but they depend on simTrackStore being set
	      convertedPhoton = true;
	    } // check whether the cluster can be matched to an unconverted photon
	    else {
	      //
	      // These clusters are matched to unconverted photons in the simTracks collection
	      //
	      // Check that the photon parent meson did not come from a higher mass resonance decay
	      //
	      int jSim = bestNoConvertSimIndexEcal[jClu];  // jSim is the index in the simTrack branch
	      if(jSim < 0 || jSim >= njSim) {
		cerr << "\n Invalid value of jSim " << jSim << " for a matched unconverted ECAL cluster jClu " << jClu;
		cerr << endl;
		return;
	      } // safety check


	      if(gMotherGenIdSim[jSim] > -1) {  // this is a simTrack branch element, also stored with the simSlimTrackStore
		decayFromGrandParentResonance = true;
		countDecayParents++;
	      }
	      else {
		countNonDecayParents++; // these will also be unconverted photons
	      } // check on grandmother PDG ID
	    } // branch for further checking of unconverted photons
	  } // check on using conversion suppression with the simTracksCollection collection
					
	  if(useOnlyNonDecay && decayFromGrandParentResonance)
	    continue;
					
	  if(useOnlyDecay && !decayFromGrandParentResonance)
	    continue;

	  if(useOnlyKaonGParent) {
	    float testAngleMatch = bestClusterAngleMatchKaon[jClu];
	    if(testAngleMatch <= 0.0) {
	      cerr << "\n For bestClusterAngleMatchKaon = " << testAngleMatch << endl;
	      return;
	    } // safety check

	    if(testAngleMatch > 0.03)
	      continue;

	  } // include only if this photon came from a K0-short grandparent


	  if(excludeKaonGParent) {
	    float testAngleMatch = bestClusterAngleMatchKaon[jClu];
	    if(testAngleMatch <= 0.0) {
	      cerr << "\n For bestClusterAngleMatchKaon = " << testAngleMatch << endl;
	      return;
	    } // safety check

	    if(testAngleMatch < 0.03)
	      continue;

	  } // exclude if this photon came from a K0-short grandparent

	  if(useNoRecalRenorm) {
	    S9Clu[jClu] *= noRecalRenormFactor;
	    S4Clu[jClu] *= noRecalRenormFactor;
	    S25Clu[jClu] *= noRecalRenormFactor;
	    S1Clu[jClu] *= noRecalRenormFactor;
	    recEnergySum[jClu] *= noRecalRenormFactor;
	  }

	  bool failShapeCut = false;
	  float ecalEnergyUncorrected = S9Clu[jClu];
	  float recEnergyTest = recEnergySum[jClu];

	  if(ecalEnergyUncorrected > lowEnergyCutParameter && S4Clu[jClu]/ecalEnergyUncorrected > clustS49Cut &&
	     S1Clu[jClu] > clustS1Cut && fabs(etaClu[jClu]) < 1.49 &&
	     (fabs(1.0 - S25Clu[jClu]/ecalEnergyUncorrected) < clustS25Cut)) {

	    //
	    // check for energy bin
	    //
	    int jEnergyBin = -1;
	    for(int kEn=0;  kEn<nRecEnergyBins; kEn++) {
	      if(recEnergyTest >= lowRecEnergyLimit[kEn] && recEnergyTest < highRecEnergyLimit[kEn]) {
		jEnergyBin = kEn;
		break;
	      }
	    } // check for energy bin

	    if(jEnergyBin != -1) {
	      inclusiveClusters[jEnergyBin]->Fill(nCryClu[jClu]);

	      if(testConversion) {
		if(convertedPhoton) {
		  convClusters[jEnergyBin]->Fill(nCryClu[jClu]);
		}
		else {
		  noConvClusters[jEnergyBin]->Fill(nCryClu[jClu]);
		}
	      } // check on using conversion suppression
	      
	      float widthSize = s25WidthX[jClu];
	      float sumWidthSize = widthSize + s25WidthY[jClu];
	      if(iOption == 56)
		widthSize = s25WidthY[jClu];
	      if(iOption == 57)
		widthSize = s9WidthX[jClu];
	      if(iOption == 58)
		widthSize = s9WidthY[jClu];
	      if(iOption == 60)
		sumWidthSize = s9WidthX[jClu] + s9WidthY[jClu];

	      if(nCryClu[jClu] >= lowCrystalLimit && nCryClu[jClu] <= highCrystalLimit) {

		float s25SumWidth = s25WidthX[jClu] + s25WidthY[jClu];
		float s9SumWidth = s9WidthX[jClu] + s9WidthY[jClu];
		totalShapeExaminePhotons++;
		if(useClusterShapeCuts) {
		  if(nCryClu[jClu] == 2) {
		    if(s25SumWidth > shapeCutValue || s9SumWidth > shapeCutValue) {
		      totalShapeCutPhotons++;
		      failShapeCut = true;
		    } // check on shape cut value
		  } // check on number of crystals
		} // check on using shape cuts
		
		inclusiveWidth[jEnergyBin]->Fill(widthSize);
		inclusiveSumWidth[jEnergyBin]->Fill(sumWidthSize);

		if(testConversion) {
		  if(convertedPhoton) {
		    convWidth[jEnergyBin]->Fill(widthSize);
		    convSumWidth[jEnergyBin]->Fill(sumWidthSize);
		  }
		  else {
		    noConvWidth[jEnergyBin]->Fill(widthSize);
		    noConvSumWidth[jEnergyBin]->Fill(sumWidthSize);
		  }
		} // check on using conversion suppression

	      } // check on crystal limits

	    } // check on valid energy bin

	  } // check on uncorrected energy
					
	  countTotalClusters++;
	  if(convertedPhoton) {
	    countConvertedPhotons++;
	    if(useConversionSuppression)
	      continue;  // skip cluster entirely if conversion suppression is requested
	  }
          
	  int crystalIndex = nCryClu[jClu] - 1;
					
	  if(ecalEnergyUncorrected > lowEnergyCutParameter && S4Clu[jClu]/ecalEnergyUncorrected > clustS49Cut &&
	     !failShapeCut &&
	     S1Clu[jClu] > clustS1Cut && (fabs(1.0 - S25Clu[jClu]/ecalEnergyUncorrected) < clustS25Cut)) {
	     // S1Clu[jClu] > clustS1Cut && fabs((S25Clu[jClu]-ecalEnergyUncorrected)/ecalEnergyUncorrected) < clustS25Cut) { // second
            
	    if(kArray < ARRAYMAX) {
	      kToJCluMap[kArray] = jClu; // variable is not used

	      motherGenIndexSimCluster[kArray] = -1;
	      // motherGenIdSimCluster[kArray] = -1;  for future use
	      if(convertedPhoton) {
		convertedCluster[kArray] = true;
	      } // cluster is assigned to be from a converted photon
	      else {
		convertedCluster[kArray] = false;
		//
		// Determine the mother index for this cluster
		//
		int jSim =  bestNoConvertSimIndexEcal[jClu];
		if(jSim > -1 && jSim < nSimTracks) {
		  motherGenIndexSimCluster[kArray] = motherGenIndexSim[jSim];
		  // motherGenIdSimCluster[kArray] = motherGenIdSim[jSim];  for future use
		}
	      } // cluster is assigned to a non-converted photon

	      // taggedCluster[kArray] = 0;
	      kCrystal[kArray] =  nCryClu[jClu];
	      ecalPhi[kArray] = phiClu[jClu];
	      float ecalEta = etaClu[jClu];
	      ecalTheta[kArray] = 2.0*atan(exp(-ecalEta));
	      ecalEnergy[kArray] = ecalEnergyUncorrected;
	      ecalEnergyUncorrectedArray[kArray] = ecalEnergyUncorrected;
	      ecalTime[kArray] = seedTimeClu[jClu];
	      weightedTime[kArray] = weightedTimeClu[jClu];

	      if(useEnergyCorrection)
		ecalEnergy[kArray] = crystalCorrectionFunction(crystalIndex, ecalEnergyUncorrected);
							
	    }
	    kArray++;
						
	  }  // check for S9Clu above cut parameter
					
	} // loop on clusters
        
	if(kArray > maxArraySize)
	  maxArraySize = kArray;

	/*
	//
	// List cluster information
	//

	cout << "\n\n Number of clusters listed = " << kArray;
	for(int jClu=0; jClu<kArray; jClu++) {
	  cout << "\n " << jClu << ") with energy " << ecalEnergy[jClu];
	  cout << " at theta " << ecalTheta[jClu] << " with phi " << ecalPhi[jClu];
	  
	  if(convertedCluster[jClu])
	    cout << " is a conversion and ";
	  else
	    cout << " is not a conversion and ";
	  
	  cout << " has mother pdgId " << motherGenIdSimCluster[jClu] << " and parent index " << motherGenIndexSimCluster[jClu]; 
	}
	cout << endl;
        */

	if(kArray > 1) { // check for at least two clusters
	  int kArrayMinusOne = kArray - 1;
					
	  for(int jClu=0; jClu<kArrayMinusOne; jClu++) {

	    int indexFirstCluster = motherGenIndexSimCluster[jClu];
				
	    if(selectConversionOnly && !convertedCluster[jClu])
	      continue;

	    if(selectNonConversionOnly && convertedCluster[jClu])
	      continue;

	    float cosTheta1 = cos(ecalTheta[jClu]);
	    float sinTheta1 = sin(ecalTheta[jClu]);
	    float phi1 = ecalPhi[jClu];
	    float cosphi1 = cos(phi1);
	    float sinphi1 = sin(phi1);
	    float energy1 = ecalEnergy[jClu];
						
	    float pt1 = energy1*sinTheta1;
	    float px1 = pt1*cosphi1;
	    float py1 = pt1*sinphi1;
	    float pz1 = energy1*cosTheta1;
						
	    float px1Uncorrected = px1;
	    float py1Uncorrected = py1;

	    if(useWrongPt) {
	      float unCorrectionFactor = ecalEnergyUncorrectedArray[jClu]/energy1;
	      px1Uncorrected *= unCorrectionFactor;
	      py1Uncorrected *= unCorrectionFactor;
	    }
						
	    float xCluster1 = rECal*cosphi1;
	    float yCluster1 = rECal*sinphi1;
	    float zCluster1 = rECal/tan(ecalTheta[jClu]);
            
	    int jCluPlusOne = jClu + 1;
            
	    int jCrystal = kCrystal[jClu];
            
	    for(int mClu=jCluPlusOne; mClu<kArray; mClu++) {

	      int mCrystal = kCrystal[mClu];;

	      int indexSecondCluster = motherGenIndexSimCluster[mClu];

	      if(selectSameParentClusters) {
		if(indexFirstCluster < 0 || indexSecondCluster < 0 ||  indexFirstCluster != indexSecondCluster)
		  continue;
	      }
              
	      if(selectDifferentParentClusters) {
		if(indexFirstCluster < 0 || indexSecondCluster < 0 ||  indexFirstCluster == indexSecondCluster)
		  continue;
	      }

	      if(selectConversionOnly && !convertedCluster[mClu])
		continue;

	      if(selectNonConversionOnly && convertedCluster[mClu])
		continue;

	      bool mixedPair = false;
	      if((convertedCluster[jClu] && !convertedCluster[mClu]) ||
		 (!convertedCluster[jClu] && convertedCluster[mClu]))
		mixedPair = true;

	      if(selectConversionMixed && !mixedPair)
		continue;
					
	      float cosTheta2 = cos(ecalTheta[mClu]);
	      float sinTheta2 = sin(ecalTheta[mClu]);
	      float phi2 = ecalPhi[mClu];
	      float cosphi2 = cos(phi2);
	      float sinphi2 = sin(phi2);
	      float energy2 = ecalEnergy[mClu];
              
	      if(useClusterEnergyAsymmetryCut) {
		float ratio = fabs(energy1 - energy2)/(energy1 + energy2);
		if(ratio > clusterEnergyAsymmetryCutSize) {
		  countSameEventAsymmetryCut++;
		  continue;
		}
	      } // check on using aysmmetery cut
              
	      float xCluster2 = rECal*cosphi2;
	      float yCluster2 = rECal*sinphi2;
	      float zCluster2 = rECal/tan(ecalTheta[mClu]);
              
	      float dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		(yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		(zCluster2 - zCluster1)*(zCluster2- zCluster1);
              
	      float dSeparation = sqrt(dSeparationSquared);
              
	      if(dSeparation < minimumSeparation) {
		countSameEventSeparationCut++;
		continue;
	      }
              
	      if(dSeparation <  minimumSeparationSameEvent)
		minimumSeparationSameEvent= dSeparation;
              
	      float pt2 = energy2*sinTheta2;
	      float px2 = pt2*cosphi2;
	      float py2 = pt2*sinphi2;
	      float pz2 = energy2*cosTheta2;

	      float px2Uncorrected = px2;
	      float py2Uncorrected = py2;

	      if(useWrongPt) {
		float unCorrectionFactor = ecalEnergyUncorrectedArray[mClu]/energy2;
		px1Uncorrected *= unCorrectionFactor;
		py2Uncorrected *= unCorrectionFactor;
	      }

	      float px = px1 + px2;
	      float py = py1 + py2;
	      float pt = sqrt(px*px + py*py);

	      if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || pt < clusterCrystalLimitLowPtOnly)) {
		if(jCrystal < lowCrystalLimit || jCrystal > highCrystalLimit ||
		   mCrystal < lowCrystalLimit || mCrystal > highCrystalLimit) {
		  continue;
		}
	      } // check for using the cluster crystal limits up to only a pT cut value, same event

	      if(useClusterPairCrystalSumLimit && (!useClusterCrystalLimitLowPtOnly || pt < clusterCrystalLimitLowPtOnly)) {
		int clusterPairCrystalSum = jCrystal + mCrystal;
		if(clusterPairCrystalSum < lowClusterPairCrystalSumLimit ||
		   clusterPairCrystalSum > highClusterPairCrystalSumLimit)
		  continue;
	      } // check for crystal sum limit, same event

	      float pz = pz1 + pz2;
	      float ptot = sqrt(pt*pt + pz*pz);

	      float ptCorrected = pt;
	      if(useWrongPt) {
		px = px1Uncorrected + px2Uncorrected;
		py = py1Uncorrected + py2Uncorrected;
		pt = sqrt(px*px + py*py);
	      }
					
	      if(usePtDependentSeparation && pt > 0.0 ) {
		// Parameterization result is in cm, but need meters for checking
		double predictedMinimumDistance = 0.01*rescaleSeparationFactor*(aSeparationCoefficient/pt + bSeparationCoefficient/(pt*pt));
		if(dSeparationSquared < predictedMinimumDistance*predictedMinimumDistance) {
		  continue;
		} // check for passing pT dependent separation cut
	      }
							
	      float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
	      float openAngle = acos(cosOpenAngle);
	      bool failOpeningAngleCut = false;
	      if(useFixedOpeningAngleCut) {
		failOpeningAngleCut = true;
                
		// opening angle cut according to pT-Dependent parameterization
                
		float pTDependentOpenAngleCut = aOpenAngleCutParameter/pt + bOpenAngleCutParameter/(pt*pt);
		if(openAngle > pTDependentOpenAngleCut)
		  failOpeningAngleCut = false;
	      } // check on using pT-dependent opening angle parameterization
              
	      float massTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
	      if(!failOpeningAngleCut && massTest > 0.0) {
		massTest = sqrt(massTest);
		if(massTest > 0.225 && massTest < 0.275) {
		  if(pt > lowPtBinLimit[0] && pt < highPtBinLimit[3]) {
		    TimingClusterEvsTBgrnd->Fill(ecalTime[jClu], ecalEnergy[jClu]);
		    TimingClusterEvsTBgrnd->Fill(ecalTime[mClu], ecalEnergy[mClu]);

		    if(ecalEnergy[jClu] > 0.0) {
		      float energyInverse = 1.0/ecalEnergy[jClu];
		      float tCut = 4.0 - 10.8452*energyInverse + 14.9102*energyInverse*energyInverse -3.065*energyInverse*energyInverse*energyInverse;

		      if(ecalEnergy[jClu] > 1.123)
			tCut = 4.0;

		      if(tCut > 20)
			tCut = 20;

		      TimingClusterEvsTCut->Fill(tCut, ecalEnergy[jClu]);
		      TimingClusterEvsTCut->Fill(-tCut, ecalEnergy[jClu]);
		    }

		    if(ecalEnergy[mClu] > 0.0) {
		      float energyInverse = 1.0/ecalEnergy[mClu];
		      float tCut = 4.0 - 10.8452*energyInverse + 14.9102*energyInverse*energyInverse -3.065*energyInverse*energyInverse*energyInverse;

		      if(ecalEnergy[mClu] > 1.123)
			tCut = 4.0;

		      if(tCut > 20)
			tCut = 20;

		      TimingClusterEvsTCut->Fill(tCut, ecalEnergy[mClu]);
		      TimingClusterEvsTCut->Fill(-tCut, ecalEnergy[mClu]);
		    }

		  } // check low pT limits
		} // check for background mass regiom

		float pi0Theta = acos(pz/ptot);
		float pi0Eta = -log(tan(pi0Theta/2.0)); 
		float pi0Phi = atan2(py,px);

		if((massTest > lowLimitPi0Mass && massTest < highLimitPi0Mass) ||
                   (useTwoSideBands && (massTest > lowLimitSideBandMass && massTest < highLimitSideBandMass))) {

		  if(fabs(0.134976 - massTest) < widthForEfficiency) {
		    //
		    // reconstruction histograms for dynamic pi0 efficiency
		    //
		    reconstructedPi0YieldsPt->Fill(pt);
		    reconstructedPi0YieldsEta->Fill(pi0Eta);								
		    reconstructedPi0Yields->Fill(pt, pi0Eta);
		  }

		  if(pt > lowPtBinLimit[0] && pt < highPtBinLimit[3]) {
		    TimingClusterEvsT->Fill(ecalTime[jClu], ecalEnergy[jClu]);
		    TimingClusterEvsT->Fill(ecalTime[mClu], ecalEnergy[mClu]);
		    WeightedTimingClusterEvsT->Fill(weightedTime[jClu] - ecalTime[jClu], ecalEnergy[jClu]);
		    WeightedTimingClusterEvsT->Fill(weightedTime[mClu] - ecalTime[mClu], ecalEnergy[mClu]);
		  } // check pT limits

		  if(countRecoPi0Mass < MAXRECOPI0MASS) {

		    bool keepMass = true;
		    if(iOption >= 334 && iOption <= 337) {

		      if(pt > lowPtBinCompleteLimit[0] && pt <= highPtBinCompleteLimit[nPtBinsComplete-1] && pi0Eta > etaLowLimit && pi0Eta < etaHighLimit)
			nMult_trg++;
		      else
			keepMass = false;
		    } // check if filling 2D pair histograms
		    
		    if(keepMass) {
		      // firstPairMember[countRecoPi0Mass] = jClu;   for future use
		      // secondPairMember[countRecoPi0Mass] = mClu;  for future use
		      ptRecoPi0Mass[countRecoPi0Mass] = pt;
		      phiRecoPi0Mass[countRecoPi0Mass] = pi0Phi;
		      etaRecoPi0Mass[countRecoPi0Mass] = pi0Eta;	
		      countRecoPi0Mass++;
		    }
		  } // safety check

		} // check if this looks like a pi0 mass

		for(int kPt=0; kPt<nPtBins; kPt++) {
		  if(pt >= lowPtBinLimit[kPt] && pt < highPtBinLimit[kPt]) {
		    sameEventMassHistogramsPtBin[kPt]->Fill(massTest);
		    if(massTest > lowLimitPi0Mass && massTest < highLimitPi0Mass) {
		      sameEventEtaHistogramsPtBin[kPt]->Fill(pi0Eta);
		    }
		    unCorrectedPtBin[kPt]->Fill(pt);
		    correctedPtBin[kPt]->Fill(ptCorrected);
		    if(printPairContributors && kPt == 0 && countPairContributors_ < 3000 && massTest < 0.30) {
		      countPairContributors_++;
		      cout << "\n " << countPairContributors_ << ") ";
		      cout << " Cluster1 = " << kToJCluMap[jClu];
		      cout << ", with energy = " << energy1;
		      cout << ";  Cluster2 = " << kToJCluMap[mClu];
		      cout << ", with energy = " << energy2;
		      cout << "; pair mass = " << massTest;
		      cout << ", with pT = " << pt;
		      cout << ", in event = " << Event;
		      cout << "     [printContributors]";
		    } // check on printout

		    break;
		  }
		} // look for the pt bin

	      } // check on positive mass and not failing the opening angle cut
              
	      if(useRotatedBackground) {
		phi2 = phi2 + TMath::Pi();  // rotate phi angle by 180 degrees
		cosphi2 = cos(phi2);
		sinphi2 = sin(phi2);
                
		xCluster2 = rECal*cosphi2;
		yCluster2 = rECal*sinphi2;
                
		dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		  (yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		  (zCluster2 - zCluster1)*(zCluster2- zCluster1);
                
		dSeparation = sqrt(dSeparationSquared);
                
		if(dSeparation < minimumSeparation) {
		  countMixedEventSeparationCut++;
		  continue;
		}
                
		if(dSeparation <  minimumSeparationSameEvent)
		  minimumSeparationMixedEvent= dSeparation;
                
		px2 = pt2*cosphi2;
		py2 = pt2*sinphi2;
                
		px = px1 + px2;
		py = py1 + py2;
		pt = sqrt(px*px + py*py);
					
		if(usePtDependentSeparation && pt > 0.0 ) {
		  // Parameterization result is in cm, but need meters for checking
		  double predictedMinimumDistance = 0.01*rescaleSeparationFactor*(aSeparationCoefficient/pt + bSeparationCoefficient/(pt*pt));
		  if(dSeparationSquared < predictedMinimumDistance*predictedMinimumDistance) {
		    continue;
		  } // check for passing pT dependent separation cut
		}
                
		cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
		openAngle = acos(cosOpenAngle);
		failOpeningAngleCut = false;
		if(useFixedOpeningAngleCut) {
		  failOpeningAngleCut = true;
                  
		  // opening angle cut according to pT-Dependent parameterization
                  
		  float pTDependentOpenAngleCut = aOpenAngleCutParameter/pt + bOpenAngleCutParameter/(pt*pt);
		  if(openAngle > pTDependentOpenAngleCut)
		    failOpeningAngleCut = false;
		} // check on using pT-dependent opening angle parameterization
                
		massTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
		if(!failOpeningAngleCut && massTest > 0.0) {
		  massTest = sqrt(massTest);
		  for(int kPt=0; kPt<nPtBins; kPt++) {
		    if(pt >= lowPtBinLimit[kPt] && pt < highPtBinLimit[kPt]) {
		      mixedEventMassHistogramsPtBin[kPt]->Fill(massTest);
		      break;
		    }
		  } // look for the pt bin
		} // check on positive mass
                
	      } // check on using rotated cluster background
              
	    } // inner cluster loop
            
	  } // outer cluster loop
					
	  countTotalRecoPi0Mass += countRecoPi0Mass;

	  // cout << "\n countTotalRecoPi0Mass = " << countTotalRecoPi0Mass << endl;

	  if(iOption >= 334 && iOption <= 337) { // pair correlations plots

	    if(countRecoPi0Mass != nMult_trg) {
	      cerr << "\n Programming error: countRecoPi0Mass = " << countRecoPi0Mass << ", nMult_trg = " << nMult_trg << endl;
	      return;
	    }

	    if(countRecoPi0Mass > 0 && nMult_trg > 0) {
	      //
	      // Get the charged particle arrays, either using the MC charged particles or the reconstructed tracks
	      //
	      if(useMCTracks && countRecoPi0Mass == 0) {
		nTracksSize = nChMesonSize;
	      }

	      for(int pTrack=0; pTrack<nTracksSize; pTrack++) {

		float pt_ass = 0.0;
		float eta_ass = 0.0;
		float phi_ass = 0.0;

		if(useMCTracks && countRecoPi0Mass == 0) {
		  int thisPdgId = pdgIdChMeson[pTrack];
		  if(thisPdgId==211 || thisPdgId==-211 || thisPdgId==321 || thisPdgId==-321 || thisPdgId==2212 || thisPdgId==-2212) {
		    pt_ass = ptChMeson[pTrack];
		    eta_ass = etaChMeson[pTrack];
		    phi_ass = phiChMeson[pTrack];
		  }
		} // using MC charged particles
		else {
		  pt_ass = recoPairPtTrack[pTrack];
		  eta_ass = recoPairEtaTrack[pTrack];
		  phi_ass = recoPairPhiTrack[pTrack];
		} // using reconstructed particle tracks
	      
		if(pt_ass >= ptMin_ass && pt_ass <= ptMax_ass && fabs(eta_ass) < 2.4) {

		  if(nMult_ass < MAXBACKGROUNDSIZE) {
		    etaThisEvent[nMult_ass] = eta_ass;
		    phiThisEvent[nMult_ass] = phi_ass;
		    efficiencyThisEvent[nMult_ass] = 1.0;
		    if(useTrackEfficiencyTable) {
		      efficiencyThisEvent[nMult_ass] = efficiencyTrackYieldsRead->GetBinContent(efficiencyTrackYieldsRead->FindBin(eta_ass, pt_ass));
		    }
		    nMult_ass++;
		  } // check size
		  else {
		    cerr << "\n Too many charged particles" << endl;
		    return;
		  } // safety check

		} // check kinematic values
	      } // loop over tracks

	      if(nMult_ass > nTracksSize) {
		cerr << "\n Programming error: nMult_ass = " << nMult_ass << ", but nTracks = " << nTracksSize << endl;
		return;
	      }

	      float fillFactor = 1.0/4.0/nMult_trg;  // filling factor used by Monika

	      for(int kPi0=0; kPi0<countRecoPi0Mass; kPi0++) {
		float pt_trg = recoPtChange*ptRecoPi0Mass[kPi0];
		int kPtIndex = -1;
		for(int kPt=0; kPt<nPtBinsComplete; kPt++) {

		  if(pt_trg > lowPtBinCompleteLimit[kPt] && pt_trg <= highPtBinCompleteLimit[kPt]) {
		    kPtIndex = kPt;
		    break;
		  } // check for correct pt index
		} // loop over all pT values

		if(kPtIndex == -1)
		  continue;

		if(kPtIndex >= 0 && kPtIndex < nPtBinsComplete) {
		  nTriggers_PtBin[kPtIndex]++;
		}
		else {
		  cerr << "\n Programming error: invalid value for integer kPtIndex = " << kPtIndex << endl;
		  return;
		}

		float phi_trg = phiRecoPi0Mass[kPi0];
		float eta_trg = etaRecoPi0Mass[kPi0];

		float efficiencyPi0 = 1.0; // default weight for this trigger particle
		if(usePi0EfficiencyTable) {
		  //
		  // should do a first order, bi-linear interpolation
		  //
		  efficiencyPi0 = efficiencyPi0YieldsRead->GetBinContent(efficiencyPi0YieldsRead->FindBin(pt_trg, eta_trg));
		  if(efficiencyPi0 > 0.0 && efficiencyPi0 < 1.0) {
		    fillFactor = (1.0/4.0/nMult_trg)/efficiencyPi0;  //  boost the weight of this trigger particle by the inverse of the efficiencyPi0
		  }  // check for good efficiencyPi0 numbers
		} // check if using the efficiencyPi0 table

		//
		// Look for associated charged particles in same event
		//
		for(int pTrack=0; pTrack< nMult_ass; pTrack++) {

		  float eta_ass = etaThisEvent[pTrack];
		  float phi_ass = phiThisEvent[pTrack];

		  float deltaEta = eta_trg - eta_ass;

		  // How does this code different from the standard CMS function for Delta-Phi?
		  double deltaPhiSharma = phi_ass - phi_trg;
		  double deltaPhiCMS = deltaPhi(phi_ass, phi_trg);

		  double phiDelta = deltaPhiSharma;
		  if(useDeltaPhiCMS)
		    phiDelta = deltaPhiCMS;

		  if(phiDelta > TMath::Pi()) phiDelta = phiDelta - 2*TMath::Pi();
		  if(phiDelta < -TMath::Pi()) phiDelta = phiDelta + 2*TMath::Pi();
		  if(phiDelta > -TMath::Pi() && phiDelta < -TMath::Pi()/2.0) phiDelta = phiDelta + 2*TMath::Pi();

		  if(deltaEta == 0 && phiDelta == 0)
		    continue;

		  float efficiencyTrackInverse = 1.0/efficiencyThisEvent[pTrack];

		  //
		  // Monika's hSignal histogram filling
		  //
		  if(useEtaSymmetry) {
		    hRecoSignalPtBin[kPtIndex]->Fill(fabs(deltaEta),fabs(phiDelta),fillFactor*efficiencyTrackInverse);
		    hRecoSignalPtBin[kPtIndex]->Fill(-fabs(deltaEta),fabs(phiDelta),fillFactor*efficiencyTrackInverse);
		    hRecoSignalPtBin[kPtIndex]->Fill(fabs(deltaEta),-fabs(phiDelta),fillFactor*efficiencyTrackInverse);
		    hRecoSignalPtBin[kPtIndex]->Fill(-fabs(deltaEta),-fabs(phiDelta),fillFactor*efficiencyTrackInverse);
		    hRecoSignalPtBin[kPtIndex]->Fill(fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactor*efficiencyTrackInverse);
		    hRecoSignalPtBin[kPtIndex]->Fill(-fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactor*efficiencyTrackInverse);
		  }
		  else {
		    hRecoSignalPtBin[kPtIndex]->Fill(deltaEta, fabs(phiDelta), 2.0*fillFactor*efficiencyTrackInverse);
		    hRecoSignalPtBin[kPtIndex]->Fill(deltaEta, -fabs(phiDelta), 2.0*fillFactor*efficiencyTrackInverse);
		    hRecoSignalPtBin[kPtIndex]->Fill(deltaEta, 2*TMath::Pi()-fabs(phiDelta), 2.0*fillFactor*efficiencyTrackInverse);
		  }
		    		      
		} // loop on pTrack for same event charged particle tracks

		//
		// Look for associated charged particles in the buffer events
		//

		int useBufferDepth = 1 + kPtIndex;
		if(testConversion || useTripleRecoDepth)
		  useBufferDepth *= 3;

		if(useBufferDepth > NBUFFERDEPTH)
		  useBufferDepth = NBUFFERDEPTH;

		if(kPtIndex == -1 && nBuffersFilled >= NBUFFERDEPTH) {
		  cout << "\n nMult_ass " << nMult_ass << ", kPtIndex " << kPtIndex << ", nBuffersFilled " << nBuffersFilled <<  ", nLast_ass " << nLastBuffer[0] << endl;
		  return;
		}

		if(nBuffersFilled >= useBufferDepth) {
		  for(int kBuffer=0; kBuffer<useBufferDepth; kBuffer++) {

		    nLast_ass = nLastBuffer[kBuffer];

		    if(nLast_ass < 1)
		      continue;

		    float fillFactorAssociated = (1.0/nMult_trg/nLast_ass)/efficiencyPi0;  // efficiencyPi0 number = 1 unless the efficiencyPi0 tables are used
		    
		    for(int pTrack=0; pTrack<nLast_ass; pTrack++) {		  
		      //
		      // Look for associated charged particles in buffer event
		      //

		      float eta_ass = etaLastEvent[pTrack][kBuffer];
		      float phi_ass = phiLastEvent[pTrack][kBuffer];
		    
		      float deltaEta = eta_trg - eta_ass;

		      // How does this code different from the standard CMS function for Delta-Phi?
		      double deltaPhiSharma = phi_ass - phi_trg;
		      double deltaPhiCMS = deltaPhi(phi_ass, phi_trg);

		      double phiDelta = deltaPhiSharma;
		      if(useDeltaPhiCMS)
			phiDelta = deltaPhiCMS;

		      if(phiDelta > TMath::Pi()) phiDelta = phiDelta - 2*TMath::Pi();
		      if(phiDelta < -TMath::Pi()) phiDelta = phiDelta + 2*TMath::Pi();
		      if(phiDelta > -TMath::Pi() && phiDelta < -TMath::Pi()/2.0) phiDelta = phiDelta + 2*TMath::Pi();

		      if(deltaEta == 0 && phiDelta == 0)
			continue;

		      float efficiencyTrackInverse = 1.0/efficiencyLastEvent[pTrack][kBuffer];

		      //
		      // Monika's mixed-event histogram filling
		      //
		      if(useEtaSymmetry) {
			hRecoBackgroundPtBin[kPtIndex]->Fill(fabs(deltaEta),fabs(phiDelta),fillFactorAssociated*efficiencyTrackInverse);
			hRecoBackgroundPtBin[kPtIndex]->Fill(-fabs(deltaEta),fabs(phiDelta),fillFactorAssociated*efficiencyTrackInverse);
			hRecoBackgroundPtBin[kPtIndex]->Fill(fabs(deltaEta),-fabs(phiDelta),fillFactorAssociated*efficiencyTrackInverse);
			hRecoBackgroundPtBin[kPtIndex]->Fill(-fabs(deltaEta),-fabs(phiDelta),fillFactorAssociated*efficiencyTrackInverse);
			hRecoBackgroundPtBin[kPtIndex]->Fill(fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactorAssociated*efficiencyTrackInverse);
			hRecoBackgroundPtBin[kPtIndex]->Fill(-fabs(deltaEta),2*TMath::Pi()-fabs(phiDelta),fillFactorAssociated*efficiencyTrackInverse); 
		      }
		      else {
			hRecoBackgroundPtBin[kPtIndex]->Fill(deltaEta, fabs(phiDelta), 2.0*fillFactorAssociated*efficiencyTrackInverse);
			hRecoBackgroundPtBin[kPtIndex]->Fill(deltaEta, -fabs(phiDelta), 2.0*fillFactorAssociated*efficiencyTrackInverse);
			hRecoBackgroundPtBin[kPtIndex]->Fill(deltaEta, 2*TMath::Pi()-fabs(phiDelta), 2.0*fillFactorAssociated*efficiencyTrackInverse);
		      }
   
		    } // loop on pTrack for buffer event charged particles

		  } // loop over buffer events

		} // check if all the buffer event arrays have been filled

	      } // loop over reconstructed pi0

	    } // check for at least one reconstructed pi0

	    nTrgTotal += nMult_trg;

	    if(i%nEntries10 == 0 || i < 10) {
	      cout << "; nMult_trg = " << nMult_trg << ",  nMult_ass = " << nMult_ass << ",  nTrgTotal = " << nTrgTotal;
	      cout << ", nPairTracksSize " << nPairTracksSize <<  ", nTracksSize " << nTracksSize;
	    }

	    //
	    // transfer this event to the buffer event arrays
	    //
	    if(currentBufferIndex < 0 || currentBufferIndex >= NBUFFERDEPTH) {
	      cerr << "\n Error in currentBufferIndex value " << currentBufferIndex << endl;
	      return;
	    }
	    for(int pTrack=0; pTrack<nMult_ass; pTrack++) {
	      etaLastEvent[pTrack][currentBufferIndex] = etaThisEvent[pTrack];
	      phiLastEvent[pTrack][currentBufferIndex] = phiThisEvent[pTrack];
	      efficiencyLastEvent[pTrack][currentBufferIndex] = efficiencyThisEvent[pTrack];
	    }
	    nLastBuffer[currentBufferIndex] = nMult_ass;
	    nBuffersFilled++;

	    currentBufferIndex++;
	    if(currentBufferIndex == NBUFFERDEPTH)
	      currentBufferIndex = 0;

	    continue; // skip rest of processing

	  } // check for pair correlation plots in this event

	  /*

	  //
	  // Check for opening angles between pairs of pi0
	  //
	  if(countRecoPi0Mass > 1) {
	    int countRecoPi0MassMinusOne = countRecoPi0Mass - 1;
	    for(int kPi0=0; kPi0<countRecoPi0MassMinusOne; kPi0++) {
	      int firstClu = firstPairMember[kPi0];
	      int jClu1 = kToJCluMap[firstClu];
	      bool trueDecayFirst = false;
	      if(countNoConvertSimMatchEcal[jClu1] > 0 && bestNoConvertSimAngleEcal[jClu1] < 0.02) {
		int jSim =  bestNoConvertSimIndexEcal[jClu1];
		if(gMotherGenIdSim[jSim] > -1)
		  trueDecayFirst = true;
	      }
							
	      int secondClu = secondPairMember[kPi0];
	      int mClu1 = kToJCluMap[secondClu];
	      bool trueDecaySecond = false;
	      if(countNoConvertSimMatchEcal[mClu1] > 0 && bestNoConvertSimAngleEcal[mClu1] < 0.02) {
		int jSim =  bestNoConvertSimIndexEcal[mClu1];
		if(gMotherGenIdSim[jSim] > -1)
		  trueDecaySecond = true;
	      }
					
	      if(trueDecayFirst && trueDecaySecond)
		countTrueDecayMesons++;

	      float phi1 = phiRecoPi0Mass[kPi0];
	      float eta1 = etaRecoPi0Mass[kPi0];
		
	      int kPi0PlusOne = kPi0 + 1;
	      for(int jPi0=kPi0PlusOne; jPi0<countRecoPi0Mass; jPi0++) {
		int thirdClu = firstPairMember[jPi0];
		int jClu2 = kToJCluMap[thirdClu];
		bool trueDecayThird = false;
		if(countNoConvertSimMatchEcal[jClu2] > 0 && bestNoConvertSimAngleEcal[jClu2] < 0.02) {
		  int jSim =  bestNoConvertSimIndexEcal[jClu2];
		  if(gMotherGenIdSim[jSim] > -1)
		    trueDecayThird = true;
		}
						
		int fourthClu = secondPairMember[jPi0];
		int mClu2 = kToJCluMap[fourthClu];
		bool trueDecayFourth = false;
		if(countNoConvertSimMatchEcal[mClu2] > 0 && bestNoConvertSimAngleEcal[mClu2] < 0.02) {
		  int jSim =  bestNoConvertSimIndexEcal[mClu2];
		  if(gMotherGenIdSim[jSim] > -1)
		    trueDecayFourth = true;
		}		

		if(trueDecayThird && trueDecayFourth)
		  countTrueDecayMesons++;

		float phi2 = phiRecoPi0Mass[jPi0];
		float eta2 = etaRecoPi0Mass[jPi0];
								
		float phiDelta = asin(sin(phi1 - phi2));
		float etaDelta = eta1 - eta2;
								
		float pairOpenAngle = sqrt(etaDelta*etaDelta + phiDelta*phiDelta);
		if(pairOpenAngle < PI0PAIROPENCUT) {
		  countTaggedRecoPi0Mass += 2;

		  if(taggedCluster[firstClu] == 0) {
		    countTaggedClusters++;
		    if(trueDecayFirst)
		      countTrueDecayPhotons++;
		  }
		  taggedCluster[firstClu]++;

		  if(taggedCluster[secondClu] == 0) {
		    countTaggedClusters++;
		    if(trueDecaySecond)
		      countTrueDecayPhotons++;
		  }
		  taggedCluster[secondClu]++;

		  if(taggedCluster[thirdClu] == 0) {
		    countTaggedClusters++;
		    if(trueDecayThird)
		      countTrueDecayPhotons++;
		  }
		  taggedCluster[thirdClu]++;

		  if(taggedCluster[fourthClu] == 0) {
		    countTaggedClusters++;
		    if(trueDecayFourth)
		      countTrueDecayPhotons++;
		  }
		  taggedCluster[fourthClu]++;

		} // check on opening angle
								
	      } // inner loop over jPi0;
	    } // outer loop over kPi0
	  } // check for countRecoPi0Mass >= 2

	  */

	}  // check for at least two clusters
        
	if(!useRotatedBackground) {
          
	  if(kArray > 0) {
            
	    if(kDebugPrint < 0) {
	      cout << "\n kArray = " << kArray;
	      cout << ",  kArrayLast = " << kArrayLast;
	      cout << endl;
	      kDebugPrint++;
	      if(kDebugPrint >= 10)
		return;
	    }
            
	    if(kArrayLast > 0) {
              
	      if(kDebugPrint < 00) {
		cout << "\n Start mixed-event with kArray = " << kArray;
		cout << ", kArrayLast = " << kArrayLast;
		cout << endl;
		kDebugPrint++;
		if(kDebugPrint >= 10)
		  return;
	      }
              
	      for(int jClu=0; jClu<kArray; jClu++) {
                
		int indexFirstCluster = motherGenIndexSimClusterLast[jClu];

		if(selectConversionOnly && !convertedCluster[jClu])
		  continue;

		if(selectNonConversionOnly && convertedCluster[jClu])
		  continue;

		float cosTheta1 = cos(ecalTheta[jClu]);
		float sinTheta1 = sin(ecalTheta[jClu]);
		float phi1 = ecalPhi[jClu];
		float cosphi1 = cos(phi1);
		float sinphi1 = sin(phi1);
		float energy1 = ecalEnergy[jClu];
                
		float xCluster1 = rECal*cosphi1;
		float yCluster1 = rECal*sinphi1;
		float zCluster1 = rECal/tan(ecalTheta[jClu]);
                
		float pt1 = energy1*sinTheta1;
		float px1 = pt1*cosphi1;
		float py1 = pt1*sinphi1;
						
		float px1Uncorrected = px1;
		float py1Uncorrected = py1;

		if(useWrongPt) {
		  float unCorrectionFactor = ecalEnergyUncorrectedArray[jClu]/energy1;
		  px1Uncorrected *= unCorrectionFactor;
		  py1Uncorrected *= unCorrectionFactor;
		}
                
		int jCrystal = kCrystal[jClu];
                
		for(int mClu=0; mClu<kArrayLast; mClu++) {

		  int mCrystal = kCrystalLast[mClu];

		  int indexSecondCluster = motherGenIndexSimClusterLast[mClu];

		  if(selectSameParentClusters) {
		    if(indexFirstCluster < 0 || indexSecondCluster < 0 ||  indexFirstCluster != indexSecondCluster)
		      continue;
		  }

		  if(selectDifferentParentClusters) {
		    if(indexFirstCluster < 0 || indexSecondCluster < 0 ||  indexFirstCluster == indexSecondCluster)
		      continue;
		  }
		  if(selectConversionOnly && !convertedClusterLast[mClu])
		    continue;

		  if(selectNonConversionOnly && convertedClusterLast[mClu])
		    continue;

		  bool mixedPair = false;
		  if((convertedCluster[jClu] && !convertedClusterLast[mClu]) ||
		     (!convertedCluster[jClu] && convertedClusterLast[mClu]))
		    mixedPair = true;

		  if(selectConversionMixed && !mixedPair)
		    continue;
   
		  float cosTheta2 = cos(ecalThetaLast[mClu]);
		  float sinTheta2 = sin(ecalThetaLast[mClu]);
		  float phi2 = ecalPhiLast[mClu];
		  float cosphi2 = cos(phi2);
		  float sinphi2 = sin(phi2);
		  float energy2 = ecalEnergyLast[mClu];
                  
		  if(useClusterEnergyAsymmetryCut) {
		    float ratio = fabs(energy1 - energy2)/(energy1 + energy2);
		    if(ratio > clusterEnergyAsymmetryCutSize) {
		      countMixedEventAsymmetryCut++;
		      continue;
		    }
		  } // check on using aysmmetery cut
                  
		  float xCluster2 = rECal*cosphi2;
		  float yCluster2 = rECal*sinphi2;
		  float zCluster2 = rECal/tan(ecalThetaLast[mClu]);
                  
		  float dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		    (yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		    (zCluster2 - zCluster1)*(zCluster2- zCluster1);
                  
		  float dSeparation = sqrt(dSeparationSquared);
		  if(dSeparation < minimumSeparation) {
		    countMixedEventSeparationCut++;
		    continue;
		  }
                  
		  if(dSeparation < minimumSeparationMixedEvent)
		    minimumSeparationMixedEvent= dSeparation;
                  
		  float pt2 = energy2*sinTheta2;
		  float px2 = pt2*cosphi2;
		  float py2 = pt2*sinphi2;

		  float px2Uncorrected = px2;
		  float py2Uncorrected = py2;

		  if(useWrongPt) {
		    float unCorrectionFactor = ecalEnergyUncorrectedArrayLast[mClu]/energy2;
		    px1Uncorrected *= unCorrectionFactor;
		    py2Uncorrected *= unCorrectionFactor;
		  }
                  
		  float px = px1 + px2;
		  float py = py1 + py2;
		  float pt = sqrt(px*px + py*py);

		  if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || pt < clusterCrystalLimitLowPtOnly)) {
		    if(jCrystal < lowCrystalLimit || jCrystal > highCrystalLimit ||
		       mCrystal < lowCrystalLimit || mCrystal > highCrystalLimit) {
		      continue;
		    }
		  } // check for using the cluster crystal limits up to only a pT cut value, mixed event

		  if(useClusterPairCrystalSumLimit && (!useClusterCrystalLimitLowPtOnly || pt < clusterCrystalLimitLowPtOnly)) {
		    int clusterPairCrystalSum = jCrystal + mCrystal;
		    if(clusterPairCrystalSum < lowClusterPairCrystalSumLimit ||
		       clusterPairCrystalSum > highClusterPairCrystalSumLimit)
		      continue;
		  } // check for using crystal sum limit, mixed event

		  if(useWrongPt) {
		    px = px1Uncorrected + px2Uncorrected;
		    py = py1Uncorrected + py2Uncorrected;
		    pt = sqrt(px*px + py*py);
		  }
					
		  if(usePtDependentSeparation && pt > 0.0 ) {
		    // Parameterization result is in cm, but need meters for checking
		    double predictedMinimumDistance = 0.01*rescaleSeparationFactor*(aSeparationCoefficient/pt + bSeparationCoefficient/(pt*pt));
		    if(dSeparationSquared < predictedMinimumDistance*predictedMinimumDistance) {
		      continue;
		    } // check for passing pT dependent separation cut
		  }
                  
		  float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
		  float openAngle = acos(cosOpenAngle);
                  
		  bool failOpeningAngleCut = false;
		  if(useFixedOpeningAngleCut)
		    failOpeningAngleCut = true;
                  
		  if(useFixedOpeningAngleCut) {
                    
		    // opening angle cut according to pT-Dependent parameterization
                    
		    float pTDependentOpenAngleCut = aOpenAngleCutParameter/pt + bOpenAngleCutParameter/(pt*pt);
		    if(openAngle > pTDependentOpenAngleCut)
		      failOpeningAngleCut = false;
		  } // check on using pT-dependent opening angle parameterization
                  
		  float massTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
		  if(!failOpeningAngleCut && massTest > 0.0) {
		    massTest = sqrt(massTest);
		    for(int kPt=0; kPt<nPtBins; kPt++) {
		      if(pt >= lowPtBinLimit[kPt] && pt < highPtBinLimit[kPt]) {
			mixedEventMassHistogramsPtBin[kPt]->Fill(massTest);
			break;
		      }
		    } // look for the pt bin
		  } // check on positive mass
                  
		} // previous event cluster loop
                
	      } // current event cluster loop
              
	    } // check if at least two clusters in the previous event
            
            //
            // Put current event arrays into last event arrays
            //
	    kArrayLast = kArray;
	    for(int jClu=0; jClu<kArrayLast; jClu++) {
	      kCrystalLast[jClu] = kCrystal[jClu];
	      motherGenIndexSimClusterLast[jClu] = motherGenIndexSimCluster[jClu];
	      //  motherGenIdSimClusterLast[jClu] = motherGenIdSimCluster[jClu];  for future use
	      convertedClusterLast[jClu] = convertedCluster[jClu] ;
	      ecalEnergyLast[jClu] = ecalEnergy[jClu];
	      ecalEnergyUncorrectedArrayLast[jClu] = ecalEnergyUncorrectedArray[jClu];
	      ecalThetaLast[jClu] = ecalTheta[jClu];
	      ecalPhiLast[jClu] = ecalPhi[jClu];
	    } // moving current event cluster information to the previous arrays
            
	  } // check if at least two clusters in current event to do mixed-event background
          
	} // check on not using rotated cluster background method
        
      } // loop on entries
      
      cout << "\n\n max array size = " << maxArraySize;
      cout << "\n events failing Z-Vertex cut = " << countZVertexCut;
      cout << "\n number of clusters = " << countTotalClusters;
      cout << "\n number of clusters failing isolation cut = " << countIsolationCut;
      cout << "\n number of same-event asymmetry cut = " << countSameEventAsymmetryCut;
      cout << "\n number of mixed-event asymmetry cut = " << countMixedEventAsymmetryCut;
      cout << "\n number of unconverted photons from parent mesons not produced by resonance decays = " << countNonDecayParents;
      cout << "\n number of unconverted photons from parent mesons produced by resonance decays = " << countDecayParents;
      cout << "\n number of converted photons = " << countConvertedPhotons;
      cout << "\n number of track-matched clusters = " <<countMatchedClusters;
      cout << "\n minimum separation same events = " << minimumSeparationSameEvent;
      cout << "\n minimum separation mixed events = " << minimumSeparationMixedEvent;
      cout << "\n number of same event pairs failing separation cut = " << countSameEventSeparationCut;
      cout << "\n number of mixed event pairs failing separation cut = " << countMixedEventSeparationCut;
      cout << "\n number of pair masses within the pi0 mass window = " << countTotalRecoPi0Mass;
      cout << "\n number of pair masses within resonance decay window = " << countTaggedRecoPi0Mass;
      cout << "\n number of true decay mesons = " << countTrueDecayMesons;
      cout << "\n number of tagged clusters " << countTaggedClusters;
      cout << "\n number of true decay photons " << countTrueDecayPhotons;
      cout << "\n number of photons examined for shape cuts " << totalShapeExaminePhotons;
      cout << "\n number of photons failing shape cuts " << totalShapeCutPhotons;
      cout << endl << endl;

      if(iOption == 334) {
	c1->Divide(2,2);
	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);
	  hRecoSignalPtBin[kPt]->Draw("SURF1");
	}
	return;
      } // iOption = 334

      if(iOption == 335) {
	c1->Divide(2,2);
	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);
	  hRecoBackgroundPtBin[kPt]->Draw("SURF1");
	}
	return;
      } // iOption = 335

      if((iOption == 336 || iOption == 337) && nTrgTotal > 0) {

	float etaMin = 2.0;
	float etaMax = 3.6;
    
	TString Name = "projClone";
	TString Name2 = "pi0HadProj";
	TString Name4 = "FourierDecompose";
	TString Name1, Name3, Name5;
    
	TH2D *projCorrFunc[9];
	TH1D *pi0HadCorrProj[9];
	TF1 *FourierDecompose[9];
	const int n = 9;

	double Parameter2[n];
	double Par2Error[n];
	double Parameter3[n];
	double Par3Error[n];

	long kPtLimit = nPtBinsComplete;
	float xPositionAdd = 0.0;
	if(useClusterCrystalLimit && highCrystalLimit < 4) {
	  c1->Divide(1,2);
	  kPtLimit = 2;
	  xPositionAdd = 0.43;
	}
	else {
	  c1->Divide(3,3);
	}

	double etabinwidth = hRecoSignalPtBin[0]->GetXaxis()->GetBinWidth(1);
	double phibinwidth = hRecoSignalPtBin[0]->GetYaxis()->GetBinWidth(1);
	double binWidthFactor = 1.0/etabinwidth/phibinwidth;
	const float v2ChargedInverseEPOS = 1.0/0.232;    // v2 of the EPOS generator charged particles, 0.3 - 3.0 GeV/c, according to Z. Chen (May 4, 2014, K0-short analysis)
	const float v2ChargedInverseData = 1.0/0.08609;  // v2 of the pPb data charged particles, 0.3 - 3.0 GeV/c, according to Monika

	float v2ChargedInverse = v2ChargedInverseEPOS;
	if(!simRun)
	  v2ChargedInverse = v2ChargedInverseData;
	  
	for(long kPt=0; kPt<kPtLimit; kPt++) {

	  v2FitValue[kPt] = 0.0;
	  v2FitError[kPt] = 0.0;

	  c1->cd(kPt+1);

	  hRecoSignalPtBin[kPt]->Divide(hRecoBackgroundPtBin[kPt]);
	  if(simRun)
	    sprintf(histogramTitle, "MC: Signal #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f GeV/c", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);
	  if(!simRun)
	    sprintf(histogramTitle, "pPb Data: Signal #pi^{0}-h^{#pm} correlation for %5.2f < p_{T} < %5.2f GeV/c", lowPtBinCompleteLimit[kPt], highPtBinCompleteLimit[kPt]);

	  float errorBase = 0.001*sqrt(float(nMult_trgAllEventsPt[kPt])/float(nTriggers_PtBin[kPt]));

	  int x0 = hRecoBackgroundPtBin[kPt]->GetXaxis()->FindBin(0.0);
	  int y0 = hRecoBackgroundPtBin[kPt]->GetYaxis()->FindBin(0.0);
	  double B0 = hRecoBackgroundPtBin[kPt]->GetBinContent(x0,y0);
	  if(B0 <= 0.0 || nEventsTotal <= 0) {
	    cerr << "\n Error B0 = " << B0 << ",  nEventsTotal = " << nEventsTotal << endl;
	    return;
	  }
	  hRecoSignalPtBin[kPt]->SetTitle(histogramTitle);
	  hRecoSignalPtBin[kPt]->Scale(B0/nEventsTotal);
	  hRecoSignalPtBin[kPt]->Scale(binWidthFactor);
	  hRecoSignalPtBin[kPt]->GetZaxis()->SetNdivisions(505);

	  hRecoSignalPtBin[kPt]->GetXaxis()->SetRange(5,29);

	  if(iOption == 336)
	    hRecoSignalPtBin[kPt]->Draw("SURF1");

	  if(iOption == 337) {
	    Name1 = Name + kPt;
	    Name3 = Name2 + kPt;
	    Name5 = Name4 + kPt;

	    projCorrFunc[kPt] = (TH2D*)hRecoSignalPtBin[kPt]->Clone(Name1);
 
	    int etabin10m = projCorrFunc[kPt]->GetXaxis()->FindBin(etaMin+0.01);
	    int etabin10p = projCorrFunc[kPt]->GetXaxis()->FindBin(etaMax-0.01);

	    pi0HadCorrProj[kPt] = (TH1D *) projCorrFunc[kPt]->ProjectionY(Name3,etabin10m,etabin10p,"e");
	    pi0HadCorrProj[kPt]->GetXaxis()->SetRange(8,24);

	    pi0HadCorrProj[kPt]->SetMarkerColor(4);
	    pi0HadCorrProj[kPt]->SetMarkerStyle(20);
	    pi0HadCorrProj[kPt]->SetMarkerSize(1.0);

	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitle("#Delta#phi (radians)");
	    pi0HadCorrProj[kPt]->GetXaxis()->SetLabelFont(42);
	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitleSize(0.06);
	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitleOffset(0.67);
	    pi0HadCorrProj[kPt]->GetXaxis()->SetTitleFont(42);

	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitle("Associated yield");
	    pi0HadCorrProj[kPt]->GetYaxis()->SetLabelFont(42);
	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitleSize(0.06);
	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitleOffset(0.77);
	    pi0HadCorrProj[kPt]->GetYaxis()->SetTitleFont(42);

	    int nBinsX = pi0HadCorrProj[kPt]->GetNbinsX();
	    int nHalfBinsX = nBinsX/2;
	    float errorFactor = (1.0+ pow(float(kPt),1.25))*errorBase;

	    if(kPt > 5)
	      errorFactor *= 2.0;

	    for(int kBin=1; kBin<=nBinsX; kBin++) {
	      double value = pi0HadCorrProj[kPt]->GetBinContent(kBin);
	      pi0HadCorrProj[kPt]->SetBinError(kBin, errorFactor*(2.0-fabs(float(kBin-nHalfBinsX)/float(nHalfBinsX)))*value);
	    }

	    pi0HadCorrProj[kPt]->SetStats(0);
	    float maximumHistogramValue = pi0HadCorrProj[kPt]->GetMaximum();
	    float minimumHistogramValue = pi0HadCorrProj[kPt]->GetMinimum();
	    pi0HadCorrProj[kPt]->SetMaximum(maximumHistogramValue + 0.50*(maximumHistogramValue - minimumHistogramValue));

	    pi0HadCorrProj[kPt]->Draw("E1");

	    (c1->cd(kPt+1))->SetGrid();

	    if(useV1V2Fit) {
	      FourierDecompose[kPt] = new TF1(Name5, v1v2Fit, -1.4, 4.88, 3);
	      FourierDecompose[kPt]->SetParNames("Norm","v1", "v2");
	    }

	    if(useV2FitOnly) {
	      FourierDecompose[kPt] = new TF1(Name5, v2Fit, -1.4, 4.88, 2);
	      FourierDecompose[kPt]->SetParNames("Norm","v2");
	      FourierDecompose[kPt]->SetParameters(1.0, 0.2);
	    }
	    
	    if(!useV2FitOnly && !useV1V2Fit) {
	      FourierDecompose[kPt] = new TF1(Name5, FourierFunction, -1.4, 4.88, 4);
	      FourierDecompose[kPt]->SetParNames("Norm", "v1", "v2", "v3");
	      FourierDecompose[kPt]->SetParameters(1.0, 0.1, 0.2, 0.3);
	    }

	    pi0HadCorrProj[kPt]->Fit(Name5, "", "", -1.4, 4.84);

	    double v1 = 0;
	    double v1Error = 0;

	    if(useV1V2Fit) {
	      v1 = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(1);
	      v1Error = v2ChargedInverse*FourierDecompose[kPt]->GetParError(1);

	      Parameter2[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(2);
	      Par2Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(2);

	    } // using a v1 + v2 fit function

	    if(useV2FitOnly) {
	      Parameter2[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(1);
	      Par2Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(1);
	    } // using a pure v2 fit function
	    
	    if(!useV2FitOnly && !useV1V2Fit) {
	      Parameter2[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(2);
	      Par2Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(2);
	      Parameter3[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParameter(3);
	      Par3Error[kPt] = v2ChargedInverse*FourierDecompose[kPt]->GetParError(3);
	    }

	    v2FitValue[kPt] = Parameter2[kPt];
	    v2FitError[kPt] = Par2Error[kPt];

	    TLegend *legend = new TLegend(0.15, 0.69, 0.88, 0.85);
	    char *legendHeader = new char[200];
	    if(simRun) {
	      sprintf(legendHeader, "RECO-EPOS pPb: #pi^{0} triggers for this p_{T} bin = %d", nTriggers_PtBin[kPt]); 
	    }
	    if(!simRun) {
	      sprintf(legendHeader, "RECO-Data pPb: #pi^{0} triggers for this p_{T} bin = %d", nTriggers_PtBin[kPt]); 
	    }
	    legend->SetHeader(legendHeader);
	    legend->SetTextSize(0.04);
	    legend->SetTextColor(kBlue);

	    char *fitResult = new char[200];

	    if(useV1V2Fit) {
	      sprintf(fitResult, "v_{2} = %4.3f #pm %4.3f, v_{1} = %4.3f #pm %4.3f", Parameter2[kPt], Par2Error[kPt], v1, v1Error); 
	    }

	    if(useV2FitOnly) {
	      sprintf(fitResult, "v_{2} = %4.3f #pm %4.3f (pure v_{2} fit)", Parameter2[kPt], Par2Error[kPt]); 
	    }

	    if(!useV2FitOnly && !useV1V2Fit) {
	      sprintf(fitResult, "v_{2} = %4.3f #pm %4.3f, v_{3} = %4.3f #pm %4.3f", Parameter2[kPt], Par2Error[kPt], Parameter3[kPt], Par3Error[kPt]); 
	    }
	    legend->AddEntry(Name5, fitResult, "l");
	    legend->Draw();

	    if(kPt == 0) {

	      //
	      // Extra labeling for top left plot
	      //
	      float maximumHistogramValue1 = pi0HadCorrProj[kPt]->GetMaximum();

	      char *recoLabel1 = new char[60];
	      sprintf(recoLabel1, "Total #pi^{0} trigger particles =  %d", nTrgTotal);
	      TLatex *recoText1 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.63*(maximumHistogramValue1-minimumHistogramValue), recoLabel1);
	      recoText1->SetTextColor(2);
	      recoText1->SetTextSize(0.045);
	      recoText1->Draw();

	      if(useConversionSuppression) {
		TLatex *recoText2 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.53*(maximumHistogramValue1-minimumHistogramValue), "Conversions suppressed for #pi^{0} RECO");
		recoText2->SetTextColor(2);
		recoText2->SetTextSize(0.042);
		recoText2->Draw();
	      }

	      if(selectConversionOnly) {
		TLatex *recoText2 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.53*(maximumHistogramValue1-minimumHistogramValue), "Conversion clusters only for #pi^{0} RECO");
		recoText2->SetTextColor(2);
		recoText2->SetTextSize(0.042);
		recoText2->Draw();
	      }
	      
	      if(selectNonConversionOnly) {
		TLatex *recoText2 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.53*(maximumHistogramValue1-minimumHistogramValue), "Non-conversion clusters only for #pi^{0} RECO");
		recoText2->SetTextColor(2);
		recoText2->SetTextSize(0.042);
		recoText2->Draw();
	      }

	      if(selectSameParentClusters) {
		TLatex *recoText2 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.53*(maximumHistogramValue1-minimumHistogramValue), "Only same parent photons used for #pi^{0} RECO");
		recoText2->SetTextColor(2);
		recoText2->SetTextSize(0.042);
		recoText2->Draw();
	      }

	      if(selectDifferentParentClusters) {
		TLatex *recoText2 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.53*(maximumHistogramValue1-minimumHistogramValue), "Different parent photons for #pi^{0} RECO");
		recoText2->SetTextColor(2);
		recoText2->SetTextSize(0.042);
		recoText2->Draw();
	      }

	      if(usePi0EfficiencyTable) {
		TLatex *recoText2 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.53*(maximumHistogramValue1-minimumHistogramValue), "Efficiency corrections for #pi^{0} RECO");
		recoText2->SetTextColor(2);
		recoText2->SetTextSize(0.042);
		recoText2->Draw();
	      }

	      if(!testConversion && !usePi0EfficiencyTable) {
		TLatex *recoText2 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.53*(maximumHistogramValue1-minimumHistogramValue), "No acceptance modifications for #pi^{0} RECO");
		recoText2->SetTextColor(2);
		recoText2->SetTextSize(0.042);
		recoText2->Draw();
	      }

	      if(useTrackEfficiencyTable) {
		TLatex *recoText3 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.43*(maximumHistogramValue1-minimumHistogramValue), "Efficiency corrections for track RECO");
		recoText3->SetTextColor(2);
		recoText3->SetTextSize(0.042);
		recoText3->Draw();
	      }
	      else {
		TLatex *recoText3 = new TLatex(0.62+xPositionAdd, minimumHistogramValue + 0.43*(maximumHistogramValue1-minimumHistogramValue), "No efficiency corrections for track RECO");
		recoText3->SetTextColor(2);
		recoText3->SetTextSize(0.042);
		recoText3->Draw();
	      }

	      char *recoLabel4 = new char[100];
	      sprintf(recoLabel4, "%4.3f<m_{#gamma#gamma}<%4.3f GeV/c^{2}", lowLimitPi0Mass, highLimitPi0Mass);
	      TLatex *recoText4 = new TLatex(0.85+xPositionAdd, minimumHistogramValue + 0.33*(maximumHistogramValue1-minimumHistogramValue), recoLabel4);
	      recoText4->SetTextColor(2);
	      recoText4->SetTextSize(0.042);
	      recoText4->Draw();

	      if(useTwoSideBands) {
		char *recoLabel5 = new char[100];
		sprintf(recoLabel5, "%4.3f<m_{#gamma#gamma}<%4.3f GeV/c^{2}", lowLimitSideBandMass, highLimitSideBandMass);
		TLatex *recoText5 = new TLatex(0.85+xPositionAdd, minimumHistogramValue + 0.23*(maximumHistogramValue1-minimumHistogramValue), recoLabel5);
		recoText5->SetTextColor(2);
		recoText5->SetTextSize(0.042);
		recoText5->Draw();
	      }

	    } // extra labeling for top left plot

	  } // check for iOption = 337

	} // loop over kPt bins

	if(iOption == 337) {
	  for(int kPt=0; kPt<kPtLimit; kPt++) {
	    cout << "\n " << kPt << ") v2Fit = " << v2FitValue[kPt] << " +/- " << v2FitError[kPt];
	  }
	  cout << endl << endl;
	}

	return;

      } // check on iOption = 336 or iOption = 337

      if(plotKaonResiduals) {
	c1->Divide(2,3);

	c1->cd(1);
	// hBestAngleMatchKaon->SetStats(0);
	hBestAngleMatchKaon->Draw();
	(c1->cd(1))->SetGrid();

	c1->cd(2);
	dPhi_dEtaKaon->SetStats(0);
	dPhi_dEtaKaon->Draw("contz");
	(c1->cd(2))->SetLogz();
	(c1->cd(2))->SetGrid();

	c1->cd(3);
	//hBestPhiMatchKaon->SetStats(0);
	hBestPhiMatchKaon->Draw();
	(c1->cd(3))->SetGrid();
	
	c1->cd(4);
	//hBestEtaMatchKaon->SetStats(0);
	hBestEtaMatchKaon->Draw();
	(c1->cd(4))->SetGrid();

	/*
	c1->cd(5);
	dPhi_dZKaon->SetStats(0);
	dPhi_dZKaon->Draw("contz");
	(c1->cd(5))->SetLogz();
	(c1->cd(5))->SetGrid();

	c1->cd(6);
	dEta_dZKaon->SetStats(0);
	dEta_dZKaon->Draw("contz");
	(c1->cd(6))->SetLogz();
	(c1->cd(6))->SetGrid();

	c1->cd(7);
	dPhi_dRKaon->SetStats(0);
	dPhi_dRKaon->Draw("contz");
	(c1->cd(7))->SetLogz();
	(c1->cd(7))->SetGrid();

	c1->cd(8);
	dEta_dRKaon->SetStats(0);
	dEta_dRKaon->Draw("contz");
	(c1->cd(8))->SetLogz();
	(c1->cd(8))->SetGrid();

	c1->cd(5);
	dPhi_dEKaon->SetStats(0);
	dPhi_dEKaon->Draw("contz");
	(c1->cd(5))->SetLogz();
	(c1->cd(5))->SetGrid();

	c1->cd(6);
	dEta_dEKaon->SetStats(0);
	dEta_dEKaon->Draw("contz");
	(c1->cd(6))->SetLogz();
	(c1->cd(6))->SetGrid();
	*/

	c1->cd(5);
	dPhi_dSimEtaKaon->SetStats(0);
	dPhi_dSimEtaKaon->Draw("contz");
	(c1->cd(5))->SetLogz();
	(c1->cd(5))->SetGrid();

	c1->cd(6);
	dEta_dSimEtaKaon->SetStats(0);
	dEta_dSimEtaKaon->Draw("contz");
	(c1->cd(6))->SetLogz();
	(c1->cd(6))->SetGrid();

	return;

      } // kaon residuals


      if(iOption == -31) {
	WeightedTimingClusterEvsT->Draw("contz");
	c1->SetLogz();
	c1->SetGrid();

	char *runLabelText1 = new char[200];
	if(simRun) {
	  sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", sampledEvents);
	}
	if(simRunEPOS) {
	  sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", sampledEvents);
	}
	if(pPbRunNormal) {
	  sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", sampledEvents);
	}
	if(iOption >=0 || iOption <4) {
	  sprintf(runLabelText1, "2013 pPb runs, %d sampled HIHighPt events", sampledEvents);
	}
	if(ppRun) {
	  sprintf(runLabelText1, "2013 pp runs, %d sampled events", sampledEvents);
	}
          
	TLatex *runLabel1 = new TLatex(-50, 4.75, runLabelText1);
	runLabel1->SetTextColor(2);
	runLabel1->SetTextSize(0.040);
	runLabel1->Draw();
        
	char *runLabelText2 = new char[200];
	if(useHighPurityTracks) {
	  sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm (%d accepted events)", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit, acceptedEvents);
	}
	else {	  
	  sprintf(runLabelText2, "%d < NHITrack < %d and  %4.1f < Z < %3.1f cm (%d accepted events)", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit, acceptedEvents);
	}
	TLatex *runLabel2 = new TLatex(-50, 4.45, runLabelText2);
	runLabel2->SetTextColor(1);
	runLabel2->SetTextSize(0.045);
	runLabel2->Draw();

	char *runLabelText3 = new char[200];
	if(useTrackMatchSuppression) {
	  sprintf(runLabelText3, "Track-cluster match suppression is used");
	}
	else {
	  sprintf(runLabelText3, "NO track-cluster match suppression is used");
	}
	TLatex *runLabel3 = new TLatex(-50, 4.15, runLabelText3);
	runLabel3->SetTextColor(2);
	runLabel3->SetTextSize(0.035);
	runLabel3->Draw();
          
	char *runLabelText4 = new char[200];
	if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || lowPtBinLimit[0] < clusterCrystalLimitLowPtOnly)) {
	  if(useClusterCrystalLimitLowPtOnly) {
	    sprintf(runLabelText4, "Cluster crystal limits %d to %d used for cluster pairs with p_{T} < %3.1f GeV/c", lowCrystalLimit, highCrystalLimit, clusterCrystalLimitLowPtOnly);
	  }
	  else {
	    sprintf(runLabelText4, "Cluster crystal limits %d to %d used for all cluster pairs", lowCrystalLimit, highCrystalLimit);
	  }
	}
	else {
	  sprintf(runLabelText4, "NO cluster crystal sum limit is used");
	}
	TLatex *runLabel4 = new TLatex(-50, 3.85, runLabelText4);
	runLabel4->SetTextColor(2);
	runLabel4->SetTextSize(0.035);
	runLabel4->Draw();
          
	char *runLabelText4a = new char[200];
	if(useClusterPairCrystalSumLimit) {
	  sprintf(runLabelText4a, "Pair crystal sum limits %d to %d used", lowClusterPairCrystalSumLimit, highClusterPairCrystalSumLimit);
	}
	else {
	  sprintf(runLabelText4a, "NO pair crystal sum limit is used");
	}
	TLatex *runLabel4a = new TLatex(5, 3.85, runLabelText4a);
	runLabel4a->SetTextColor(2);
	runLabel4a->SetTextSize(0.035);
	runLabel4a->Draw();
        
	char *runLabelText5 = new char[200];
	if(useRotatedBackground) {
	  sprintf(runLabelText5, "Using rotated cluster background method");
	}
	else {
	  sprintf(runLabelText5, "Using mixed event background method");
	}
	TLatex *runLabel5 = new TLatex(-50, 3.55, runLabelText5);
	runLabel5->SetTextColor(kMagenta);
	runLabel5->SetTextSize(0.035);
	runLabel5->Draw();
				
	if(simRun && useConversionSuppression) {
	  TLatex *runLabel6 = new TLatex(-50, 3.25, "Using conversion suppression");
	  runLabel6->SetTextColor(kMagenta);
	  runLabel6->SetTextSize(0.035);
	  runLabel6->Draw();
	}

	char *runLabelText7 = new char[200];
	if(useSeedTimeCut) {
	  sprintf(runLabelText7, "Time cut %d ns", int(seedTimeCut));
	  
	  float yPos = 2.95;
	  if(!simRun)
	    yPos = 3.25;
	  
	  TLatex *runLabel7 = new TLatex(-50, yPos, runLabelText7);
	  runLabel7->SetTextColor(kBlue);
	  runLabel7->SetTextSize(0.035);
	  runLabel7->Draw();
	}

	// TimingClusterEvsTCut->Draw("same");

	return;
      } // iOption = -31

      if(iOption == -32) {
	TimingClusterEvsTBgrnd->Draw("contz");
	c1->SetLogz();
	c1->SetGrid();

	char *runLabelText1 = new char[200];
	if(simRun) {
	  sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", sampledEvents);
	}
	if(simRunEPOS) {
	  sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", sampledEvents);
	}
	if(pPbRunNormal) {
	  sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", sampledEvents);
	}
	if(ppRun) {
	  sprintf(runLabelText1, "2013 pp runs, %d sampled events", sampledEvents);
	}
          
	TLatex *runLabel1 = new TLatex(-50, 4.75, runLabelText1);
	runLabel1->SetTextColor(2);
	runLabel1->SetTextSize(0.040);
	runLabel1->Draw();
        
	char *runLabelText2 = new char[200];
	if(useHighPurityTracks) {
	  sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm (%d accepted events)", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit, acceptedEvents);
	}
	else {	  
	  sprintf(runLabelText2, "%d < NHITrack < %d and  %4.1f < Z < %3.1f cm (%d accepted events)", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit, acceptedEvents);
	}
	TLatex *runLabel2 = new TLatex(-50, 4.45, runLabelText2);
	runLabel2->SetTextColor(2);
	runLabel2->SetTextSize(0.035);
	runLabel2->Draw();

	char *runLabelText3 = new char[200];
	if(useTrackMatchSuppression) {
	  sprintf(runLabelText3, "Track-cluster match suppression is used");
	}
	else {
	  sprintf(runLabelText3, "NO track-cluster match suppression is used");
	}
	TLatex *runLabel3 = new TLatex(-50, 4.15, runLabelText3);
	runLabel3->SetTextColor(2);
	runLabel3->SetTextSize(0.035);
	runLabel3->Draw();

	char *runLabelText4 = new char[200]; 
	if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || lowPtBinLimit[0] < clusterCrystalLimitLowPtOnly)) {
	  if(useClusterCrystalLimitLowPtOnly) {
	    sprintf(runLabelText4, "Cluster crystal limits %d to %d used for cluster pairs with p_{T} < %3.1f GeV/c", lowCrystalLimit, highCrystalLimit, clusterCrystalLimitLowPtOnly);
	  }
	  else {
	    sprintf(runLabelText4, "Cluster crystal limits %d to %d used for all cluster pairs", lowCrystalLimit, highCrystalLimit);
	  }
	}
	else {
	  sprintf(runLabelText4, "NO cluster crystal sum limit is used");
	} 

	TLatex *runLabel4 = new TLatex(-50, 3.85, runLabelText4);
	runLabel4->SetTextColor(2);
	runLabel4->SetTextSize(0.035);
	runLabel4->Draw();

	char *runLabelText4a = new char[200];
	if(useClusterPairCrystalSumLimit) {
	  sprintf(runLabelText4a, "Pair crystal sum limits %d to %d used", lowClusterPairCrystalSumLimit, highClusterPairCrystalSumLimit);
	}
	else {
	  sprintf(runLabelText4a, "NO pair crystal sum limit is used");
	}
	TLatex *runLabel4a = new TLatex(5, 3.85, runLabelText4a);
	runLabel4a->SetTextColor(2);
	runLabel4a->SetTextSize(0.035);
	runLabel4a->Draw();
        
	char *runLabelText5 = new char[200];
	if(useRotatedBackground) {
	  sprintf(runLabelText5, "Using rotated cluster background method");
	}
	else {
	  sprintf(runLabelText5, "Using mixed event background method");
	}
	TLatex *runLabel5 = new TLatex(-50, 3.55, runLabelText5);
	runLabel5->SetTextColor(kMagenta);
	runLabel5->SetTextSize(0.035);
	runLabel5->Draw();
				
	if(simRun && useConversionSuppression) {
	  TLatex *runLabel6 = new TLatex(-50, 3.25, "Using conversion suppression");
	  runLabel6->SetTextColor(kMagenta);
	  runLabel6->SetTextSize(0.035);
	  runLabel6->Draw();
	}

	char *runLabelText7 = new char[200];
	if(useSeedTimeCut) {
	  sprintf(runLabelText7, "Time cut %d ns", int(seedTimeCut));
	  
	  float yPos = 2.95;
	  if(!simRun)
	    yPos = 3.25;
	  
	  TLatex *runLabel7 = new TLatex(-50, yPos, runLabelText7);
	  runLabel7->SetTextColor(kBlue);
	  runLabel7->SetTextSize(0.035);
	  runLabel7->Draw();
	}

	return;
      } // iOption = -32
      
      if(iOption == -33) {
	TimingClusterEvsT->Draw("contz");
	c1->SetLogz();
	c1->SetGrid();

	char *runLabelText1 = new char[200];
	if(simRun) {
	  sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", sampledEvents);
	}
	if(simRunEPOS) {
	  sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", sampledEvents);
	}
	if(pPbRunNormal) {
	  sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", sampledEvents);
	}
	if(ppRun) {
	  sprintf(runLabelText1, "2013 pp runs, %d sampled events", sampledEvents);
	}
          
	TLatex *runLabel1 = new TLatex(-50, 4.75, runLabelText1);
	runLabel1->SetTextColor(2);
	runLabel1->SetTextSize(0.040);
	runLabel1->Draw();
        
	char *runLabelText2 = new char[200];
	if(useHighPurityTracks) {
	  sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm (%d accepted events)", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit, acceptedEvents);
	}
	else {
	  sprintf(runLabelText2, "%d < NHITrack < %d and  %4.1f < Z < %3.1f cm (%d accepted events)", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit, acceptedEvents);
	}
	TLatex *runLabel2 = new TLatex(-50, 4.45, runLabelText2);
	runLabel2->SetTextColor(2);
	runLabel2->SetTextSize(0.035);
	runLabel2->Draw();

	char *runLabelText3 = new char[200];
	if(useTrackMatchSuppression) {
	  sprintf(runLabelText3, "Track-cluster match suppression is used");
	}
	else {
	  sprintf(runLabelText3, "NO track-cluster match suppression is used");
	}
	TLatex *runLabel3 = new TLatex(-50, 4.15, runLabelText3);
	runLabel3->SetTextColor(2);
	runLabel3->SetTextSize(0.035);
	runLabel3->Draw();
          
	char *runLabelText4 = new char[200];
	if(useClusterCrystalLimit) {
	  sprintf(runLabelText4, "Cluster crystal limits %d to %d used", lowCrystalLimit, highCrystalLimit);
	}
	else {
	  sprintf(runLabelText4, "NO cluster crystal sum limit is used");
	}
	TLatex *runLabel4 = new TLatex(-50, 3.85, runLabelText4);
	runLabel4->SetTextColor(2);
	runLabel4->SetTextSize(0.035);
	runLabel4->Draw();
          
	char *runLabelText4a = new char[200];
	if(useClusterPairCrystalSumLimit) {
	  sprintf(runLabelText4a, "Pair crystal sum limits %d to %d used", lowClusterPairCrystalSumLimit, highClusterPairCrystalSumLimit);
	}
	else {
	  sprintf(runLabelText4a, "NO pair crystal sum limit is used");
	}
	TLatex *runLabel4a = new TLatex(5, 3.85, runLabelText4a);
	runLabel4a->SetTextColor(2);
	runLabel4a->SetTextSize(0.035);
	runLabel4a->Draw();
        
	char *runLabelText5 = new char[200];
	if(useRotatedBackground) {
	  sprintf(runLabelText5, "Using rotated cluster background method");
	}
	else {
	  sprintf(runLabelText5, "Using mixed event background method");
	}
	TLatex *runLabel5 = new TLatex(-50, 3.55, runLabelText5);
	runLabel5->SetTextColor(kMagenta);
	runLabel5->SetTextSize(0.035);
	runLabel5->Draw();
				
	if(simRun && useConversionSuppression) {
	  TLatex *runLabel6 = new TLatex(-50, 3.25, "Using conversion suppression");
	  runLabel6->SetTextColor(kMagenta);
	  runLabel6->SetTextSize(0.035);
	  runLabel6->Draw();
	}

	char *runLabelText7 = new char[200];
	if(useSeedTimeCut) {
	  sprintf(runLabelText7, "Time cut %d ns", int(seedTimeCut));
	  
	  float yPos = 2.95;
	  if(!simRun)
	    yPos = 3.25;
	  
	  TLatex *runLabel7 = new TLatex(-50, yPos, runLabelText7);
	  runLabel7->SetTextColor(kBlue);
	  runLabel7->SetTextSize(0.035);
	  runLabel7->Draw();
	}

	TimingClusterEvsTCut->Draw("same");
	return;
      }
      
      if(iOption == 331) { // dynamic efficiency root file creation

	efficiencyPi0Yields->SetStats(0);
	efficiencyPi0Yields->SetMaximum(0.6);
	for(int xBin=0; xBin<25; xBin++) {
	  for(int yBin=0; yBin<25; yBin++) {
	    float numerator = reconstructedPi0Yields->GetBinContent(xBin, yBin);
	    float denominator = generatorPi0Yields->GetBinContent(xBin, yBin);
	    
	    if(denominator > 0.0)
	      efficiencyPi0Yields->SetBinContent(xBin, yBin, numerator/denominator);
	  } // loop over x bins
	} // loop over y bins
	efficiencyPi0Yields->Draw("surf3");

	char *efficiencyTitle = new char[200];
	char *efficiencyFileName = new char[200];
	if(useHighPurityTracks) {
	  sprintf(efficiencyTitle, "Efficiency (pt,eta) for pi0 +/- %4.3f GeV/c^{2} in events with HighPurity Tracks = %d - %d, use S4/S9 = %4.2f and |1-S25|/S9 cut = %4.2f, created on %s",
		  widthForEfficiency, lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, asciiDate); 
	  sprintf(efficiencyFileName, "pi0EfficiencyWidth%4.3f_HiPurity%d-%d_S4To9_%3.2f_S25To9_%2.1f_Date%d.root", widthForEfficiency, lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, date); 
	}
	else {
	  sprintf(efficiencyTitle, "Efficiency (pt,eta) for pi0 +/- %4.3f GeV/c^{2} in events with NHITracks = %d - %d, use S4/S9 = %4.2f and |1-S25|/S9 cut = %4.2f, created on %s",
		  widthForEfficiency, lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, asciiDate);
	  sprintf(efficiencyFileName, "pi0EfficiencyWidth%4.3f_NHITrack%d-%d_S4To9_%3.2f_S25To9_%2.1f_Date%d.root", widthForEfficiency, lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, date); 
	}

	TFile *pi0EfficiencyFile = new TFile(efficiencyFileName, "recreate", efficiencyTitle);
        generatorPi0YieldsEta->Write();
        generatorPi0YieldsPt->Write();
        reconstructedPi0YieldsEta->Write();
        reconstructedPi0YieldsPt->Write();
	generatorPi0Yields->Write();
	reconstructedPi0Yields->Write();
	efficiencyPi0Yields->Write();
	pi0EfficiencyFile->Close();

	cout << "\n\n Produced pi0 efficiency file with name " << efficiencyFileName << endl << endl;

	return;
      } // ioption = 331

      c1->Divide(2,2);  

      if((selectSameParentClusters || selectDifferentParentClusters) && iOption == 33) {

	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);
	  double maxHistogramValue1 = 2.0*sameEventMassHistogramsPtBin[kPt]->GetMaximum();
	  if(kPt != 0)
	    maxHistogramValue1 *= 0.6;

	  sameEventMassHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue1);
	  if(selectDifferentParentClusters) {
	    sameEventMassHistogramsPtBin[kPt]->SetFillColor(kYellow);
	    sameEventMassHistogramsPtBin[kPt]->SetLineColor(kMagenta);
	    sameEventMassHistogramsPtBin[kPt]->SetLineWidth(2);
	    sameEventMassHistogramsPtBin[kPt]->Draw();
	  }
	  if(selectSameParentClusters) {
	    if(sameEventMassHistogramsPtBin[kPt]->GetEntries() < 1.0) {
	      cerr << "\n Trying to fit an empty sameEventMassHistogramsPtBin, kPt = " << kPt << endl;
	      return;
	    }
	    sameEventMassHistogramsPtBin[kPt]->SetFillColor(kGreen);
	    sameEventMassHistogramsPtBin[kPt]->Fit("gaus", "", "", fitStart, fitEnd);

	    TF1 *fit =  sameEventMassHistogramsPtBin[kPt]->GetFunction("gaus");
	    float centroid = fit->GetParameter(1);
	    float width = fabs(fit->GetParameter(2));
	    cout << "\n  Centroid = " << centroid;
	    cout << ",  Width = " << width;
	    double signalSum = 0.0;
	    double centroidMinusTwoSigma = centroid - 2.0*width;
	    double centroidPlusTwoSigma = centroid + 2.0*width;
	    for(unsigned int kBin=0; kBin<=75; kBin++) {
	      double massValue =sameEventMassHistogramsPtBin[kPt]->GetBinCenter(kBin);
	      if(massValue >= centroidMinusTwoSigma && massValue <= centroidPlusTwoSigma) {
		signalSum += sameEventMassHistogramsPtBin[kPt]->GetBinContent(kBin);
	      } // check if mass value within +/- 2 sigma of centroid
	    } // loop over mass bins

	    cout << "\n Signal yield = " << int(signalSum) << " +/- " << int(sqrt(signalSum)+1);
	    cout << endl;

	    double maxHistogramValue2 = maxHistogramValue1;
	    if(kPt == 0)
	      maxHistogramValue2 = maxHistogramValue1/2.0;

	    char *peakLabel1 = new char[200];
	    sprintf(peakLabel1, "Fit: centroid = %5.3f GeV/c^{2}", centroid);
	    TLatex *peakText1 = new TLatex(0.155, 0.8*maxHistogramValue2, peakLabel1);
	    peakText1->SetTextColor(kBlue);
	    peakText1->SetTextSize(0.05);
	    peakText1->Draw();

	    float deltaY = 0.1;
	    if(kPt == 0)
	      deltaY = 0.15;

	    char *peakLabel2 = new char[200];
	    sprintf(peakLabel2, "Fit: #sigma = %5.3f GeV/c^{2}", width);
	    TLatex *peakText2 = new TLatex(0.155, (0.8 - deltaY)*maxHistogramValue2, peakLabel2);
	    peakText2->SetTextColor(kBlue);
	    peakText2->SetTextSize(0.05);
	    peakText2->Draw();

	    char *yieldLabel = new char[200];
	    sprintf(yieldLabel, "Signal = %d #pm %d", int(signalSum), int(sqrt(signalSum))+1);
	    TLatex *yieldText = new TLatex(0.155, (0.8 - 2.0*deltaY)*maxHistogramValue2, yieldLabel);
	    yieldText->SetTextColor(kBlue);
	    yieldText->SetTextSize(0.05);
	    yieldText->Draw();

	  } // select same parent clusters

	  (c1->cd(kPt+1))->SetGrid();

	  if(kPt == 0) {
	    char *runLabelText1 = new char[200];
	    if(simRun) {
	      sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", sampledEvents);
	    }
	    if(simRunEPOS) {
	      sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", sampledEvents);
	    }
	    if(pPbRunNormal) {
	      sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", sampledEvents);
	    }
	    if(iMultOption >=0 && iMultOption < 4) {
	      sprintf(runLabelText1, "2013 pPb runs, %d sampled HIHighPt events", sampledEvents);
	    }
	    if(ppRun) {
	      sprintf(runLabelText1, "2013 pp runs, %d sampled events", sampledEvents);
	    }

	    TLatex *runLabel1 = new TLatex(0.02, 0.93*maxHistogramValue1, runLabelText1);
	    runLabel1->SetTextColor(1);
	    runLabel1->SetTextSize(0.05);
	    runLabel1->Draw();
          
	    char *runLabelText2 = new char[200];
	    if(useHighPurityTracks) {
	      sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	    }
	    else {	  
	      sprintf(runLabelText2, "%d < NHITrack < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	    }
	    TLatex *runLabel2 = new TLatex(0.02, 0.86*maxHistogramValue1, runLabelText2);
	    runLabel2->SetTextColor(1);
	    runLabel2->SetTextSize(0.045);
	    runLabel2->Draw();

	    char *runLabelText3 = new char[200];
	    sprintf(runLabelText3, "Number of accepted events %d, use S4/S9 = %4.2f and |1-S25|/S9 cut = %4.2f", acceptedEvents, clustS49Cut, clustS25Cut);
	    TLatex *runLabel3 = new TLatex(0.02, 0.79*maxHistogramValue1, runLabelText3);
	    runLabel3->SetTextColor(1);
	    runLabel3->SetTextSize(0.045);
	    runLabel3->Draw();
     
	    char *runLabelText4 = new char[200];
	    if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || lowPtBinLimit[0] < clusterCrystalLimitLowPtOnly)) {
	      if(useClusterCrystalLimitLowPtOnly) {
		sprintf(runLabelText4, "Cluster crystal limits %d to %d used for cluster pairs with p_{T} < %3.1f GeV/c", lowCrystalLimit, highCrystalLimit, clusterCrystalLimitLowPtOnly);
	      }
	      else {
		sprintf(runLabelText4, "Cluster crystal limits %d to %d used for all cluster pairs", lowCrystalLimit, highCrystalLimit);
	      }
	    }
	    else {
	      sprintf(runLabelText4, "NO cluster crystal pair sum limit is used");
	    }
	    TLatex *runLabel4 = new TLatex(0.02, 0.72*maxHistogramValue1, runLabelText4);
	    runLabel4->SetTextColor(1);
	    runLabel4->SetTextSize(0.045);
	    runLabel4->Draw();
          					
	    if(selectSameParentClusters) {
	      TLatex *runLabel6 = 0;
	      if(useOnlyNoMother) {
		runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Only same parent photon pairs are used, require primary photons");
	      }
	      if(excludeNoMother) {
		runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Only same parent photon pairs are used, exclude primary photons");
	      }
	      if(useOnlyPdg111) {
		runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Only same parent photon pairs are used, require #pi^{0} parent");
	      }
	      if(excludePdg111) {
		runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Only same parent photon pairs are used, exclude #pi^{0} parent");
	      }
	      if(!excludePdg111 && !useOnlyPdg111) {
		runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Only same parent photon pairs are used, no check for #pi^{0} parent");
	      }
	      runLabel6->SetTextColor(kMagenta);
	      runLabel6->SetTextSize(0.045);
	      runLabel6->Draw();

	      //
	      // Grandmother particle
	      //
	      TLatex *runLabel7 = 0;
	      if(useOnlyPdg221GParent) {
		runLabel7 = new TLatex(0.02, 0.51*maxHistogramValue1, "Require #eta(547) grandparent");
	      }
	      if(excludePdg221GParent) {
		runLabel7 = new TLatex(0.02, 0.51*maxHistogramValue1, "Exclude #eta(547) grandparent");
	      }
	      if(useOnlyKaonGParent) {
		runLabel7 = new TLatex(0.02, 0.51*maxHistogramValue1, "Require a kaon grandparent");
	      }
	      if(useOnlyValidGParent) {
		runLabel7 = new TLatex(0.02, 0.51*maxHistogramValue1, "Require grandparent to be #eta or #eta^{#prime} or #rho or #omega or #Kaon");
	      }
	      if(excludeValidGParent) {
		runLabel7 = new TLatex(0.02, 0.51*maxHistogramValue1, "Exclude grandparent which are #eta or #eta^{#prime} or #rho or #omega or K");
	      }
	      if(runLabel7) {
		runLabel7->SetTextColor(kMagenta);
		runLabel7->SetTextSize(0.045);
		runLabel7->Draw();
	      }
	    }
	    else {
	      TLatex *runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Only different parent photon pairs are used");
	      runLabel6->SetTextColor(kMagenta);
	      runLabel6->SetTextSize(0.045);
	      runLabel6->Draw();
	    }

	  } // check if kPt = 0

	} // loop over kPt

	char *graphOutputFileName = new char[200];
	sprintf(graphOutputFileName, "pi0MassSameParentPt_Q%d_489Files_Multiplicity%d-%d_S4To9_%3.2f_S25To9-%3.1f_Date%d.pdf", pTQuartile, lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, date);
	c1->Print(graphOutputFileName);  // PDF file
	sprintf(graphOutputFileName, "pi0MassSameParentPt_Q%d_489Files_Multiplicity%d-%d_S4To9_%3.2f_S25To9-%3.1f_Date%d.root", pTQuartile, lowMultiplicity, highMultiplicity, clustS49Cut, clustS25Cut, date);
	c1->Print(graphOutputFileName);  // ROOT file
      
	return;
      }  // iOption == 33 and selects same parent cluster or select different parent cluster

      if(iOption == 70 || iOption == 72) {
	TF1 *parameterizedBackgroundFit[4];
	TF1 *parameterizedBackground[4];
	char *fitName = new char[200];
	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);

	  sprintf(fitName, "parametrizedFit%d", kPt);
	  int kFirstGaussParameter = 3;
	  if(iOption == 70) {
	    fitStart = 0.070;
	    fitEnd = 0.220;
	    if(usePtDependentSeparation) {
	      fitStart = 0.085;
	      fitEnd = 0.185;
	    }
	    parameterizedBackgroundFit[kPt] = new TF1(fitName, fitFunctionQuadratic, fitStart, fitEnd, 6);
	  }
	  if(iOption == 72) {
	    fitStart = 0.09;
	    fitEnd = 0.18;
	    kFirstGaussParameter = 2;
	    parameterizedBackgroundFit[kPt] = new TF1(fitName, fitFunctionLinear, fitStart, fitEnd, 5);
	  }
	  parameterizedBackgroundFit[kPt]->SetParName(0, "bkgConst");
	  parameterizedBackgroundFit[kPt]->SetParName(1, "bkgLin");
	  if(iOption == 70) {
	    parameterizedBackgroundFit[kPt]->SetParName(2, "bkgQuad");
	  }
	  parameterizedBackgroundFit[kPt]->SetParName(kFirstGaussParameter, "peakAmpl");
	  parameterizedBackgroundFit[kPt]->SetParName(kFirstGaussParameter+1, "peakCent");
	  parameterizedBackgroundFit[kPt]->SetParName(kFirstGaussParameter+2, "peakSigma");
	  if(iOption == 70) {
	    parameterizedBackgroundFit[kPt]->SetParameters(-400., 8000., -13500., 500., 0.134, 0.012);
	  }
	  if(iOption == 72) {
	    parameterizedBackgroundFit[kPt]->SetParameters(-30., 2000., 1800., 0.134, 0.012);
	  }
	  parameterizedBackgroundFit[kPt]->SetLineColor(kBlue);

	  float maxHistogramValue = 1.55*sameEventMassHistogramsPtBin[kPt]->GetMaximum();
	  sameEventMassHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue);
	  sameEventMassHistogramsPtBin[kPt]->Fit(fitName, "", "", fitStart, fitEnd);

	  sprintf(fitName, "parametrizedBackground%d", kPt); 
	  parameterizedBackground[kPt] = new TF1(fitName, fitFunctionQuadratic, fitStart, fitEnd, 3);
	  float bkgConst = parameterizedBackgroundFit[kPt]->GetParameter(0);
	  float bkgLin = parameterizedBackgroundFit[kPt]->GetParameter(1);
	  if(iOption == 70) {
	    float bkgQuad = parameterizedBackgroundFit[kPt]->GetParameter(2);
	    parameterizedBackground[kPt]->SetParameters(bkgConst, bkgLin, bkgQuad);
	  }
	  if(iOption == 72) {
	    parameterizedBackground[kPt]->SetParameters(bkgConst, bkgLin);
	  }
	  parameterizedBackground[kPt]->SetLineColor(2);
	  parameterizedBackground[kPt]->Draw("same");

	  float xTextPosition = 0.015;
	  char *centroidText = new char[200];
	  float centroidFit =  parameterizedBackgroundFit[kPt]->GetParameter(kFirstGaussParameter+1);
	  float centroidError = parameterizedBackgroundFit[kPt]->GetParError(kFirstGaussParameter+1);
	  float sigmaFit = fabs(parameterizedBackgroundFit[kPt]->GetParameter(kFirstGaussParameter+2));
	  float sigmaError = parameterizedBackgroundFit[kPt]->GetParError(kFirstGaussParameter+2);

	  sprintf(centroidText, "Fit centroid = %4.1f MeV (#pm %2.1f), #sigma = %4.1f MeV (#pm %2.1f)", 1000.0*centroidFit, 1000.0*centroidError, 1000.0*sigmaFit, 1000.0*sigmaError);
	  TLatex *centroid = new TLatex(xTextPosition, 0.90*maxHistogramValue, centroidText);
	  centroid->SetTextColor(kBlue);
	  centroid->SetTextSize(0.055);
	  centroid->Draw();
            
	  double lowCountLimit = centroidFit - sigFactor*sigmaFit;
	  double highCountLimit = centroidFit + sigFactor*sigmaFit;
	  double summedYield = 0;
	  double summedYieldError = 0;
	  double summedBackground = 0;
	  double summedBackgroundError = 0;
	  for(int massBin=1; massBin<200; massBin++) {
	    double massValue = sameEventMassHistogramsPtBin[kPt]->GetBinCenter(massBin);
	    if(massValue >= lowCountLimit && massValue <= highCountLimit) {
	      double foreGround = sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      double foreGroundErrorSquared = foreGround;
	      double background = parameterizedBackground[kPt]->Eval(massValue);
	      summedYield += foreGround - background;
	      summedBackground += background;
	      double backgroundErrorSquared = background;
	      summedYieldError += foreGroundErrorSquared + backgroundErrorSquared;
	      summedBackgroundError += backgroundErrorSquared;
	    }
	  } // loop over mass bins
	  summedYieldError = sqrt(summedYieldError);
	  summedBackgroundError = sqrt(summedBackgroundError);

	  cout << "\n\n  Summed signal yield = " << summedYield << " +/- " << summedYieldError;
	  cout << "\n  Summed background = " << summedBackground << " +/- " << summedBackgroundError;
	  cout << endl << endl;

	  char *yieldText = new char[200];
	  sprintf(yieldText, "Signal yield in %d#sigma interval = %d #pm %d", int(sigFactor), int(summedYield), int(summedYieldError));
	  TLatex *yieldLabel = new TLatex(xTextPosition, 0.80*maxHistogramValue, yieldText);
	  yieldLabel->SetTextColor(kBlue);
	  yieldLabel->SetTextSize(0.055);
	  yieldLabel->Draw();

	  char *backgroundText = new char[200];
	  sprintf(backgroundText, "Background in %d#sigma interval = %d #pm %d", int(sigFactor), int(summedBackground), int(summedBackgroundError));
	  TLatex *backgroundLabel = new TLatex(xTextPosition, 0.70*maxHistogramValue, backgroundText);
	  backgroundLabel->SetTextColor(kBlue);
	  backgroundLabel->SetTextSize(0.055);
	  backgroundLabel->Draw();
              
	  if(summedBackground > 0 && summedYield >0) {
	    char *sbRatioText = new char[200];
	    float sbRatio = summedYield/(summedBackground + summedYield);
	    float sbRatioError = sbRatio*(sqrt(pow(summedYieldError/summedYield,2) + pow(summedBackgroundError/summedBackground,2)));
	    sprintf(sbRatioText, "S/(S+B) = %4.3f #pm %4.3f", sbRatio, sbRatioError);
	    TLatex *sbRatioLabel = new TLatex(xTextPosition, 0.60*maxHistogramValue, sbRatioText);
	    sbRatioLabel->SetTextColor(kBlue);
	    sbRatioLabel->SetTextSize(0.055);
	    sbRatioLabel->Draw();
	  }

	  if(kPt == 0) {
	    char *runLabelText1 = new char[200];
	    if(simRun) {
	      sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", sampledEvents);
	    }
	    if(simRunEPOS) {
	      sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", sampledEvents);
	    }
	    if(pPbRunNormal) {
	      sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", sampledEvents);
	    }
	    if(ppRun) {
	      sprintf(runLabelText1, "2013 pp runs, %d sampled events", sampledEvents);
	    }
          
	    float xPositionText0 = 0.110;
	    TLatex *runLabel1 = new TLatex(xPositionText0+0.01, 0.30*maxHistogramValue, runLabelText1);
	    runLabel1->SetTextColor(1);
	    runLabel1->SetTextSize(0.05);
	    runLabel1->Draw();
          
	    char *runLabelText2 = new char[200];
	    if(useHighPurityTracks) {
	      sprintf(runLabelText2, "%d < HighPurity < %d and %d accepted events", lowMultiplicity, highMultiplicity, acceptedEvents);
	    }
	    else {
	      sprintf(runLabelText2, "%d < NHITrack < %d and %d accepted events", lowMultiplicity, highMultiplicity, acceptedEvents);
	    }

	    TLatex *runLabel2 = new TLatex(xPositionText0, 0.22*maxHistogramValue, runLabelText2);
	    runLabel2->SetTextColor(1);
	    runLabel2->SetTextSize(0.045);
	    runLabel2->Draw();
                    
	    char *runLabelText4 = new char[200];
	    if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || lowPtBinLimit[0] < clusterCrystalLimitLowPtOnly)) {
	      if(useClusterCrystalLimitLowPtOnly) {
		sprintf(runLabelText4, "Cluster crystal limits %d to %d used for cluster pairs with p_{T} < %3.1f GeV/c", lowCrystalLimit, highCrystalLimit, clusterCrystalLimitLowPtOnly);
	      }
	      else {
		sprintf(runLabelText4, "Cluster crystal limits %d to %d used for all cluster pairs", lowCrystalLimit, highCrystalLimit);
	      }
	    }
	    else {
	      sprintf(runLabelText4, "NO cluster crystal sum limit is used");
	    }
	    TLatex *runLabel4 = new TLatex(xPositionText0, 0.14*maxHistogramValue, runLabelText4);
	    runLabel4->SetTextColor(1);
	    runLabel4->SetTextSize(0.045);
	    runLabel4->Draw();
          					
	    if(simRun && useConversionSuppression) {
	      TLatex *runLabel6 = new TLatex(xPositionText0, 0.06*maxHistogramValue, "Using conversion suppression");
	      runLabel6->SetTextColor(1);
	      runLabel6->SetTextSize(0.05);
	      runLabel6->Draw();
	    }

	    char *fitLabel = new char[200];
	    if(iOption == 70) {
	      sprintf(fitLabel, "Quadratic background function");
	    }
	    if(iOption == 72) {
	      sprintf(fitLabel, "Linear background function");
	    }
	    TLatex *fitText = new TLatex(xTextPosition, 0.50*maxHistogramValue, fitLabel);
	    fitText->SetTextColor(kBlue);
	    fitText->SetTextSize(0.045);
	    fitText->Draw();

	  } // labels for the upper left quadrant only

	  (c1->cd(kPt+1))->SetGrid();
	}
	return;
      } // iOption = 70, 72 for parametrized fitting

      if(iOption == 71) {
	TF1 *mixedEventBackgroundFit[4];
	char *fitName = new char[200];
	TH1D *subtractedMassHistogramsPtBin[4];
	for(int kPt=0; kPt<4; kPt++) {

	  sprintf(fitName, "mixedEventFit%d", kPt); 
	  mixedEventBackgroundFit[kPt] = new TF1(fitName, gaussPeak, fitStart, fitEnd, 3);
	  mixedEventBackgroundFit[kPt]->SetParName(0, "peakAmpl");
	  mixedEventBackgroundFit[kPt]->SetParName(1, "peakCent");
	  mixedEventBackgroundFit[kPt]->SetParName(2, "peakSigma");
	  mixedEventBackgroundFit[kPt]->SetParameters(1800., 0.134, 0.012);
	  mixedEventBackgroundFit[kPt]->SetLineColor(kBlue);

	  sprintf(histogramName, "subtracteMassHistogramPtBin%d", kPt);
	  sprintf(histogramTitle, "Subtracted m_{#gamma#gamma} for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	  subtractedMassHistogramsPtBin[kPt]  = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, highMass);
	  subtractedMassHistogramsPtBin[kPt]->SetStats(0);
	  subtractedMassHistogramsPtBin[kPt]->SetLineColor(1);
	  subtractedMassHistogramsPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	  subtractedMassHistogramsPtBin[kPt]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
	  (subtractedMassHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
	  (subtractedMassHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
	  
	  (subtractedMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
	  (subtractedMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
	  (subtractedMassHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
	  (subtractedMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
	  (subtractedMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
	  (subtractedMassHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();
	  c1->cd(kPt+1);

	  float maxHistogramValue = 1.55*sameEventMassHistogramsPtBin[kPt]->GetMaximum();
	  if(kPt == 0)
	    maxHistogramValue = 2.0*sameEventMassHistogramsPtBin[kPt]->GetMaximum();

	  sameEventMassHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue);

	  double countSameEventBackground = 0.0;
	  double countMixedEventBackground = 0.0;
	  for(int massBin=1; massBin<200; massBin++) {
	    double massValue = sameEventMassHistogramsPtBin[kPt]->GetBinCenter(massBin);
	    if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	      countSameEventBackground += sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      countMixedEventBackground += mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	    }
	  } // loop over mass values;
	  if(countSameEventBackground > 0.0 && countMixedEventBackground > 0.0) {
	    double normalizationFactor = countSameEventBackground/countMixedEventBackground;
	    for(int massBin=1; massBin<200; massBin++) {
	      double countsBackground = mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      mixedEventMassHistogramsPtBin[kPt]->SetBinContent(massBin, countsBackground*normalizationFactor);
	      double countsForeground = sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      double countsSubtracted = countsForeground - normalizationFactor*countsBackground;
	      double errorSubtracted = sqrt(countsForeground + normalizationFactor*normalizationFactor*countsBackground);
	      subtractedMassHistogramsPtBin[kPt]->SetBinContent(massBin, countsSubtracted);
	      subtractedMassHistogramsPtBin[kPt]->SetBinError(massBin, errorSubtracted);

	    } // loop over mass bins

	    cout << "\n For pT bin " << kPt << " counts in same event normalization region = " << countSameEventBackground;
	    cout << ",  counts in mixed event normalization region = " << countMixedEventBackground;
	    cout << ",  with normalization factor = " << normalizationFactor;
	    // cout << ",  histogram rescale factor = " << rescaleFactor;
	    cout << endl;

	    sameEventMassHistogramsPtBin[kPt]->Draw();
	    mixedEventMassHistogramsPtBin[kPt]->SetFillColor(kYellow);
	    mixedEventMassHistogramsPtBin[kPt]->Draw("same");
	    sameEventMassHistogramsPtBin[kPt]->SetLineWidth(2);
	    sameEventMassHistogramsPtBin[kPt]->Draw("same");

	    subtractedMassHistogramsPtBin[kPt]->SetMarkerColor(2);
	    subtractedMassHistogramsPtBin[kPt]->SetMarkerSize(0.65);
	    subtractedMassHistogramsPtBin[kPt]->SetMarkerStyle(20);
	    subtractedMassHistogramsPtBin[kPt]->Draw("same");

	    subtractedMassHistogramsPtBin[kPt]->Fit(fitName, "N", "", fitStart, fitEnd);
	    mixedEventBackgroundFit[kPt]->Draw("same");

	    float xTextPosition = 0.015;
	    char *centroidText = new char[200];
	    float centroidFit =  mixedEventBackgroundFit[kPt]->GetParameter(1);
	    float centroidError = mixedEventBackgroundFit[kPt]->GetParError(1);
	    float sigmaFit =  fabs(mixedEventBackgroundFit[kPt]->GetParameter(2));
	    float sigmaError = mixedEventBackgroundFit[kPt]->GetParError(2);

	    sprintf(centroidText, "Fit centroid = %4.1f MeV (#pm %2.1f), #sigma = %4.1f MeV (#pm %2.1f)", 1000.0*centroidFit, 1000.0*centroidError, 1000.0*sigmaFit, 1000.0*sigmaError);
	    TLatex *centroid = new TLatex(xTextPosition, 0.90*maxHistogramValue, centroidText);
	    centroid->SetTextColor(kBlue);
	    centroid->SetTextSize(0.055);
	    centroid->Draw();

	    double lowCountLimit = centroidFit - sigFactor*sigmaFit;
	    double highCountLimit = centroidFit + sigFactor*sigmaFit;
	    double summedYield = 0;
	    double summedYieldError = 0;
	    double summedBackground = 0;
	    double summedBackgroundError = 0;
	    for(int massBin=1; massBin<200; massBin++) {
	      double massValue = subtractedMassHistogramsPtBin[kPt]->GetBinCenter(massBin);
	      if(massValue >= lowCountLimit && massValue <= highCountLimit) {
		double foreGround = subtractedMassHistogramsPtBin[kPt]->GetBinContent(massBin);
		double foreGroundError= subtractedMassHistogramsPtBin[kPt]->GetBinError(massBin);
		summedYieldError += foreGroundError*foreGroundError;
		double background =  normalizationFactor*mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
		summedYield += foreGround;
		summedBackground += background;
		summedBackgroundError += normalizationFactor*background;
	      }
	    } // loop over mass bins
	    summedYieldError = sqrt(summedYieldError);
	    summedBackgroundError = sqrt(summedBackgroundError);

	    cout << "\n\n  Summed signal yield = " << summedYield << " +/- " << summedYieldError;
	    cout << "\n  Summed background = " << summedBackground << " +/- " << summedBackgroundError;
	    cout << endl << endl;

	    char *yieldText = new char[200];
	    sprintf(yieldText, "Signal yield in %d#sigma interval = %d #pm %d", int(sigFactor), int(summedYield), int(summedYieldError));
	    TLatex *yieldLabel = new TLatex(xTextPosition, 0.80*maxHistogramValue, yieldText);
	    yieldLabel->SetTextColor(kBlue);
	    yieldLabel->SetTextSize(0.055);
	    yieldLabel->Draw();

	    char *backgroundText = new char[200];
	    sprintf(backgroundText, "Background in %d#sigma interval = %d #pm %d", int(sigFactor), int(summedBackground), int(summedBackgroundError));
	    TLatex *backgroundLabel = new TLatex(xTextPosition, 0.70*maxHistogramValue, backgroundText);
	    backgroundLabel->SetTextColor(kBlue);
	    backgroundLabel->SetTextSize(0.055);
	    backgroundLabel->Draw();

	    if(summedBackground > 0 && summedYield >0) {
	      char *sbRatioText = new char[200];
	      float sbRatio = summedYield/(summedBackground + summedYield);
	      float sbRatioError = sbRatio*(sqrt(pow(summedYieldError/summedYield,2) + pow(summedBackgroundError/summedBackground,2)));
	      sprintf(sbRatioText, "S/(S+B) = %4.3f #pm %4.3f", sbRatio, sbRatioError);
	      TLatex *sbRatioLabel = new TLatex(xTextPosition, 0.60*maxHistogramValue, sbRatioText);
	      sbRatioLabel->SetTextColor(kBlue);
	      sbRatioLabel->SetTextSize(0.055);
	      sbRatioLabel->Draw();
	    }

	  } // check for non-zero counts

	  if(kPt == 0) {
	    char *runLabelText1 = new char[200];
	    if(simRun) {
	      sprintf(runLabelText1, "%d Sampled HIJING pPb MB Events", sampledEvents);
	    }
	    if(simRunEPOS) {
	      sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", sampledEvents);
	    }
	    if(simRunEPOS) {
	      sprintf(runLabelText1, "%d Sampled EPOS pPb MB Events", sampledEvents);
	    }
	    if(pPbRunNormal) {
	      sprintf(runLabelText1, "First MB 2013 pPb, %d sampled events", sampledEvents);
	    }
	    if(ppRun) {
	      sprintf(runLabelText1, "2013 pp, %d sampled events", sampledEvents);
	    }
          
	    float xPositionText0 = 0.155;
	    TLatex *runLabel1 = new TLatex(xPositionText0, 0.30*maxHistogramValue, runLabelText1);
	    runLabel1->SetTextColor(1);
	    runLabel1->SetTextSize(0.048);
	    runLabel1->Draw();
          
	    char *runLabelText2 = new char[200];
	    if(useHighPurityTracks) {
	      sprintf(runLabelText2, "%d <HighPurity <%d", lowMultiplicity, highMultiplicity);
	    }
	    else {
	      sprintf(runLabelText2, "%d <NHITracks <%d", lowMultiplicity, highMultiplicity);
	    }
	    TLatex *runLabel2 = new TLatex(xPositionText0, 0.25*maxHistogramValue, runLabelText2);
	    runLabel2->SetTextColor(1);
	    runLabel2->SetTextSize(0.045);
	    runLabel2->Draw();

	    char *runLabelText3 = new char[200];
	    sprintf(runLabelText3, "Number of accepted events %d, use S4/S9 = %4.2f and |1-S25|/S9 cut = %4.2f", acceptedEvents, clustS49Cut, clustS25Cut);
	    TLatex *runLabel3 = new TLatex(0.02, 0.20*maxHistogramValue, runLabelText3);
	    runLabel3->SetTextColor(1);
	    runLabel3->SetTextSize(0.045);
	    runLabel3->Draw();
                    
	    char *runLabelText4 = new char[200];
	    if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || lowPtBinLimit[0] < clusterCrystalLimitLowPtOnly)) {
	      if(useClusterCrystalLimitLowPtOnly) {
		sprintf(runLabelText4, "Cluster crystal limits %d to %d used for cluster pairs with p_{T} < %3.1f GeV/c", lowCrystalLimit, highCrystalLimit, clusterCrystalLimitLowPtOnly);
	      }
	      else {
		sprintf(runLabelText4, "Cluster crystal limits %d to %d used for all cluster pairs", lowCrystalLimit, highCrystalLimit);
	      }
	    }
	    else {
	      sprintf(runLabelText4, "NO cluster crystal sum limit is used");
	    }
	    TLatex *runLabel4 = new TLatex(xPositionText0, 0.14*maxHistogramValue, runLabelText4);
	    runLabel4->SetTextColor(1);
	    runLabel4->SetTextSize(0.045);
	    runLabel4->Draw();
          					

	    if(simRun && useConversionSuppression) {
	      TLatex *runLabel6 = new TLatex(xPositionText0+0.02, 0.07*maxHistogramValue, "Conversion suppression");
	      runLabel6->SetTextColor(1);
	      runLabel6->SetTextSize(0.035);
	      runLabel6->Draw();
	    }

	    TLatex *fitText = new TLatex(0.015, 0.50*maxHistogramValue, "Mixed-event background");
	    fitText->SetTextColor(kBlue);
	    fitText->SetTextSize(0.045);
	    fitText->Draw();

	  } // labels for the upper left quadrant only

	  (c1->cd(kPt+1))->SetGrid();

	} // loop over pT bins

	return;
      } // iOption = 71 for mixed-event background fitting

      if(iOption == 54) {
	for(int kEn=0; kEn<4; kEn++) {
	  c1->cd(kEn+1);
	  inclusiveClusters[kEn]->Draw();
	  char *inclusiveLabel = new char[200];
	  sprintf(inclusiveLabel, "Inclusive: Mean value %4.1f, RMS %4.1f", inclusiveClusters[kEn]->GetMean(), inclusiveClusters[kEn]->GetRMS());
	  float maxHistogramValue =  inclusiveClusters[kEn]->GetMaximum();
	  TLatex *inclusiveText = new TLatex(2.8, 0.9*maxHistogramValue, inclusiveLabel);
	  inclusiveText->SetTextColor(kBlue);
	  inclusiveText->SetTextSize(0.050);
	  inclusiveText->Draw();
        
	  if(useConversionSuppression) {
	    noConvClusters[kEn]->Draw("same");
	    char *noConvClusterLabel = new char[200];
	    sprintf(noConvClusterLabel, "No conversion: Mean value %4.1f, RMS %4.1f", noConvClusters[kEn]->GetMean(), noConvClusters[kEn]->GetRMS());
	    TLatex *noConvText = new TLatex(2.8, 0.75*maxHistogramValue, noConvClusterLabel);
	    noConvText->SetTextColor(kGreen);
	    noConvText->SetTextSize(0.050);
	    noConvText->Draw();

	    convClusters[kEn]->Draw("same");
	    char *convClusterLabel = new char[200];
	    sprintf(convClusterLabel, "Conversion: Mean value %4.1f, RMS %4.1f", convClusters[kEn]->GetMean(), convClusters[kEn]->GetRMS());
	    TLatex *convText = new TLatex(2.8, 0.60*maxHistogramValue, convClusterLabel);
	    convText->SetTextColor(kRed);
	    convText->SetTextSize(0.050);
	    convText->Draw();

	  } // check using conversion suppression

	} // loop over energy bins

	return;

      } // iOption 54

      if(iOption >= 55 && iOption <= 58) {

	for(int kEn=0; kEn<4; kEn++) {
	  c1->cd(kEn+1);
	  if(inclusiveWidth[kEn]->GetSum() <= 0.0)
	    continue;

	  inclusiveWidth[kEn]->Draw();
	  char *inclusiveLabel = new char[200];
	  sprintf(inclusiveLabel, "Inclusive: Mean value %5.3f, RMS %5.3f", inclusiveWidth[kEn]->GetMean(), inclusiveWidth[kEn]->GetRMS());
	  float maxHistogramValue =  1.5*inclusiveWidth[kEn]->GetMaximum();
	  inclusiveWidth[kEn]->SetMaximum(maxHistogramValue);
	  TLatex *inclusiveText = new TLatex(0.2, 0.9*maxHistogramValue, inclusiveLabel);
	  inclusiveText->SetTextColor(kBlue);
	  inclusiveText->SetTextSize(0.050);
	  inclusiveText->Draw();
        
	  if(useConversionSuppression) {
	    noConvWidth[kEn]->Draw("same");
	    char *noConvClusterLabel = new char[200];
	    sprintf(noConvClusterLabel, "No conversion: Mean value %5.3f, RMS %5.3f", noConvWidth[kEn]->GetMean(), noConvWidth[kEn]->GetRMS());
	    TLatex *noConvText = new TLatex(0.2, 0.80*maxHistogramValue, noConvClusterLabel);
	    noConvText->SetTextColor(kGreen);
	    noConvText->SetTextSize(0.050);
	    noConvText->Draw();

	    convWidth[kEn]->Draw("same");
	    char *convClusterLabel = new char[200];
	    sprintf(convClusterLabel, "Conversion: Mean value %5.3f, RMS %5.3f", convWidth[kEn]->GetMean(), convWidth[kEn]->GetRMS());
	    TLatex *convText = new TLatex(0.2, 0.70*maxHistogramValue, convClusterLabel);
	    convText->SetTextColor(kRed);
	    convText->SetTextSize(0.050);
	    convText->Draw();

	    char *clusterLimitLabel = new char[200];
	    sprintf(clusterLimitLabel,  "Cluster crystal limits %d to %d used", lowCrystalLimit, highCrystalLimit);  
	    TLatex *clusterLimitText = new TLatex(0.6, 0.60*maxHistogramValue, clusterLimitLabel);
	    clusterLimitText->SetTextColor(kBlack);
	    clusterLimitText->SetTextSize(0.05);
	    clusterLimitText->Draw();

	    char *trackLimitLabel = new char[200];
	    if(useHighPurityTracks) {
	      sprintf(trackLimitLabel,  "%d < HighPurity < %d", lowMultiplicity, highMultiplicity);  
	    }
	    else {
	      sprintf(trackLimitLabel,  "%d < NHITracks < %d", lowMultiplicity, highMultiplicity);  
	    }
	    TLatex *trackLimitText = new TLatex(0.6, 0.50*maxHistogramValue, trackLimitLabel);
	    trackLimitText->SetTextColor(kBlack);
	    trackLimitText->SetTextSize(0.05);
	    trackLimitText->Draw();

	  } // check using conversion suppression

	  (c1->cd(kEn+1))->SetGrid();

	} // loop over energy bins

	return;

      } // iOption 55 - 58

      if(iOption >= 59 && iOption <= 60) {

	for(int kEn=0; kEn<4; kEn++) {
	  c1->cd(kEn+1);
	  if(inclusiveSumWidth[kEn]->GetSum() <= 0.0)
	    continue;

	  inclusiveSumWidth[kEn]->Draw();
	  char *inclusiveLabel = new char[200];
	  sprintf(inclusiveLabel, "Inclusive: Mean value %5.3f, RMS %5.3f", inclusiveSumWidth[kEn]->GetMean(), inclusiveSumWidth[kEn]->GetRMS());
	  float maxHistogramValue =  1.5*inclusiveSumWidth[kEn]->GetMaximum();
	  inclusiveSumWidth[kEn]->SetMaximum(maxHistogramValue);
	  TLatex *inclusiveText = new TLatex(0.2, 0.9*maxHistogramValue, inclusiveLabel);
	  inclusiveText->SetTextColor(kBlue);
	  inclusiveText->SetTextSize(0.050);
	  inclusiveText->Draw();
        
	  if(useConversionSuppression) {
	    noConvSumWidth[kEn]->Draw("same");
	    char *noConvClusterLabel = new char[200];
	    sprintf(noConvClusterLabel, "No conversion: Mean value %5.3f, RMS %5.3f", noConvSumWidth[kEn]->GetMean(), noConvSumWidth[kEn]->GetRMS());
	    TLatex *noConvText = new TLatex(0.2, 0.80*maxHistogramValue, noConvClusterLabel);
	    noConvText->SetTextColor(kGreen);
	    noConvText->SetTextSize(0.050);
	    noConvText->Draw();

	    convSumWidth[kEn]->Draw("same");
	    char *convClusterLabel = new char[200];
	    sprintf(convClusterLabel, "Conversion: Mean value %5.3f, RMS %5.3f", convSumWidth[kEn]->GetMean(), convSumWidth[kEn]->GetRMS());
	    TLatex *convText = new TLatex(0.2, 0.70*maxHistogramValue, convClusterLabel);
	    convText->SetTextColor(kRed);
	    convText->SetTextSize(0.050);
	    convText->Draw();

	    char *clusterLimitLabel = new char[200];
	    sprintf(clusterLimitLabel,  "Cluster crystal limits %d to %d used", lowCrystalLimit, highCrystalLimit);  
	    TLatex *clusterLimitText = new TLatex(0.6, 0.60*maxHistogramValue, clusterLimitLabel);
	    clusterLimitText->SetTextColor(kBlack);
	    clusterLimitText->SetTextSize(0.05);
	    clusterLimitText->Draw();

	    char *trackLimitLabel = new char[200];
	    if(useHighPurityTracks) {
	      sprintf(trackLimitLabel,  "%d < HighPurity < %d", lowMultiplicity, highMultiplicity);  
	    }
	    else {
	      sprintf(trackLimitLabel,  "%d < NHITracks < %d", lowMultiplicity, highMultiplicity);  
	    }
	    TLatex *trackLimitText = new TLatex(0.6, 0.50*maxHistogramValue, trackLimitLabel);
	    trackLimitText->SetTextColor(kBlack);
	    trackLimitText->SetTextSize(0.05);
	    trackLimitText->Draw();

	  } // check using conversion suppression

	} // loop over energy bins

	return;

      } // iOption 59 - 60

      double normalizationFactorBin0 = 0;
      double normalizationFactorBin1 = 0;

      double normalizationFactorBinDouble0 = 0;
      double normalizationFactorBinDouble1 = 0;

      for(int kPt=0; kPt<4; kPt++) {
        
	double rescaleFactor = 1.20;
	if(kPt == 0)
	  rescaleFactor = 2.1;
        
	double maxHistogramValue1 = rescaleFactor*sameEventMassHistogramsPtBin[kPt]->GetMaximum();
	sameEventMassHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue1);
       
	if(iOption == 32) {
	  maxHistogramValue1 = rescaleFactor*sameEventMassHistogramsPtBin[kPt]->GetMaximum();
	  mixedEventMassHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue1);
	}

	if(iOption == 53) {
	  maxHistogramValue1 = rescaleFactor*unCorrectedPtBin[kPt]->GetMaximum();
	  unCorrectedPtBin[kPt]->SetMaximum(maxHistogramValue1);
	}
        
	c1->cd(kPt+1);

	if(iOption == 53) {
	  unCorrectedPtBin[kPt]->SetLineColor(2);
	  unCorrectedPtBin[kPt]->SetLineWidth(2);
	  unCorrectedPtBin[kPt]->SetStats(0);
	  unCorrectedPtBin[kPt]->SetXTitle("p_{T} (GeV/c)");
	  unCorrectedPtBin[kPt]->SetYTitle("Counts per 50 MeV/c p_{T} bin");
	  unCorrectedPtBin[kPt]->Draw();
	  correctedPtBin[kPt]->SetLineColor(4);
	  correctedPtBin[kPt]->SetLineWidth(2);
	  correctedPtBin[kPt]->Draw("same");

	  char *nominalPtText = new char[200];
	  float nominalPt = unCorrectedPtBin[kPt]->GetMean();;
	  float nominalPtRMS = unCorrectedPtBin[kPt]->GetRMS();
	  sprintf(nominalPtText, "<p_{T}> = %5.2f #pm %5.2f GeV/c", nominalPt, nominalPtRMS);
	  TLatex *nominalPtLabel = new TLatex(3.2, 0.60*maxHistogramValue1, nominalPtText);
	  nominalPtLabel->SetTextColor(kRed);
	  nominalPtLabel->SetTextSize(0.055);
	  nominalPtLabel->Draw();

	  char *correctedPtText = new char[200];
	  float correctedPt = correctedPtBin[kPt]->GetMean();;
	  float correctedPtRMS = correctedPtBin[kPt]->GetRMS();
	  sprintf(correctedPtText, "<p_{T}> = %5.2f #pm %5.2f GeV/c", correctedPt, correctedPtRMS);
	  TLatex *correctedPtLabel = new TLatex(3.2, 0.50*maxHistogramValue1, correctedPtText);
	  correctedPtLabel->SetTextColor(kBlue);
	  correctedPtLabel->SetTextSize(0.055);
	  correctedPtLabel->Draw();

	} // iOption = 53
	
	if(iOption == 31 || iOption == 33) {
	  sameEventMassHistogramsPtBin[kPt]->Draw();
	  if(iOption == 33) {
	    double countSameEventBackground = 0.0;
	    double countMixedEventBackground = 0.0;
	    double countSameEventBackgroundDouble = 0.0;
	    double countMixedEventBackgroundDouble = 0.0;

	    for(int massBin=1; massBin<200; massBin++) {
	      double massValue = sameEventMassHistogramsPtBin[kPt]->GetBinCenter(massBin);
	      if(massValue >= lowMassBackground && massValue <= highMassBackground) {
		countSameEventBackground += sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
		countMixedEventBackground += mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      }
	      if(massValue >= lowMassBackgroundDouble && massValue <= highMassBackgroundDouble) {
		countSameEventBackgroundDouble += sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
		countMixedEventBackgroundDouble += mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      }
	    } // loop over mass values;

	    //
	    // Get normalization factors for the mixed-event background
	    //

	    if(countSameEventBackground > 0.0 && countMixedEventBackground > 0.0) {
	      double normalizationFactor = countSameEventBackground/countMixedEventBackground; // will be changed if useAverageNormalization is true

	      double normalizationFactorDouble = 0.0;
	      if(countSameEventBackgroundDouble > 0.0 && countMixedEventBackgroundDouble > 0.0) {
		normalizationFactorDouble = countSameEventBackgroundDouble/countMixedEventBackgroundDouble;
	      }

	      double backgroundInterpolationFactor = 0.0;
	      double lastNormalizationFactor = 0.0;
	      double averageNormalizationFactor = 0.0;
	      if(kPt == 0) {
		normalizationFactorBin0 = normalizationFactor;
		normalizationFactorBinDouble0 = normalizationFactorDouble;
		backgroundInterpolationFactor = (normalizationFactorBin0 - normalizationFactorBinDouble0)*backgroundInverseDenominatorDouble;
		averageNormalizationFactor = 0.5*(normalizationFactorBin0  + normalizationFactorBinDouble0);
	        lastNormalizationFactor = normalizationFactorBinDouble0 + (highMidMassBackgroundDouble - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;
	      }
	      if(kPt == 1) {
		normalizationFactorBin1 = normalizationFactor;
		normalizationFactorBinDouble1 = normalizationFactorDouble;
		backgroundInterpolationFactor = (normalizationFactorBin1 - normalizationFactorBinDouble1)*backgroundInverseDenominatorDouble;
		averageNormalizationFactor = 0.5*(normalizationFactorBin1  + normalizationFactorBinDouble1);
		lastNormalizationFactor = normalizationFactorBinDouble1 + (highMidMassBackgroundDouble - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;
              }

	      cout << "\n Second  normalizationFactor " << normalizationFactor;

	      /*
	      cout << "\n normalizationFactorBin0 = " << normalizationFactorBin0;
	      cout << "\n normalizationFactorBinDouble0 = " << normalizationFactorBinDouble0;
	      cout << "\n averageNormalization = " << averageNormalization;
	      cout << "\n lowMidMassBackgroundDouble = " << lowMidMassBackgroundDouble;
	      cout << "\n highMidMassBackgroundDouble = " << highMidMassBackgroundDouble;
	      cout << "\n backgroundInverseDenominatorDouble = " << backgroundInverseDenominatorDouble;
	      cout << "\n backgroundInterpolationFactor = " << backgroundInterpolationFactor;
	      cout << endl;
	      return;
	      */

	      //
	      // Apply the normalization factors in order to get the subtracted pair mass histogram
	      //

	      double thisMassNormalizationFactor = normalizationFactor;
	      if(useAverageNormalization)
		thisMassNormalizationFactor = averageNormalizationFactor;

	      for(int massBin=1; massBin<200; massBin++) {
		double massValue = mixedEventMassHistogramsPtBin[kPt]->GetBinCenter(massBin);

		if(massValue < 0.030)
		  continue;  // don't plot subtracted mass below 30 MeV

		double countsBackground = mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);

		if(kPt == 0 && iOption == 33 && countsBackground > 0.0) {
		  //
		  // The lower of the two pT bins being plotted
		  //
		  double countsForeground = sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
		  double countsSubtracted = 0.0;

		  if(useSingleNormalization || useAverageNormalization) {
		    countsSubtracted = countsForeground - thisMassNormalizationFactor*countsBackground;;
		  }

		  if(useDoubleNormalization) {
		    thisMassNormalizationFactor = normalizationFactorBinDouble0 + (massValue - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;
		    
		    if(massValue > highMidMassBackgroundDouble)
		      thisMassNormalizationFactor = lastNormalizationFactor;  // constant at high pair mass

		    countsSubtracted = countsForeground - thisMassNormalizationFactor*countsBackground;;
		  }

		  //
		  // Renormalize the mixed-event histogram at this mass value
		  //
		  mixedEventMassHistogramsPtBin[kPt]->SetBinContent(massBin, countsBackground*thisMassNormalizationFactor);

		  //
		  // Set the contents of the subtracted pair mass histogram
		  //
		  double errorSubtracted = sqrt(countsForeground + thisMassNormalizationFactor*thisMassNormalizationFactor*countsBackground);
		  subtractedMassHistogramsPtBin0->SetBinContent(massBin, countsSubtracted);
		  subtractedMassHistogramsPtBin0->SetBinError(massBin, errorSubtracted);
		  if(massValue < 0.0) {
		    cout << "\n at pT = 0 the mass = " << massValue;
		    cout << ",  foreground = " << countsForeground;
		    cout << ",  single normalization background = " << normalizationFactor*countsBackground;
		    if(useDoubleNormalization) {
		      cout << "\n Single normalization factor " << normalizationFactor;
		      cout << "\n Double normalization factor " << thisMassNormalizationFactor;
		      cout << "\n Double normalization background " << thisMassNormalizationFactor*countsBackground;
		    }
		    cout << ",  subtracted = " << countsSubtracted;
		    cout << ",  error = " << errorSubtracted;
		  } // check on massValue < 0.0
		} // check on kPt = 0

		if(kPt == 1 && iOption == 33 && countsBackground > 0.0) {
		  //
		  // The higher of the two pT bins being plotted
		  //
		  double countsForeground = sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
		  double countsSubtracted = 0.0;

		  if(useSingleNormalization || useAverageNormalization) {
		    countsSubtracted = countsForeground - thisMassNormalizationFactor*countsBackground;;
		  }
		  if(useDoubleNormalization) {
		    thisMassNormalizationFactor = normalizationFactorBinDouble1 + (massValue - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;

		    if(massValue > highMidMassBackgroundDouble)
		      thisMassNormalizationFactor = lastNormalizationFactor;  // constant at high pair mass

		    countsSubtracted = countsForeground - thisMassNormalizationFactor*countsBackground;;
		  }

		  //
		  // Renormalize the mixed-event historgam at this mass value
		  //
		  mixedEventMassHistogramsPtBin[kPt]->SetBinContent(massBin, countsBackground*thisMassNormalizationFactor);

		  //
		  // Set the contents of the subtracted pair mass histogram
		  //
		  double errorSubtracted = sqrt(countsForeground + thisMassNormalizationFactor*thisMassNormalizationFactor*countsBackground);
		  subtractedMassHistogramsPtBin1->SetBinContent(massBin, countsSubtracted);
		  subtractedMassHistogramsPtBin1->SetBinError(massBin, errorSubtracted);
		  if(massValue < 0.0) {
		    cout << "\n at kPt == 1 the mass = " << massValue;
		    cout << ",  foreground = " << countsForeground;
		    cout << ",  background = " << normalizationFactor*countsBackground;
		    cout << ",  subtracted = " << countsSubtracted;
		    cout << ",  error = " << errorSubtracted;
		  } // check on massValue < 0.0
		} // check on kPt = 1

	      } // loop over mass bins

	      cout << "\n For pT bin " << kPt << " counts in same event normalization region = " << countSameEventBackground;
	      cout << ",  counts in mixed event normalization region = " << countMixedEventBackground;
	      cout << ",  with normalization factor = " << normalizationFactor;
	      cout << ",  histogram rescale factor = " << rescaleFactor;

	      if(useDoubleNormalization) {
		cout << "\n For pT bin " << kPt << " counts in same event double normalization region = " << countSameEventBackgroundDouble;
		cout << ",  counts in mixed event double normalization region = " << countMixedEventBackgroundDouble;
		cout << ",  with double normalization factor = " << normalizationFactorDouble;
	      }
	    
	      cout << endl;

	    } // check countSameEventBackground > 0

	    if((kPt == 2 || kPt == 3) && iOption == 33 && selectConversionOnly) {
	      if(kPt == 2) {
		//
		// Lower pT bin
		//
		subtractedMassHistogramsPtBin0->SetMarkerColor(2);
		subtractedMassHistogramsPtBin0->SetMarkerSize(0.65);
		subtractedMassHistogramsPtBin0->SetMarkerStyle(20);
		double subtractedPeakMaximumValue = 1.80*subtractedMassHistogramsPtBin0->GetMaximum();
		subtractedMassHistogramsPtBin0->SetMaximum(subtractedPeakMaximumValue);
		subtractedMassHistogramsPtBin0->Draw();
              }
	      if(kPt == 3) {
		//
		// Upper pT bin
		//
		subtractedMassHistogramsPtBin1->SetMarkerColor(2);
		subtractedMassHistogramsPtBin1->SetMarkerSize(0.65);
		subtractedMassHistogramsPtBin1->SetMarkerStyle(20);
		subtractedMassHistogramsPtBin1->Draw();
              }
            } // kPt = 2 or kPt = 3
              
	    //
	    // Fit and plot the two subtracted pair mass histograms
	    if((kPt == 2 || kPt == 3) && iOption == 33 && !selectConversionOnly) {
	      if(kPt == 2) {
		//
		// Lower pT bin
		//
		subtractedMassHistogramsPtBin0->SetMarkerColor(2);
		subtractedMassHistogramsPtBin0->SetMarkerSize(0.65);
		subtractedMassHistogramsPtBin0->SetMarkerStyle(20);
		double subtractedPeakMaximumValue = 1.80*subtractedMassHistogramsPtBin0->GetMaximum();
		subtractedMassHistogramsPtBin0->SetMaximum(subtractedPeakMaximumValue);
              
		TF1 *subtractedPeak = new TF1("subtractedPeak", gaussPeak, fitStart, fitEnd, 3);
		subtractedPeak->SetParName(0, "Ampl");
		subtractedPeak->SetParName(1, "Cent");
		subtractedPeak->SetParName(2, "Sigma");
		subtractedPeak->SetParameters(100., 0.135, 0.02);
		subtractedPeak->SetLineColor(kBlue);
                if(!selectConversionMixed)
		  subtractedMassHistogramsPtBin0->Fit("subtractedPeak", "", "", fitStart, fitEnd);
                else
                  subtractedMassHistogramsPtBin0->Fit("subtractedPeak", "", "", 0.05, 0.15);

		float xLabelPosition = 0.025;
              
		double centroidFit = subtractedPeak->GetParameter(1);
		double sigmaFit = fabs(subtractedPeak->GetParameter(2));
		double centroidError = 1000.0*subtractedPeak->GetParError(1);
		double sigmaError = 1000.0*subtractedPeak->GetParError(2);
		char *subCentroidText = new char[200];
		sprintf(subCentroidText, "Fit centroid = %4.1f MeV (#pm %2.1f), #sigma = %4.1f MeV (#pm %2.1f)", 1000.0*centroidFit, centroidError, 1000.0*sigmaFit, sigmaError);
		TLatex *subCentroid = new TLatex(xLabelPosition, 0.85*subtractedPeakMaximumValue, subCentroidText);
		subCentroid->SetTextColor(kBlue);
		subCentroid->SetTextSize(0.055);
		subCentroid->Draw();
              
		double lowCountLimit = centroidFit - sigFactor*sigmaFit;
		double highCountLimit = centroidFit + sigFactor*sigmaFit;
		double summedYield = 0;
		double summedYieldError = 0;
		double summedBackground = 0;
		double summedBackgroundError = 0;
		for(int massBin=1; massBin<200; massBin++) {
		  double massValue = subtractedMassHistogramsPtBin0->GetBinCenter(massBin);
		  if(massValue >= lowCountLimit && massValue <= highCountLimit) {
		    summedYield += subtractedMassHistogramsPtBin0->GetBinContent(massBin);
		    summedYieldError += pow(subtractedMassHistogramsPtBin0->GetBinError(massBin), 2);
		    summedBackground += mixedEventMassHistogramsPtBin[0]->GetBinContent(massBin);
		    summedBackgroundError += normalizationFactorBin0*normalizationFactorBin0*mixedEventMassHistogramsPtBin[0]->GetBinContent(massBin);
		  }
		} // loop over mass bins
		summedYieldError = sqrt(summedYieldError);
		summedBackgroundError = sqrt(summedBackgroundError);
		cout << "\n\n Subtracted peak maximum value = " << subtractedPeakMaximumValue;
		cout << "\n  summed yield = " << summedYield << " +/- " << summedYieldError;
		cout << "\n  summed background = " << summedBackground << " +/- " << summedBackgroundError;
		cout << endl << endl;
              
		char *yieldText = new char[200];
		sprintf(yieldText, "Peak yield in %d#sigma interval = %d #pm %d", int(sigFactor), int(summedYield), int(summedYieldError));
		TLatex *yieldLabel = new TLatex(xLabelPosition, 0.73*subtractedPeakMaximumValue, yieldText);
		yieldLabel->SetTextColor(kBlue);
		yieldLabel->SetTextSize(0.045);
		yieldLabel->Draw();
              
		char *bgrndText = new char[200];
		sprintf(bgrndText, "Background under peak = %d #pm %d", int(summedBackground), int(summedBackgroundError));
		TLatex *bgrndLabel = new TLatex(xLabelPosition, 0.61*subtractedPeakMaximumValue, bgrndText);
		bgrndLabel->SetTextColor(kBlue);
		bgrndLabel->SetTextSize(0.045);
		bgrndLabel->Draw();

		if(summedBackground > 0 && summedYield >0) {
		  char *sbRatioText = new char[200];
		  float sbRatio = summedYield/(summedBackground + summedYield);
		  float sbRatioError = sbRatio*(sqrt(pow(summedYieldError/summedYield,2) + pow(summedBackgroundError/summedBackground,2)));
		  sprintf(sbRatioText, "S/(S+B) = %5.3f #pm %5.3f", sbRatio, sbRatioError);
		  TLatex *sbRatioLabel = new TLatex(xLabelPosition + 0.15, 0.46*subtractedPeakMaximumValue, sbRatioText);
		  sbRatioLabel->SetTextColor(kBlue);
		  sbRatioLabel->SetTextSize(0.055);
		  sbRatioLabel->Draw();
		}

		TLine *baseLine = new TLine(0.0, 0.0, highMass, 0.0);
		baseLine->SetLineColor(kGreen);
		baseLine->SetLineWidth(2);
		baseLine->Draw("same");

	      } // kPt = 2 (bottom left)

	      if(kPt == 3) {
		//
		// Upper pT bin
		//
		subtractedMassHistogramsPtBin1->SetMarkerColor(2);
		subtractedMassHistogramsPtBin1->SetMarkerSize(0.65);
		subtractedMassHistogramsPtBin1->SetMarkerStyle(20);
		double subtractedPeakMaximumValue = 1.80*subtractedMassHistogramsPtBin1->GetMaximum();
		subtractedMassHistogramsPtBin1->SetMaximum(subtractedPeakMaximumValue);
              
		TF1 *subtractedPeak = new TF1("subtractedPeak", gaussPeak, fitStart, fitEnd, 3);
		subtractedPeak->SetParName(0, "Ampl");
		subtractedPeak->SetParName(1, "Cent");
		subtractedPeak->SetParName(2, "Sigma");
		subtractedPeak->SetParameters(100., 0.135, 0.02);
		subtractedPeak->SetLineColor(kBlue);
                if(!selectConversionMixed)
		  subtractedMassHistogramsPtBin1->Fit("subtractedPeak", "", "", fitStart, fitEnd);
                else
                  subtractedMassHistogramsPtBin1->Fit("subtractedPeak", "", "", 0.05, 0.15);


		float xLabelPosition = 0.025;
              
		double centroidFit = subtractedPeak->GetParameter(1);
		double sigmaFit = fabs(subtractedPeak->GetParameter(2));
		double centroidError = 1000.0*subtractedPeak->GetParError(1);
		double sigmaError = 1000.0*subtractedPeak->GetParError(2);
		char *subCentroidText = new char[200];
		sprintf(subCentroidText, "Fit centroid = %4.1f MeV (#pm %2.1f), #sigma = %4.1f MeV (#pm %2.1f)", 1000.0*centroidFit, centroidError, 1000.0*sigmaFit, sigmaError);
		TLatex *subCentroid = new TLatex(xLabelPosition, 0.85*subtractedPeakMaximumValue, subCentroidText);
		subCentroid->SetTextColor(kBlue);
		subCentroid->SetTextSize(0.055);
		subCentroid->Draw();
              
		double lowCountLimit = centroidFit - sigFactor*sigmaFit;
		double highCountLimit = centroidFit + sigFactor*sigmaFit;
		double summedYield = 0;
		double summedYieldError = 0;
		double summedBackground = 0;
		double summedBackgroundError = 0;
		for(int massBin=1; massBin<200; massBin++) {
		  double massValue = subtractedMassHistogramsPtBin1->GetBinCenter(massBin);
		  if(massValue >= lowCountLimit && massValue <= highCountLimit) {
		    summedYield += subtractedMassHistogramsPtBin1->GetBinContent(massBin);
		    summedYieldError += pow(subtractedMassHistogramsPtBin1->GetBinError(massBin), 2);
		    summedBackground += mixedEventMassHistogramsPtBin[1]->GetBinContent(massBin);
		    summedBackgroundError += normalizationFactorBin1*normalizationFactorBin1*mixedEventMassHistogramsPtBin[0]->GetBinContent(massBin);
		  }
		} // loop over mass bins
		summedYieldError = sqrt(summedYieldError);
		summedBackgroundError = sqrt(summedBackgroundError);
		cout << "\n\n Subtracted peak maximum value = " << subtractedPeakMaximumValue;
		cout << "\n  summed yield = " << summedYield << " +/- " << summedYieldError;
		cout << "\n  summed background = " << summedBackground << " +/- " << summedBackgroundError;
		cout << endl << endl;
              
		char *yieldText = new char[200];
		sprintf(yieldText, "Peak yield in %d#sigma interval = %d #pm %d", int(sigFactor), int(summedYield), int(summedYieldError));
		TLatex *yieldLabel = new TLatex(xLabelPosition, 0.73*subtractedPeakMaximumValue, yieldText);
		yieldLabel->SetTextColor(kBlue);
		yieldLabel->SetTextSize(0.045);
		yieldLabel->Draw();
              
		char *bgrndText = new char[200];
		sprintf(bgrndText, "Background under peak = %d #pm %d", int(summedBackground), int(summedBackgroundError));
		TLatex *bgrndLabel = new TLatex(xLabelPosition, 0.61*subtractedPeakMaximumValue, bgrndText);
		bgrndLabel->SetTextColor(kBlue);
		bgrndLabel->SetTextSize(0.045);
		bgrndLabel->Draw();

		if(summedBackground > 0 && summedYield >0) {
		  char *sbRatioText = new char[200];
		  float sbRatio = summedYield/(summedBackground + summedYield);
		  float sbRatioError = sbRatio*(sqrt(pow(summedYieldError/summedYield,2) + pow(summedBackgroundError/summedBackground,2)));
		  sprintf(sbRatioText, "S/(S+B) = %5.3f #pm %5.3f", sbRatio, sbRatioError);
		  TLatex *sbRatioLabel = new TLatex(xLabelPosition + 0.15, 0.46*subtractedPeakMaximumValue, sbRatioText);
		  sbRatioLabel->SetTextColor(kBlue);
		  sbRatioLabel->SetTextSize(0.055);
		  sbRatioLabel->Draw();
		}

		TLine *baseLine = new TLine(0.0, 0.0, highMass, 0.0);
		baseLine->SetLineColor(kGreen);
		baseLine->SetLineWidth(2);
		baseLine->Draw("same");
	      } // kPt = 3 (bottom right)

	    } // kPt == 2 or 3, and iOption == 33
	    else {
              if(!selectConversionOnly) {
	        mixedEventMassHistogramsPtBin[kPt]->SetFillColor(kYellow);
	        mixedEventMassHistogramsPtBin[kPt]->Draw("same");
	        sameEventMassHistogramsPtBin[kPt]->SetLineWidth(2);
	        sameEventMassHistogramsPtBin[kPt]->Draw("same");
              }
	    } //  plot Lower

	  } // iOption = 33

	} // iOption = 31 or iOption = 33

	if(iOption == 32) {
	  mixedEventMassHistogramsPtBin[kPt]->Draw();
	}
	(c1->cd(kPt+1))->SetGrid();
        
	if(kPt == 0) {
	  char *runLabelText1 = new char[200];
	  if(simRun) {
	    sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", sampledEvents);
	  }
	  if(simRunEPOS) {
	    sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", sampledEvents);
	  }
	  if(pPbRunNormal) {
	    sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", sampledEvents);
	  }
	  if(iMultOption >=0 && iMultOption < 4) {
	    sprintf(runLabelText1, "2013 pPb runs, %d sampled HIHighPt events", sampledEvents);
	  }
	  if(ppRun) {
	    sprintf(runLabelText1, "2013 pp runs, %d sampled events", sampledEvents);
	  }
          
	  TLatex *runLabel1 = new TLatex(0.02, 0.93*maxHistogramValue1, runLabelText1);
	  runLabel1->SetTextColor(1);
	  runLabel1->SetTextSize(0.05);
	  runLabel1->Draw();

	  char *runLabelText2 = new char[200];
	  if(useHighPurityTracks) {
	    sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	  }
	  else {
	    sprintf(runLabelText2, "%d < NHITrack < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	  }
	  TLatex *runLabel2 = new TLatex(0.02, 0.86*maxHistogramValue1, runLabelText2);
	  runLabel2->SetTextColor(1);
	  runLabel2->SetTextSize(0.045);
	  runLabel2->Draw();

	  char *runLabelText3 = new char[200];
	  sprintf(runLabelText3, "Number of accepted events %d, use S4/S9 = %4.2f and |1-S25|/S9 cut = %4.2f", acceptedEvents, clustS49Cut, clustS25Cut);
	  TLatex *runLabel3 = new TLatex(0.02, 0.79*maxHistogramValue1, runLabelText3);
	  runLabel3->SetTextColor(1);
	  runLabel3->SetTextSize(0.045);
	  runLabel3->Draw();
          
	  char *runLabelText4 = new char[200];
	  if(useClusterCrystalLimit && (!useClusterCrystalLimitLowPtOnly || lowPtBinLimit[0] < clusterCrystalLimitLowPtOnly)) {
	    if(useClusterCrystalLimitLowPtOnly) {
	      sprintf(runLabelText4, "Cluster crystal limits %d to %d used for cluster pairs with p_{T} < %3.1f GeV/c", lowCrystalLimit, highCrystalLimit, clusterCrystalLimitLowPtOnly);
	    }
	    else {
	      sprintf(runLabelText4, "Cluster crystal limits %d to %d used for all cluster pairs", lowCrystalLimit, highCrystalLimit);
	    }
	  }
	  else {
	    sprintf(runLabelText4, "NO cluster crystal sum limit is used");
	  }
	  TLatex *runLabel4 = new TLatex(0.02, 0.72*maxHistogramValue1, runLabelText4);
	  runLabel4->SetTextColor(1);
	  runLabel4->SetTextSize(0.045);
	  runLabel4->Draw();
          					
	  if(simRun && useConversionSuppression) {
	    TLatex *runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Using conversion suppression (no parent checking)");
	    runLabel6->SetTextColor(kMagenta);
	    runLabel6->SetTextSize(0.045);
	    runLabel6->Draw();
	  }

	  if(simRun && selectConversionMixed) {
	    TLatex *runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Pairing converted and non-converted photon clusters");
	    runLabel6->SetTextColor(kMagenta);
	    runLabel6->SetTextSize(0.045);
	    runLabel6->Draw();
	  }

	  if(simRun && selectConversionOnly) {
	    TLatex *runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Only converted photon clusters are paired");
	    runLabel6->SetTextColor(kMagenta);
	    runLabel6->SetTextSize(0.045);
	    runLabel6->Draw();
	  }

	  if(simRun && !useConversionSuppression && !selectConversionMixed && !selectConversionOnly) {
	    TLatex *runLabel6 = 0;

	    if(!checkKaon)
	      runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Not using conversion suppression nor parent checking");

	    if(useOnlyKaonGParent)
	      runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Not using conversion suppression, require K^{0}_{S} grandparent and #pi^{0} parent");

	    if(excludeKaonGParent)
	      runLabel6 = new TLatex(0.02, 0.58*maxHistogramValue1, "Not using conversion suppression, exclude K^{0}_{S} grandparent and #pi^{0} parent");

	    if(runLabel6) {
	      runLabel6->SetTextColor(kMagenta);
	      runLabel6->SetTextSize(0.045);
	      runLabel6->Draw();
	    }
	  }

	  float yPosition = 0.51;
	  if(!simRun)
	    yPosition = 0.58;

	  if(useDoubleNormalization) {
	    char *runLabel7Text = new char[200];
	    sprintf(runLabel7Text, "Double normalization: %5.3f<m_{#gamma#gamma}<%5.3f, %5.3f<m_{#gamma#gamma}<%5.3f GeV/c^{2}", 
		    lowMassBackgroundDouble,  highMassBackgroundDouble, lowMassBackground, highMassBackground);
	    TLatex *runLabel7 = new TLatex(0.02, yPosition*maxHistogramValue1,runLabel7Text);
	    runLabel7->SetTextColor(1);
	    runLabel7->SetTextSize(0.045);
	    runLabel7->Draw();
	  }
	  if(useSingleNormalization) {
	    char *runLabel7Text = new char[200];
	    sprintf(runLabel7Text, "Single normalization: %5.3f<m_{#gamma#gamma}<%5.3f GeV/c^{2}", 
		    lowMassBackground, highMassBackground);
	    TLatex *runLabel7 = new TLatex(0.02, yPosition*maxHistogramValue1, "Single normalization used");
	    runLabel7->SetTextColor(1);
	    runLabel7->SetTextSize(0.045);
	    runLabel7->Draw();
	  }
	  if(useAverageNormalization) {
	    char *runLabel7Text = new char[200];
	    sprintf(runLabel7Text, "Average normalization: %5.3f<m_{#gamma#gamma}<%5.3f, %5.3f<m_{#gamma#gamma}<%5.3f GeV/c^{2}", 
		    lowMassBackgroundDouble,  highMassBackgroundDouble, lowMassBackground, highMassBackground);
	    TLatex *runLabel7 = new TLatex(0.02, yPosition*maxHistogramValue1,runLabel7Text);
	    runLabel7->SetTextColor(1);
	    runLabel7->SetTextSize(0.045);
	    runLabel7->Draw();
	  }

	  yPosition = 0.42;
	  if(!simRun)
	    yPosition = 0.49;

	  char *plotLabelText = new char[200];
	  sprintf(plotLabelText, "Plot date: %s", asciiDate);
	  TLatex *plotLabel = new TLatex(0.02, yPosition*maxHistogramValue1, plotLabelText);
	  plotLabel->SetTextColor(1);
	  plotLabel->SetTextSize(0.045);
	  plotLabel->Draw();
          
	}
      } // loop over pT bins

      if(iOption == 61) {
	for(int kPt=0; kPt<4; kPt++) {
	  c1->cd(kPt+1);
	  sameEventEtaHistogramsPtBin[kPt]->Draw();
	  (c1->cd(kPt+1))->SetGrid();
	  sameEventEtaHistogramsPtBin[kPt]->SetMinimum(0);
	  double maxHistogramValue = sameEventEtaHistogramsPtBin[kPt]->GetMaximum();
	  if(kPt == 0) {
	    double maxHistogramValue1 = 1.45*maxHistogramValue;
	    sameEventEtaHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue1);
	    char *runLabelText1 = new char[200];
	    sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", int(entriesToProcess));
	    if(simRunEPOS) {
	      sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", int(entriesToProcess));
	    }
	    TLatex *runLabel1 = new TLatex(-1.25, 0.93*maxHistogramValue1, runLabelText1);
	    runLabel1->SetTextColor(2);
	    runLabel1->SetTextSize(0.055);
	    runLabel1->Draw();
            
	    char *runLabelText2 = new char[200];
	    if(useHighPurityTracks) {
	      sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	    }
	    else {
	      sprintf(runLabelText2, "%d < NHITrack < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	    }
            
	    TLatex *runLabel2 = new TLatex(-1.25, 0.85*maxHistogramValue1, runLabelText2);
	    runLabel2->SetTextColor(2);
	    runLabel2->SetTextSize(0.050);
	    runLabel2->Draw();

	    char *runLabelText3 = new char[200];
	    sprintf(runLabelText3, "%5.3f < m_{#gamma#gamma} < %5.3f GeV/c^{2}", lowLimitPi0Mass, highLimitPi0Mass);
            
	    TLatex *runLabel3 = new TLatex(-1.25, 0.78*maxHistogramValue1, runLabelText3);
	    runLabel3->SetTextColor(2);
	    runLabel3->SetTextSize(0.050);
	    runLabel3->Draw();

	    char *plotLabelText = new char[200];
	    sprintf(plotLabelText, "Plot date: %s", asciiDate);
	    TLatex *plotLabel = new TLatex(-1.25, 0.64*maxHistogramValue1, plotLabelText);
	    plotLabel->SetTextColor(1);
	    plotLabel->SetTextSize(0.045);
	    plotLabel->Draw();

	  } // check on first pt bin

	  char *runLabelText4 = new char[200];
	  if(useConversionSuppression) {
	    sprintf(runLabelText4, "Photon conversions suppressed: RMS = %5.3f", sameEventEtaHistogramsPtBin[kPt]->GetRMS());
	  }
	  else {
	    sprintf(runLabelText4, "Photon conversions not suppressed: RMS = %5.3f", sameEventEtaHistogramsPtBin[kPt]->GetRMS());
	  }
	  TLatex *runLabel4 = new TLatex(-1.25, 0.15*maxHistogramValue, runLabelText4);
	  runLabel4->SetTextColor(2);
	  runLabel4->SetTextSize(0.050);
	  runLabel4->Draw();

	} // loop over pt bins
      } // iOption = 61

      char *graphOutputFileName = new char[200];
      sprintf(graphOutputFileName, "pi0MassHighPt_Q%d_327Files_Multiplicity%d-%d_S25Cut-%3.1f_Date%d.pdf", pTQuartile, lowMultiplicity, highMultiplicity, clustS25Cut, date);
      c1->Print(graphOutputFileName);  // PDF file
      sprintf(graphOutputFileName, "pi0MassHighPt_Q%d_327Files_Multiplicity%d-%d__S25Cut-%3.1f_Date%d.root", pTQuartile, lowMultiplicity, highMultiplicity, clustS25Cut, date);
      c1->Print(graphOutputFileName);  // ROOT file
      
      return;
    } // iOption = 31, 32, or 33  2x2 panel of the mass spectra for pT bins 0.7-1.0, 1.0-1.5, 1.5-2.0, and 2.0-2.5 (same, mixed, same + mixed)
		
    if(iOption == 34 || iOption == 35  || iOption == -35 || iOption == 36 || iOption == -36 || iOption == 37 || iOption == 38) { // check energy asymmetry parameter for the pi0 or the eta-meson decay photons
      
      int nPtBins = 4;
      float lowPtBinLimit[4] =  {0.7, 1.0, 1.5, 2.0};
      float highPtBinLimit[4] = {1.0, 1.5, 2.0, 2.5};
					
      float mesonMass = 0.134957;
      int pdgIdChoice = 111;
      if(useOnlyPdg221) {
	pdgIdChoice = 221;
	mesonMass = 0.5475;
      }
			
      float mesonMassSquared = mesonMass*mesonMass;
      float mesonPairsMassMaximum = 2.0*mesonMass + 4*nMassBins*0.001;
      float mesonTripletsMassMaximum = 3.0*mesonMass + 4*nMassBins*0.001;
			
      bool randomPhi = false;
      if(iOption == -35)
	randomPhi = true;
      
      TH1D *sameEventEtaHistogramsPtBin[4];

      TH1D *sameEventMassHistogramsPtBin[4];
      TH1D *mixedEventMassHistogramsPtBin[4];
			
      char *histogramName = new char[200];
      char *histogramTitle = new char[200];
      for(int kPt=0; kPt<nPtBins; kPt++) {
	sprintf(histogramName, "sameEventMassHistogramPtBin%d", kPt);
	sprintf(histogramTitle, "GENERATOR: m_{#gamma#gamma} for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	sameEventMassHistogramsPtBin[kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, highMass);
        
	sameEventMassHistogramsPtBin[kPt]->SetStats(0);
	sameEventMassHistogramsPtBin[kPt]->SetLineColor(1);
	sameEventMassHistogramsPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	sameEventMassHistogramsPtBin[kPt]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
	(sameEventMassHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
	(sameEventMassHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();

	sprintf(histogramName, "sameEventEtaHistogramPtBin%d", kPt);
	sprintf(histogramTitle, "GENERATOR: #eta(#pi^{0}) for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	sameEventEtaHistogramsPtBin[kPt] = new TH1D(histogramName, histogramTitle, 100, -1.5, 1.5);

	sameEventEtaHistogramsPtBin[kPt]->SetStats(0);
	sameEventEtaHistogramsPtBin[kPt]->SetLineColor(1);
	sameEventEtaHistogramsPtBin[kPt]->SetXTitle("#eta");
	sameEventEtaHistogramsPtBin[kPt]->SetYTitle("Counts per 0.03 #eta bin");
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
	(sameEventEtaHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
	(sameEventEtaHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();
        
	sprintf(histogramName, "mixedEventMassHistogramPtBin%d", kPt);
	sprintf(histogramTitle, "Mixed-event m_{#gamma#gamma} for %3.1f<p_{T}<%3.1f GeV/c", lowPtBinLimit[kPt], highPtBinLimit[kPt]);
	mixedEventMassHistogramsPtBin[kPt] = new TH1D(histogramName, histogramTitle, nMassBins, 0.0, highMass);
        
	mixedEventMassHistogramsPtBin[kPt]->SetStats(0);
	mixedEventMassHistogramsPtBin[kPt]->SetLineColor(kMagenta);
	mixedEventMassHistogramsPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
	mixedEventMassHistogramsPtBin[kPt]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->SetLabelSize(0.05);
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->SetLabelSize(0.05);
        
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleSize(0.06);
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->SetTitleOffset(0.75);
	(mixedEventMassHistogramsPtBin[kPt]->GetXaxis())->CenterTitle();
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleSize(0.06);
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->SetTitleOffset(0.75);
	(mixedEventMassHistogramsPtBin[kPt]->GetYaxis())->CenterTitle();
        
      } // histogram initialization
      
      TH1D *subtractedMassHistogramsPtBin1  = new TH1D("subtractedMassHistogramsPtBin1", "GENERATOR: Background-subtracted  m_{#gamma#gamma} for 1.0<p_{T}<1.5 GeV/c", nMassBins, 0.0, highMass);
      subtractedMassHistogramsPtBin1->SetStats(0);
      subtractedMassHistogramsPtBin1->SetLineColor(1);
      subtractedMassHistogramsPtBin1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      subtractedMassHistogramsPtBin1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
      (subtractedMassHistogramsPtBin1->GetXaxis())->SetLabelSize(0.05);
      (subtractedMassHistogramsPtBin1->GetYaxis())->SetLabelSize(0.05);
      
      (subtractedMassHistogramsPtBin1->GetXaxis())->SetTitleSize(0.06);
      (subtractedMassHistogramsPtBin1->GetXaxis())->SetTitleOffset(0.75);
      (subtractedMassHistogramsPtBin1->GetXaxis())->CenterTitle();
      (subtractedMassHistogramsPtBin1->GetYaxis())->SetTitleSize(0.06);
      (subtractedMassHistogramsPtBin1->GetYaxis())->SetTitleOffset(0.75);
      (subtractedMassHistogramsPtBin1->GetYaxis())->CenterTitle();
			
      TH1D *mesonPairsMass  = new TH1D("mesonPairsMass", "GENERATOR: m_{#pi^{0}#pi^{0}}", 4*nMassBins, 2.0*mesonMass, mesonPairsMassMaximum);
      mesonPairsMass->SetStats(0);
      mesonPairsMass->SetLineColor(1);
      mesonPairsMass->SetXTitle("#pi^{0}#pi^{0} Invariant mass (GeV/c^{2})");
      mesonPairsMass->SetYTitle("Counts per 1 MeV/c^{2} mass bin");
      (mesonPairsMass->GetXaxis())->SetLabelSize(0.05);
      (mesonPairsMass->GetYaxis())->SetLabelSize(0.05);
      
      (mesonPairsMass->GetXaxis())->SetTitleSize(0.06);
      (mesonPairsMass->GetXaxis())->SetTitleOffset(0.75);
      (mesonPairsMass->GetXaxis())->CenterTitle();
      (mesonPairsMass->GetYaxis())->SetTitleSize(0.06);
      (mesonPairsMass->GetYaxis())->SetTitleOffset(0.75);
      (mesonPairsMass->GetYaxis())->CenterTitle();			
			
      TH1D *mesonTripletsMass  = new TH1D("mesonTripletsMass", "GENERATOR: m_{#pi^{0}#pi^{0}#pi^{0}}", 4*nMassBins, 3.0*mesonMass, mesonTripletsMassMaximum);
      mesonTripletsMass->SetStats(0);
      mesonTripletsMass->SetLineColor(1);
      mesonTripletsMass->SetXTitle("#pi^{0}#pi^{0}#pi^{0} Invariant mass (GeV/c^{2})");
      mesonTripletsMass->SetYTitle("Counts per 1 MeV/c^{2} mass bin");
      (mesonTripletsMass->GetXaxis())->SetLabelSize(0.05);
      (mesonTripletsMass->GetYaxis())->SetLabelSize(0.05);
      
      (mesonTripletsMass->GetXaxis())->SetTitleSize(0.06);
      (mesonTripletsMass->GetXaxis())->SetTitleOffset(0.75);
      (mesonTripletsMass->GetXaxis())->CenterTitle();
      (mesonTripletsMass->GetYaxis())->SetTitleSize(0.06);
      (mesonTripletsMass->GetYaxis())->SetTitleOffset(0.75);
      (mesonTripletsMass->GetYaxis())->CenterTitle();				
      
      TH1D *azimuthalAngleMeson = new TH1D("azimuthalAngleMeson", "GENERATOR: azimuthal angle of meson", 180., -TMath::Pi(), TMath::Pi());
      azimuthalAngleMeson->SetStats(0);
      azimuthalAngleMeson->SetLineColor(1);
      azimuthalAngleMeson->SetXTitle("Meson azumuthal angle (radians)");
      azimuthalAngleMeson->SetYTitle("Counts per 2-degree bin");
      (azimuthalAngleMeson->GetXaxis())->SetLabelSize(0.05);
      (azimuthalAngleMeson->GetYaxis())->SetLabelSize(0.05);
      
      (azimuthalAngleMeson->GetXaxis())->SetTitleSize(0.06);
      (azimuthalAngleMeson->GetXaxis())->SetTitleOffset(0.75);
      (azimuthalAngleMeson->GetXaxis())->CenterTitle();
      (azimuthalAngleMeson->GetYaxis())->SetTitleSize(0.06);
      (azimuthalAngleMeson->GetYaxis())->SetTitleOffset(0.75);
      (azimuthalAngleMeson->GetYaxis())->CenterTitle();
      
      TH1D *mesonAzimuthalAngleDifference = new TH1D("mesonAzimuthalAngleDifference", "GENERATOR: difference of azimuthal angles of meson pairs", 180., 0.0, TMath::Pi());
      mesonAzimuthalAngleDifference->SetStats(0);
      mesonAzimuthalAngleDifference->SetLineColor(1);
      mesonAzimuthalAngleDifference->SetXTitle("Azimuthal angle difference of a meson pair (radians)");
      mesonAzimuthalAngleDifference->SetYTitle("Counts per 1-degree bin");
      (mesonAzimuthalAngleDifference->GetXaxis())->SetLabelSize(0.05);
      (mesonAzimuthalAngleDifference->GetYaxis())->SetLabelSize(0.05);
      
      (mesonAzimuthalAngleDifference->GetXaxis())->SetTitleSize(0.06);
      (mesonAzimuthalAngleDifference->GetXaxis())->SetTitleOffset(0.75);
      (mesonAzimuthalAngleDifference->GetXaxis())->CenterTitle();
      (mesonAzimuthalAngleDifference->GetYaxis())->SetTitleSize(0.06);
      (mesonAzimuthalAngleDifference->GetYaxis())->SetTitleOffset(0.75);
      (mesonAzimuthalAngleDifference->GetYaxis())->CenterTitle();
      
      if(useClusterEnergyAsymmetryCut)
	cout << "\n Check for size of cluster energy asymmetry cut = " << clusterEnergyAsymmetryCutSize << endl;
      
      TH1D *energyAsymmetryRatio = new TH1D("energyAsymmetryRatio", "Cluster Energy Asymmtery Ratio for #pi^{0} Decays", 100, 0., 1.0);
      energyAsymmetryRatio->SetXTitle("Energy Asymmetry: fabs(E1 - E2)/(E1+E2)");
      energyAsymmetryRatio->SetYTitle("Counts per 0.01 bin");
      (energyAsymmetryRatio->GetXaxis())->SetLabelSize(0.040);
      (energyAsymmetryRatio->GetXaxis())->SetTitleOffset(0.8);
      (energyAsymmetryRatio->GetXaxis())->SetTitleSize(0.05);
      (energyAsymmetryRatio->GetXaxis())->CenterTitle();
      (energyAsymmetryRatio->GetYaxis())->SetLabelSize(0.040);
      (energyAsymmetryRatio->GetYaxis())->SetTitleOffset(0.8);
      (energyAsymmetryRatio->GetYaxis())->SetTitleSize(0.05);
      (energyAsymmetryRatio->GetYaxis())->CenterTitle();
      
      TH2D *energyAsymmetryRatio2D = new TH2D("energyAsymmetryRatio2D", "Cluster Energy Asymmtery Ratio for #pi^{0} Decays vs p_{T}", 100.0, 0.0, 8.0, 100, 0., 0.5);
      energyAsymmetryRatio2D->SetYTitle("Energy Asymmetry: fabs(E1 - E2)/(E1+E2)");
      energyAsymmetryRatio2D->SetXTitle("p_{T} (GeV/c)");
      (energyAsymmetryRatio2D->GetXaxis())->SetLabelSize(0.040);
      (energyAsymmetryRatio2D->GetXaxis())->SetTitleOffset(0.8);
      (energyAsymmetryRatio2D->GetXaxis())->SetTitleSize(0.05);
      (energyAsymmetryRatio2D->GetXaxis())->CenterTitle();
      (energyAsymmetryRatio2D->GetYaxis())->SetLabelSize(0.040);
      (energyAsymmetryRatio2D->GetYaxis())->SetTitleOffset(0.8);
      (energyAsymmetryRatio2D->GetYaxis())->SetTitleSize(0.05);
      (energyAsymmetryRatio2D->GetYaxis())->CenterTitle();
			
      TH1D *azimuthalAnglePhoton = new TH1D("azimuthalAnglePhoton", "GENERATOR: azimuthal angle of decay photons", 180., -TMath::Pi(), TMath::Pi());
      azimuthalAnglePhoton->SetStats(0);
      azimuthalAnglePhoton->SetLineColor(1);
      azimuthalAnglePhoton->SetXTitle("Decay photon azumuthal angle (radians)");
      azimuthalAnglePhoton->SetYTitle("Counts per 2-degree bin");
      (azimuthalAnglePhoton->GetXaxis())->SetLabelSize(0.05);
      (azimuthalAnglePhoton->GetYaxis())->SetLabelSize(0.05);
      
      (azimuthalAnglePhoton->GetXaxis())->SetTitleSize(0.06);
      (azimuthalAnglePhoton->GetXaxis())->SetTitleOffset(0.75);
      (azimuthalAnglePhoton->GetXaxis())->CenterTitle();
      (azimuthalAnglePhoton->GetYaxis())->SetTitleSize(0.06);
      (azimuthalAnglePhoton->GetYaxis())->SetTitleOffset(0.75);
      (azimuthalAnglePhoton->GetYaxis())->CenterTitle();
			
      TH1D *photonAzimuthalAngleDifference = new TH1D("photonAzimuthalAngleDifference", "GENERATOR: difference of azimuthal angles of decay photon pairs", 180., 0.0, TMath::Pi());
      photonAzimuthalAngleDifference->SetStats(0);
      photonAzimuthalAngleDifference->SetLineColor(1);
      photonAzimuthalAngleDifference->SetXTitle("Azimuthal angle difference of a decay photon pair (radians)");
      photonAzimuthalAngleDifference->SetYTitle("Counts per 1-degree bin");
      (photonAzimuthalAngleDifference->GetXaxis())->SetLabelSize(0.05);
      (photonAzimuthalAngleDifference->GetYaxis())->SetLabelSize(0.05);
      
      (photonAzimuthalAngleDifference->GetXaxis())->SetTitleSize(0.06);
      (photonAzimuthalAngleDifference->GetXaxis())->SetTitleOffset(0.75);
      (photonAzimuthalAngleDifference->GetXaxis())->CenterTitle();
      (photonAzimuthalAngleDifference->GetYaxis())->SetTitleSize(0.06);
      (photonAzimuthalAngleDifference->GetYaxis())->SetTitleOffset(0.75);
      (photonAzimuthalAngleDifference->GetYaxis())->CenterTitle();			
			
      int countDecayingMesons = 0;
      int countAcceptedMesons = 0;
      
      if(pdgIdChoice == 221) {
	mesonPairsMass->SetTitle("GENERATOR: m_{#eta#eta}");
	mesonPairsMass->SetXTitle("#eta#eta Invariant mass (GeV/c^{2})");
	mesonTripletsMass->SetTitle("GENERATOR: m_{#eta#eta#eta}");
	mesonTripletsMass->SetXTitle("#eta#eta#eta Invariant mass (GeV/c^{2})");
	energyAsymmetryRatio->SetTitle("Cluster Energy Asymmtery Ratio for #eta(547.5 MeV) Decays");
      }
			
      const int ARRAYMAX = 2000;
      float ecalEnergy[ARRAYMAX];
      float ecalTheta[ARRAYMAX];
      float ecalPhi[ARRAYMAX];
      int ecalMesonNumber[ARRAYMAX];
			
      float pionPt[ARRAYMAX];
      float pionTheta[ARRAYMAX];
      float pionPhi[ARRAYMAX];
      int pionMesonNumber[ARRAYMAX];
      int pArrayMaximum = 0;
      int countTriplets = 0;
      int countTripletsEta = 0;
      int countTripletsEtaBackground = 0;
      int countTripletsEtaBackgroundBins = 0;
      int countExactEta = 0;
			
      float minimumSeparationSameEvent = 100.0;
      float minimumSeparationMixedEvent = 100.0;
      int countSameEventAsymmetryCut = 0;
      int countSameEventSeparationCut = 0;
      int countMixedEventSeparationCut = 0;
      int countSinglePhotonDecay = 0;
      int countDoublePhotonDecay = 0;
      int acceptedEvents = 0;
      
      for (Long64_t i=skipEntries; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);
        
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " and nMesonSize = " << nMesonSize;
	}
        
	if(useHighPurityTracks) {
	  if(nHighPurityTracks < lowMultiplicity || nHighPurityTracks > highMultiplicity)
	    continue;
	}
	else {
	  if(nHITracks < lowMultiplicity || nHITracks > highMultiplicity)
	    continue;
	}
        
	if(zPrimaryVtx < zVertexLowLimit || zPrimaryVtx > zVertexHighLimit) {
	  continue;
	}
        
	acceptedEvents++;
        
	int kArray = 0;
	int pArray = 0;
	for(int jMeson=0; jMeson<nMesonSize; jMeson++) {
					
	  if(useOnlyNonDecay && motherIdMeson[jMeson] != -1)
	    continue;
					
	  if(useOnlyDecay && motherIdMeson[jMeson] == -1)
	    continue;
					
	  bool rejectMeson = true;
	  bool twoPhotonDecay = false;
	  int singlePhotonIndex = 0;
					
	  if(iOption == 38) {
						
	    if(pArray < 1998 && pdgIdMeson[jMeson] == pdgIdChoice &&
	       etaMeson[jMeson] >= etaLowLimit && etaMeson[jMeson] <= etaHighLimit) {
	      float theta = 2.0*atan(exp(-etaMeson[jMeson]));
	      pionPt[pArray] = ptMeson[jMeson];
	      pionTheta[pArray] = theta;
	      pionPhi[pArray]= phiMeson[jMeson];
	      pionMesonNumber[pArray] = jMeson;
	      rejectMeson = false;
	      pArray++;
	    } // check on pi0 meson
						
	  } // check if iOption = 38
					
	  float theta1 = 2.0*atan(exp(-etaDecay1Meson[jMeson]));
	  float energy1 = ptDecay1Meson[jMeson]/sin(theta1);
	  float theta2 = 2.0*atan(exp(-etaDecay2Meson[jMeson]));
	  float energy2 = ptDecay2Meson[jMeson]/sin(theta2);
          
	  if(iOption == 34) {
	    //
	    // require two photons for asymmetry check
	    //
	    if(((useBothPi0Eta && (pdgIdMeson[jMeson] == 111 || pdgIdMeson[jMeson] == 221)) || pdgIdMeson[jMeson] == pdgIdChoice) &&
	       daughtersFromMeson[jMeson] == 2 &&
	       pdgIdDecay1Meson[jMeson] == 22 && pdgIdDecay2Meson[jMeson] == 22 &&
	       etaDecay1Meson[jMeson] >= etaLowLimit && etaDecay2Meson[jMeson] >= etaLowLimit &&
	       etaDecay1Meson[jMeson] <= etaHighLimit && etaDecay2Meson[jMeson] <= etaHighLimit) {
	      rejectMeson = false;
	      twoPhotonDecay = true;
	      countDoublePhotonDecay++;
	    }  // check on two-photon meson decay
	  } // iOption = 34
          
	  if(iOption == 35 || iOption == -35) {
            
	    //
	    // require only one photon for generator background checks
	    //
	    if(((useBothPi0Eta && (pdgIdMeson[jMeson] == 111 || pdgIdMeson[jMeson] == 221)) || pdgIdMeson[jMeson] == pdgIdChoice)) {
	      if(daughtersFromMeson[jMeson] == 2 &&
		 pdgIdDecay1Meson[jMeson] == 22 && pdgIdDecay2Meson[jMeson] == 22 &&
		 etaDecay1Meson[jMeson] >= etaLowLimit && etaDecay2Meson[jMeson] >= etaLowLimit &&
		 etaDecay1Meson[jMeson] <= etaHighLimit && etaDecay2Meson[jMeson] <= etaHighLimit &&
		 energy1 > lowEnergyCutParameter && energy2 > lowEnergyCutParameter) {
		rejectMeson = false;
		twoPhotonDecay = true;
		countDoublePhotonDecay++;
	      } // check for two-photon decay
	      if(!twoPhotonDecay && daughtersFromMeson[jMeson] == 2 &&
		 pdgIdDecay1Meson[jMeson] == 22 &&
		 etaDecay1Meson[jMeson] >= etaLowLimit &&
		 etaDecay1Meson[jMeson] <= etaHighLimit &&
		 energy1 > lowEnergyCutParameter) {
		rejectMeson = false;
		singlePhotonIndex = 1;
		countSinglePhotonDecay++;
	      } // check for single good first photon
	      if(!twoPhotonDecay && daughtersFromMeson[jMeson] == 2 &&
		 pdgIdDecay2Meson[jMeson] == 22 &&
		 etaDecay2Meson[jMeson] >= etaLowLimit &&
		 etaDecay2Meson[jMeson] <= etaHighLimit &&
		 energy2 > lowEnergyCutParameter) {
		rejectMeson = false;
		singlePhotonIndex = 2;
		countSinglePhotonDecay++;
	      } // check for single good first photon
	    } // check for meson type
	  } // iOption = 35 or -35

	  if(iOption == -36 && pdgIdMeson[jMeson] == 111 && fabs(etaMeson[jMeson]) < 1.5) {
	    float pt = ptMeson[jMeson];
	    for(int kPt=0; kPt<nPtBins; kPt++) {
	      if(pt >= lowPtBinLimit[kPt] && pt < highPtBinLimit[kPt]) {
		sameEventEtaHistogramsPtBin[kPt]->Fill(etaMeson[jMeson]);
		break;
	      }
	    } // look for the pt bin
	  } // check option = -36
          
	  if(iOption == 36) {
						
	    if(((useBothPi0Eta && (pdgIdMeson[jMeson] == 111 || pdgIdMeson[jMeson] == 221)) || pdgIdMeson[jMeson] == pdgIdChoice)) {
	      if(daughtersFromMeson[jMeson] == 2 &&
		 pdgIdDecay1Meson[jMeson] == 22 && pdgIdDecay2Meson[jMeson] == 22 &&
		 etaMeson[jMeson] >= etaLowLimit && etaMeson[jMeson] <= etaHighLimit) {
		azimuthalAngleMeson->Fill(phiMeson[jMeson]);
		bool goodPhi1 = false;
		if(etaDecay1Meson[jMeson] >= etaLowLimit && etaDecay1Meson[jMeson] <= etaHighLimit &&
		   energy1 > lowEnergyCutParameter) {
		  azimuthalAnglePhoton->Fill(phiDecay1Meson[jMeson]);
		  goodPhi1 = true;
		} // check on eta and energy valus of first photon decay
		bool goodPhi2 = false;
		if(etaDecay2Meson[jMeson] >= etaLowLimit && etaDecay2Meson[jMeson] <= etaHighLimit &&
		   energy2 > lowEnergyCutParameter) {
		  goodPhi2 = true;
		  azimuthalAnglePhoton->Fill(phiDecay2Meson[jMeson]);
		} // check on eta and energy valus of second photon decay
		int jMesonPlusOne = jMeson + 1;
		for(int mMeson=jMesonPlusOne; mMeson<nMesonSize; mMeson++) {
		  if(((useBothPi0Eta && (pdgIdMeson[mMeson] == 111 || pdgIdMeson[mMeson] == 221)) || pdgIdMeson[mMeson] == pdgIdChoice)) {
		    if(daughtersFromMeson[mMeson] == 2 &&
		       pdgIdDecay1Meson[mMeson] == 22 && pdgIdDecay2Meson[mMeson] == 22 &&
		       etaMeson[mMeson] >= etaLowLimit && etaMeson[mMeson] <= etaHighLimit) {
											
		      float theta3 = 2.0*atan(exp(-etaDecay1Meson[mMeson]));
		      float energy3 = ptDecay1Meson[mMeson]/sin(theta3);
		      float theta4 = 2.0*atan(exp(-etaDecay2Meson[mMeson]));
		      float energy4 = ptDecay1Meson[mMeson]/sin(theta4);
											
		      if(etaDecay1Meson[mMeson] >= etaLowLimit && etaDecay1Meson[mMeson] <= etaHighLimit &&
			 energy3 > lowEnergyCutParameter) {
			azimuthalAnglePhoton->Fill(phiDecay1Meson[mMeson]);
												
			if(goodPhi1) {
			  float photonDifferenceAngle = fabs(phiDecay1Meson[jMeson] - phiDecay1Meson[mMeson]);
													
			  if(photonDifferenceAngle > TMath::Pi()) {
			    photonDifferenceAngle = 2.0*TMath::Pi() - photonDifferenceAngle;}
													
			  photonAzimuthalAngleDifference->Fill(photonDifferenceAngle);
			} // check on goodPhi1
												
			if(goodPhi2) {
			  float photonDifferenceAngle = fabs(phiDecay2Meson[jMeson] - phiDecay1Meson[mMeson]);
													
			  if(photonDifferenceAngle > TMath::Pi()) {
			    photonDifferenceAngle = 2.0*TMath::Pi() - photonDifferenceAngle;}
													
			  photonAzimuthalAngleDifference->Fill(photonDifferenceAngle);
			} // check on goodPhi2
												
												
		      } // check on eta and energy valus of third photon decay
		      if(etaDecay2Meson[mMeson] >= etaLowLimit && etaDecay2Meson[mMeson] <= etaHighLimit &&
			 energy4 > lowEnergyCutParameter) {
			azimuthalAnglePhoton->Fill(phiDecay2Meson[mMeson]);
												
			if(goodPhi1) {
			  float photonDifferenceAngle = fabs(phiDecay1Meson[jMeson] - phiDecay2Meson[mMeson]);
													
			  if(photonDifferenceAngle > TMath::Pi()) {
			    photonDifferenceAngle = 2.0*TMath::Pi() - photonDifferenceAngle;}
													
			  photonAzimuthalAngleDifference->Fill(photonDifferenceAngle);
			} // check on goodPhi1
												
			if(goodPhi2) {
			  float photonDifferenceAngle = fabs(phiDecay2Meson[jMeson] - phiDecay2Meson[mMeson]);
													
			  if(photonDifferenceAngle > TMath::Pi()) {
			    photonDifferenceAngle = 2.0*TMath::Pi() - photonDifferenceAngle;}
													
			  photonAzimuthalAngleDifference->Fill(photonDifferenceAngle);
			} // check on goodPhi2
												
		      } // check on eta and energy valus of fourth photon decay
											
		      azimuthalAngleMeson->Fill(phiMeson[mMeson]);
                      
		      float differenceAngle = fabs(phiMeson[jMeson] - phiMeson[mMeson]);
		      if(differenceAngle > TMath::Pi()) {
			differenceAngle = 2.0*TMath::Pi() - differenceAngle;}
											
		      mesonAzimuthalAngleDifference->Fill(differenceAngle);
		      rejectMeson = false;
		    } // check on second meson decay photons
		  } // check on meson choice
		} // inner meson loop
	      } // check on photon daughters
	    } // check on meson parent
	  } // iOption = 36
          
	  if(rejectMeson)
	    continue;
          
	  countDecayingMesons++;
					
	  if((iOption == 35 || iOption == -35) && kArray < ARRAYMAX - 3) {
	    if(twoPhotonDecay || singlePhotonIndex == 1) {
	      ecalEnergy[kArray] = energy1;
	      ecalTheta[kArray] = theta1;
	      ecalPhi[kArray] = phiDecay1Meson[jMeson];
	      ecalMesonNumber[kArray] = jMeson;
	      kArray++;
	    }
	    if(twoPhotonDecay || singlePhotonIndex == 2) {
	      ecalEnergy[kArray] = energy2;
	      ecalTheta[kArray] = theta2;
	      ecalPhi[kArray] = phiDecay2Meson[jMeson];
	      ecalMesonNumber[kArray] = jMeson;
	      kArray++;
	    } // check on two-photon decay
	  } // check on enough room in the buffer arrays
          
	  if(twoPhotonDecay && energy1 > lowEnergyCutParameter && energy2 > lowEnergyCutParameter) {
	    countAcceptedMesons++;
	    float energyAsymmetry = fabs(energy1 - energy2)/(energy1 + energy2);
	    energyAsymmetryRatio->Fill(energyAsymmetry);
	    energyAsymmetryRatio2D->Fill(ptMeson[jMeson], energyAsymmetry);
	  } // check on energy value s
          
	} // loop over meson collection
				
	if(pArray > pArrayMaximum)
	  pArrayMaximum = pArray;
				
	if(iOption == 38 && pArray > 1) {
	  int pArrayMinus1 = pArray - 1;
	  for(int jArray=0; jArray<pArrayMinus1; jArray++) {
						
	    float cosTheta1 = cos(pionTheta[jArray]);
	    float sinTheta1 = sin(pionTheta[jArray]);
						
	    float phi1 = pionPhi[jArray];
	    float cosphi1 = cos(phi1);
	    float sinphi1 = sin(phi1);
						
	    float pt1 = pionPt[jArray];
	    float p1 = pt1/sinTheta1;
	    float energy1 = sqrt(mesonMassSquared + p1*p1);
						
	    float px1 = pt1*cosphi1;
	    float py1 = pt1*sinphi1;
	    float pz1 = p1*cosTheta1;
						
	    int jArrayPlus1 = jArray + 1;
	    for(int mArray=jArrayPlus1; mArray<pArray; mArray++) {
							
	      if(pionMesonNumber[jArray] == pionMesonNumber[mArray]) {
		cerr << "\n Programming error" << endl;
		return;
	      }
							
	      float cosTheta2 = cos(pionTheta[mArray]);
	      float sinTheta2 = sin(pionTheta[mArray]);
							
	      float phi2 = pionPhi[mArray];
	      float cosphi2 = cos(phi2);
	      float sinphi2 = sin(phi2);
							
	      float pt2 = pionPt[mArray];
	      float p2 = pt2/sinTheta2;
	      float energy2 = sqrt(mesonMassSquared + p2*p2);
							
	      float px2 = pt2*cosphi2;
	      float py2 = pt2*sinphi2;
	      float pz2 = p2*cosTheta2;
							
	      float px = px1 + px2;
	      float py = py1 + py2;
	      float pz = pz1 + pz2;
							
	      float massTest = (energy1 + energy2)*(energy1 + energy2) - px*px - py*py - pz*pz;
	      if(massTest > 0) {
		float invariantMass = sqrt(massTest);
		if(invariantMass > 0.0 && invariantMass < mesonPairsMassMaximum)
		  mesonPairsMass->Fill(invariantMass);
	      } // check on massTest
							
	      if(mArray == pArrayMinus1)
		continue;
							
	      int mArrayPlus1 = mArray + 1;
	      for(int nArray=mArrayPlus1; nArray<pArray; nArray++) {
								
		if(pionMesonNumber[nArray] == pionMesonNumber[mArray]) {
		  cerr << "\n Programming error for nArray" << endl;
		  return;
		}
								
		countTriplets++;
								
		float cosTheta3 = cos(pionTheta[nArray]);
		float sinTheta3 = sin(pionTheta[nArray]);
								
		float phi3 = pionPhi[nArray];
		float cosphi3 = cos(phi3);
		float sinphi3 = sin(phi3);
								
		float pt3 = pionPt[nArray];
		float p3 = pt3/sinTheta3;
		float energy3 = sqrt(mesonMassSquared + p3*p3);
								
		float px3 = pt3*cosphi3;
		float py3 = pt3*sinphi3;
		float pz3 = p3*cosTheta3;
								
		px = px1 + px2 + px3;
		py = py1 + py2 + py3;
		pz = pz1 + pz2 + pz3;
								
		massTest = (energy1 + energy2 + energy3)*(energy1 + energy2 + energy3) - px*px - py*py - pz*pz;
		if(massTest > 0) {
		  float invariantMass = sqrt(massTest);
		  if(invariantMass > 0.0 && invariantMass < mesonTripletsMassMaximum)
		    mesonTripletsMass->Fill(invariantMass);
									
		  if(invariantMass > 0.54785 && invariantMass < 0.54875)
		    countExactEta++;
		}
								
	      } // loop over nArray
							
	    } // loop over mArray
	  } // loop on jArray
					
	} // check if pArray > 1					
        
	if((iOption == 35 || iOption == -35) && kArray > 1) {
	  int kArrayMinusOne = kArray - 1;
          
	  for(int jClu=0; jClu<kArrayMinusOne; jClu++) {
            
	    float cosTheta1 = cos(ecalTheta[jClu]);
	    float sinTheta1 = sin(ecalTheta[jClu]);
	    float phi1 = ecalPhi[jClu];
	    if(randomPhi)
	      phi1 = 2.0*TMath::Pi()*randomValue->Rndm();
            
	    float cosphi1 = cos(phi1);
	    float sinphi1 = sin(phi1);
	    float energy1 = ecalEnergy[jClu];
            
	    float pt1 = energy1*sinTheta1;
	    float px1 = pt1*cosphi1;
	    float py1 = pt1*sinphi1;
            
	    float xCluster1 = rECal*cosphi1;
	    float yCluster1 = rECal*sinphi1;
	    float zCluster1 = rECal/tan(ecalTheta[jClu]);
            
	    int jCluPlusOne = jClu + 1;
            
	    int jMeson = ecalMesonNumber[jClu];
            
	    for(int mClu=jCluPlusOne; mClu<kArray; mClu++) {
              
	      if(ecalMesonNumber[mClu] == jMeson)
		continue;  // skip same parent photons, could put in an artificial energy resolution for these?
              
	      float cosTheta2 = cos(ecalTheta[mClu]);
	      float sinTheta2 = sin(ecalTheta[mClu]);
	      float phi2 = ecalPhi[mClu];
	      if(randomPhi)
		phi2 = 2.0*TMath::Pi()*randomValue->Rndm();
							
	      float cosphi2 = cos(phi2);
	      float sinphi2 = sin(phi2);
	      float energy2 = ecalEnergy[mClu];
              
	      if(useClusterEnergyAsymmetryCut) {
		float ratio = fabs(energy1 - energy2)/(energy1 + energy2);
		if(ratio > clusterEnergyAsymmetryCutSize) {
		  countSameEventAsymmetryCut++;
		  continue;
		}
	      } // check on using aysmmetery cut
              
	      float xCluster2 = rECal*cosphi2;
	      float yCluster2 = rECal*sinphi2;
	      float zCluster2 = rECal/tan(ecalTheta[mClu]);
              
	      float dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		(yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		(zCluster2 - zCluster1)*(zCluster2- zCluster1);
              
	      float dSeparation = sqrt(dSeparationSquared);
              
	      if(dSeparation < minimumSeparation) {
		countSameEventSeparationCut++;
		continue;
	      }
              
	      if(dSeparation <  minimumSeparationSameEvent)
		minimumSeparationSameEvent= dSeparation;
              
	      float pt2 = energy2*sinTheta2;
	      float px2 = pt2*cosphi2;
	      float py2 = pt2*sinphi2;
              
	      float px = px1 + px2;
	      float py = py1 + py2;
	      float pt = sqrt(px*px + py*py);
              
	      float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
	      float openAngle = acos(cosOpenAngle);
	      bool failOpeningAngleCut = false;
	      if(useFixedOpeningAngleCut) {
		failOpeningAngleCut = true;
                
		// opening angle cut according to pT-Dependent parameterization
                
		float pTDependentOpenAngleCut = aOpenAngleCutParameter/pt + bOpenAngleCutParameter/(pt*pt);
		if(openAngle > pTDependentOpenAngleCut)
		  failOpeningAngleCut = false;
	      } // check on using pT-dependent opening angle parameterization
              
	      float massTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
	      if(!failOpeningAngleCut && massTest > 0.0) {
		massTest = sqrt(massTest);
		for(int kPt=0; kPt<nPtBins; kPt++) {
		  if(pt >= lowPtBinLimit[kPt] && pt < highPtBinLimit[kPt]) {
		    sameEventMassHistogramsPtBin[kPt]->Fill(massTest);
		    break;
		  }
		} // look for the pt bin
	      } // check on positive mass
              
	      phi2 = phi2 + TMath::Pi();  // rotate phi angle by 180 degrees
	      cosphi2 = cos(phi2);
	      sinphi2 = sin(phi2);
              
	      xCluster2 = rECal*cosphi2;
	      yCluster2 = rECal*sinphi2;
              
	      dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		(yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		(zCluster2 - zCluster1)*(zCluster2- zCluster1);
              
	      dSeparation = sqrt(dSeparationSquared);
              
	      if(dSeparation < minimumSeparation) {
		countMixedEventSeparationCut++;
		continue;
	      }
              
	      if(dSeparation <  minimumSeparationSameEvent)
		minimumSeparationMixedEvent = dSeparation;
              
	      px2 = pt2*cosphi2;
	      py2 = pt2*sinphi2;
              
	      px = px1 + px2;
	      py = py1 + py2;
	      pt = sqrt(px*px + py*py);
              
	      cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
	      openAngle = acos(cosOpenAngle);
	      failOpeningAngleCut = false;
	      if(useFixedOpeningAngleCut) {
		failOpeningAngleCut = true;
                
		// opening angle cut according to pT-Dependent parameterization
                
		float pTDependentOpenAngleCut = aOpenAngleCutParameter/pt + bOpenAngleCutParameter/(pt*pt);
		if(openAngle > pTDependentOpenAngleCut)
		  failOpeningAngleCut = false;
	      } // check on using pT-dependent opening angle parameterization
              
	      massTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
	      if(!failOpeningAngleCut && massTest > 0.0) {
		massTest = sqrt(massTest);
		for(int kPt=0; kPt<nPtBins; kPt++) {
		  if(pt >= lowPtBinLimit[kPt] && pt < highPtBinLimit[kPt]) {
		    mixedEventMassHistogramsPtBin[kPt]->Fill(massTest);
		    break;
		  }
		} // look for the pt bin
	      } // check on positive mass
              
	    } // inner cluster loop
            
	  } // outer cluster loop
          
	}  // check for at least two clusters
        
      } // loop over entries
      
      cout << "\n\n Number of decaying mesons = " << countDecayingMesons;
      cout << "\n Number of accepted mesons = " << countAcceptedMesons;
      cout << "\n pArrayMaximum " << pArrayMaximum;
      cout << "\n Number of double photon decays = " << countDoublePhotonDecay;
      cout << "\n Number of single photon decays = " << countSinglePhotonDecay;
      cout << "\n Minimum separation same events = " << minimumSeparationSameEvent;
      cout << "\n Minimum separation mixed events = " << minimumSeparationMixedEvent;
      cout << endl;
      
      if(iOption == 34) {
	c1->Divide(1,2);
        
	c1->cd(1);
	energyAsymmetryRatio->Draw();
	(c1->cd(1))->SetGrid();
        
	c1->cd(2);
	energyAsymmetryRatio2D->Draw("contz");
	(c1->cd(2))->SetLogz();
	(c1->cd(2))->SetGrid();
      }
      
      if(iOption == 35 || iOption == -35) {
	c1->Divide(2,2);
        
	for(int kPt=0; kPt<4; kPt++) {
	  double rescaleFactor = 1.20;
	  if(kPt == 0)
	    rescaleFactor = 1.70;
          
	  double countSameEventBackground = 0.0;
	  double countMixedEventBackground = 0.0;
	  for(int massBin=1; massBin<200; massBin++) {
	    double massValue = sameEventMassHistogramsPtBin[kPt]->GetBinCenter(massBin);
	    if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	      countSameEventBackground += sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      countMixedEventBackground += mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	    }
	  } // loop over mass values;
          
	  if(countSameEventBackground > 0.0 && countMixedEventBackground > 0.0) {
	    double normalizationFactor = countSameEventBackground/countMixedEventBackground;
            
	    for(int massBin=1; massBin<200; massBin++) {
	      double massValue = mixedEventMassHistogramsPtBin[kPt]->GetBinCenter(massBin);
	      double countsBackground = mixedEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
	      mixedEventMassHistogramsPtBin[kPt]->SetBinContent(massBin, countsBackground*normalizationFactor);
	      if(kPt == 1 && countsBackground > 0.0) {
		double countsForeground = sameEventMassHistogramsPtBin[kPt]->GetBinContent(massBin);
                
		double countsSubtracted = countsForeground - normalizationFactor*countsBackground;
		double errorSubtracted = sqrt(countsForeground + normalizationFactor*normalizationFactor*countsBackground);
		subtractedMassHistogramsPtBin1->SetBinContent(massBin, countsSubtracted);
		subtractedMassHistogramsPtBin1->SetBinError(massBin, errorSubtracted);
		if(massValue < 0.0) {
		  cout << "\n mass = " << massValue;
		  cout << ",  foreground = " << countsForeground;
		  cout << ",  background = " << normalizationFactor*countsBackground;
		  cout << ",  subtracted = " << countsSubtracted;
		  cout << ",  error = " << errorSubtracted;
		}
	      }
	    }
	    cout << "\n For pT bin " << kPt << " counts in same event normalization region = " << countSameEventBackground;
	    cout << ",  counts in mixed event normalization region = " << countMixedEventBackground;
	    cout << ",  with normalization factor = " << normalizationFactor;
	    cout << ",  histogram rescale factor = " << rescaleFactor;
	    cout << endl;
	  }
          
	  double maxHistogramValue1 = rescaleFactor*sameEventMassHistogramsPtBin[kPt]->GetMaximum();
	  sameEventMassHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue1);
          
	  c1->cd(kPt+1);
	  if(kPt != 3) {
	    sameEventMassHistogramsPtBin[kPt]->SetLineWidth(2);
	    sameEventMassHistogramsPtBin[kPt]->Draw();
	    mixedEventMassHistogramsPtBin[kPt]->SetFillColor(kYellow);
	    mixedEventMassHistogramsPtBin[kPt]->Draw("same");
	    sameEventMassHistogramsPtBin[kPt]->Draw("same");
	    if(kPt == 0) {
	      char *runLabelText1 = new char[200];
	      sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", int(entriesToProcess));
	      if(simRunEPOS) {
		sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", int(entriesToProcess));
	      }
	      TLatex *runLabel1 = new TLatex(0.05, 0.93*maxHistogramValue1, runLabelText1);
	      runLabel1->SetTextColor(2);
	      runLabel1->SetTextSize(0.055);
	      runLabel1->Draw();
              
	      char *runLabelText2 = new char[200];
	      if(useHighPurityTracks) {
		sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	      }
	      else {
		sprintf(runLabelText2, "%d < NHITracks < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	      }              
	      TLatex *runLabel2 = new TLatex(0.05, 0.85*maxHistogramValue1, runLabelText2);
	      runLabel2->SetTextColor(2);
	      runLabel2->SetTextSize(0.050);
	      runLabel2->Draw();
              
	      char *runLabelText3 = new char[200];
	      sprintf(runLabelText3, "Accepted events %d (#pi^{0} decay photons only)", acceptedEvents);
	      if(useOnlyPdg221)
		sprintf(runLabelText3, "Accepted events %d (#eta decay photons only)", acceptedEvents);
	      if(useBothPi0Eta)
		sprintf(runLabelText3, "Accepted events %d (#pi^{0} and #eta decay photons only)", acceptedEvents);
	      TLatex *runLabel3 = new TLatex(0.05, 0.77*maxHistogramValue1, runLabelText3);
	      runLabel3->SetTextColor(2);
	      runLabel3->SetTextSize(0.050);
	      runLabel3->Draw();
              
	      char *runLabelText4 = new char[200];
	      if(randomPhi) {
		sprintf(runLabelText4, "Same-event azimuthal angles are randomized (de-correlated)");
	      }
	      else {
		sprintf(runLabelText4, "Same-event azimuthal angles are NOT randomized (possibly correlated)");
	      }
	      TLatex *runLabel4 = new TLatex(0.05, 0.69*maxHistogramValue1, runLabelText4);
	      runLabel4->SetTextColor(2);
	      runLabel4->SetTextSize(0.050);
	      runLabel4->Draw();
              
	      char *runLabelText5 = new char[200];
	      if(useRotatedBackground) {
		sprintf(runLabelText5, "Using rotated cluster background method");
	      }
	      else {
		sprintf(runLabelText5, "Using mixed event background method");
	      }
	      TLatex *runLabel5 = new TLatex(0.05, 0.61*maxHistogramValue1, runLabelText5);
	      runLabel5->SetTextColor(kMagenta);
	      runLabel5->SetTextSize(0.050);
	      runLabel5->Draw();
	    } // check on kPt = 0 for plot labelling
	  }
	  if(kPt == 3) {
	    // subtractedMassHistogramsPtBin1->SetMaximum(400.0);
	    // subtractedMassHistogramsPtBin1->SetMinimum(-1000.0);
	    subtractedMassHistogramsPtBin1->SetMarkerColor(2);
	    subtractedMassHistogramsPtBin1->SetMarkerSize(0.65);
	    subtractedMassHistogramsPtBin1->SetMarkerStyle(20);
	    subtractedMassHistogramsPtBin1->Draw();
            
	    TLine *baseLine = new TLine(0.0, 0.0, highMass, 0.0);
	    baseLine->SetLineColor(kGreen);
	    baseLine->SetLineWidth(2);
	    baseLine->Draw("same");
	  }
	  (c1->cd(kPt+1))->SetGrid();
          
	} // loop over pT bins
      } // check for iOption = 35
      
      if(iOption == 36 || iOption == -36) {
	c1->Divide(2,2);

	if(iOption == -36) {
	  for(int kPt=0; kPt<4; kPt++) {
	    c1->cd(kPt+1);
	    sameEventEtaHistogramsPtBin[kPt]->Draw();
	    (c1->cd(kPt+1))->SetGrid();

	    if(kPt == 0) {
	      double maxHistogramValue1 = 1.2*sameEventEtaHistogramsPtBin[kPt]->GetMaximum();
	      sameEventEtaHistogramsPtBin[kPt]->SetMaximum(maxHistogramValue1);
	      char *runLabelText1 = new char[200];
	      sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", int(entriesToProcess));
	      if(simRunEPOS) {
		sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", int(entriesToProcess));
	      }
	      TLatex *runLabel1 = new TLatex(-1.25, 0.93*maxHistogramValue1, runLabelText1);
	      runLabel1->SetTextColor(2);
	      runLabel1->SetTextSize(0.055);
	      runLabel1->Draw();
              
	      char *runLabelText2 = new char[200];
	      if(useHighPurityTracks) {
		sprintf(runLabelText2, "%d < HighPurity < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	      }
	      else {
		sprintf(runLabelText2, "%d < NHITracks < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
	      }
              
	      TLatex *runLabel2 = new TLatex(-1.25, 0.85*maxHistogramValue1, runLabelText2);
	      runLabel2->SetTextColor(2);
	      runLabel2->SetTextSize(0.050);
	      runLabel2->Draw();
	    }

	  } // loop over pt bins
	  return;
	}
        
	c1->cd(1);
	azimuthalAngleMeson->Draw();
	(c1->cd(1))->SetGrid();
        
	c1->cd(3);
	mesonAzimuthalAngleDifference->Draw();
	(c1->cd(3))->SetGrid();
				
	c1->cd(2);
	azimuthalAnglePhoton->Draw();
	(c1->cd(2))->SetGrid();
        
	c1->cd(4);
	photonAzimuthalAngleDifference->Draw();
	(c1->cd(4))->SetGrid();
        
      } // check for iOption = 36
			
      if(iOption == 38) {
	c1->Divide(1,2);
				
	c1->cd(1);
	mesonPairsMass->Draw();	
	(c1->cd(1))->SetGrid();
				
	c1->cd(2);
	mesonTripletsMass->Draw();	
	(c1->cd(2))->SetGrid();
	for(int massBin=0; massBin<800; massBin++) {
	  float binCenter = mesonTripletsMass->GetBinCenter(massBin);
	  if(binCenter > 0.540) {
	    cout << "\n massBin " << massBin << ") ";
	    cout << "  massValue " << binCenter;
	    cout << "  with counts " << mesonTripletsMass->GetBinContent(massBin);
	    if(binCenter >= 0.548 && binCenter <= 0.548375) {
	      countTripletsEta += mesonTripletsMass->GetBinContent(massBin);
	    }
	    else {
	      countTripletsEtaBackground += mesonTripletsMass->GetBinContent(massBin);
	      countTripletsEtaBackgroundBins++;
	    }
						
	  }
	  if(binCenter > 0.550) {
	    cout << endl;
	    break;
	  }
					
	}
				
	cout << "\n\n Triplet eta mass " << countTripletsEta;
	cout << "\n triplet eta background " << countTripletsEtaBackground;
	cout << "\n background bins " << countTripletsEtaBackgroundBins;
	cout << "\n net eta yield " << float(countTripletsEta) - float(countTripletsEtaBackground)/countTripletsEtaBackgroundBins;
	cout << "\n total triplets " << countTriplets;
	cout << "\n Exact eta count " << countExactEta;
	cout << endl;
				
      } // check on iOption = 38
      
      return;
      
    } // iOption = 34 or 35 or -35 checking the energy asymmetry parameter or plotting generator level combinatorial spectra
		
    if(iOption == 39) { // plot pi0 pT spectra according to parent

      int countAcceptedEvents = 0;
      int countPi0 = 0;
      int countPi0AboveCut = 0;
      int countEtaMeson = 0;
      int countEtaMesonAboveCut = 0;
      int countDirectPi0 = 0;
      int countDirectPi0AboveCut = 0;
      int countFromEtaPi0 = 0;
      int countFromEtaPi0AboveCut = 0;
      int countFromRhoPlusMinusPi0 = 0;
      int countFromRhoPlusMinusPi0AboveCut = 0;
      int countFromOmegaPi0 = 0;
      int countFromOmegaPi0AboveCut = 0;
      int countFromKStarPi0 = 0;
      int countFromKStarPi0AboveCut = 0;
      int countFromEtaPrimePi0 = 0;
      int countFromEtaPrimePi0AboveCut = 0;
      int countFromDeltaPi0 = 0;
      int countFromDeltaPi0AboveCut = 0;

      for (Long64_t i=0; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);
        
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " and nMesonSize = " << nMesonSize;
	}
        
	if(useHighPurityTracks) {
	  if(nHighPurityTracks < lowMultiplicity || nHighPurityTracks > highMultiplicity)
	    continue;
	}
	else {
	  if(nHITracks < lowMultiplicity || nHITracks > highMultiplicity)
	    continue;
	}
        
	if(zPrimaryVtx < zVertexLowLimit || zPrimaryVtx > zVertexHighLimit) {
	  continue;
	}
        
	countAcceptedEvents++;
	
	for(int jMeson=0; jMeson<nMesonSize; jMeson++) {

	  if(pdgIdMeson[jMeson] == 221) {
	    countEtaMeson++;
	    if(ptMeson[jMeson] > 1.0)
	      countEtaMesonAboveCut++;
	    continue;
	  }

	  if(pdgIdMeson[jMeson] != 111)
	    continue;

	  if(etaMeson[jMeson] < etaLowLimit || etaMeson[jMeson] > etaHighLimit)
	    continue;
 
	  countPi0++;

	  float ptPi0 = ptMeson[jMeson];
	  bool ptPi0AboveCut = ptPi0 > 1.0;

	  if(ptPi0AboveCut)
	    countPi0AboveCut++;

	  if(motherIdMeson[jMeson] == -1) {
	    countDirectPi0++;
	    if(ptPi0AboveCut)
	      countDirectPi0AboveCut++;
	    continue;
	  }
	  if(motherIdMeson[jMeson] == 221) {
	    countFromEtaPi0++;
	    if(ptPi0AboveCut)
	      countFromEtaPi0AboveCut++;
	    continue;
	  }

	  if(motherIdMeson[jMeson] == 213 || motherIdMeson[jMeson] == -213) {
	    countFromRhoPlusMinusPi0++;
	    if(ptPi0AboveCut)
	      countFromRhoPlusMinusPi0AboveCut++;
	    continue;
	  }

	  if(motherIdMeson[jMeson] == 223) {
	    countFromOmegaPi0++;
	    if(ptPi0AboveCut)
	      countFromOmegaPi0AboveCut++;
	    continue;
	  }

	  if(motherIdMeson[jMeson] == 313 || motherIdMeson[jMeson] == -313 ||
	     motherIdMeson[jMeson] == 323 || motherIdMeson[jMeson] == -323) {
	    countFromKStarPi0++;
	    if(ptPi0AboveCut)
	      countFromKStarPi0AboveCut++;
	    continue;
	  }

	  if(motherIdMeson[jMeson] == 331) {
	    countFromEtaPrimePi0++;
	    if(ptPi0AboveCut)
	      countFromEtaPrimePi0AboveCut++;
	    continue;
	  }

	  if(motherIdMeson[jMeson] == 2214 || motherIdMeson[jMeson] == -2214 ||
	     motherIdMeson[jMeson] == 2114 || motherIdMeson[jMeson] == -2114) {
	    countFromDeltaPi0++;
	    if(ptPi0AboveCut)
	      countFromDeltaPi0AboveCut++;
	    continue;
	  }

	}
        
      } // loop over entries

      cout << "\n\n Number of accepted events " << countAcceptedEvents;
      cout << "\n  Number of pi0 " << countPi0 << ", number above pT = 1 GeV/c cut " << countPi0AboveCut;
      cout << "\n  Number of eta-meson " << countEtaMeson << ", number above pT = 1 GeV/c cut " << countEtaMesonAboveCut;
      cout << "\n  Number of direct pi0 " << countDirectPi0 << ", number above pT = 1 GeV/c cut " << countDirectPi0AboveCut;
      cout << "\n  Number pi0 from eta-meson " << countFromEtaPi0 << ", number above pT = 1 GeV/c cut " << countFromEtaPi0AboveCut;
      cout << "\n  Number pi0 from rho+ or rho- " << countFromRhoPlusMinusPi0 << ", number above pT = 1 GeV/c cut " << countFromRhoPlusMinusPi0AboveCut;
      cout << "\n  Number pi0 from omega " << countFromOmegaPi0 << ", number above pT = 1 GeV/c cut " << countFromOmegaPi0AboveCut;
      cout << "\n  Number pi0 from KStar (4 types) " << countFromKStarPi0 << ", number above pT = 1 GeV/c cut " << countFromKStarPi0AboveCut;
      cout << "\n  Number pi0 from eta-prime " << countFromEtaPrimePi0 << ", number above pT = 1 GeV/c cut " << countFromEtaPrimePi0AboveCut;
      cout << "\n  Number pi0 from Delta (4 types) " << countFromDeltaPi0 << ", number above pT = 1 GeV/c cut " << countFromDeltaPi0AboveCut;
      cout << endl;

    }

    if(iOption == 40 || iOption == 41) { // looking at Delta-eta Delta-phi 2D surface plots, with 41 for the mixed-event comparison
			
      TH2D *neutralNeutralCorrelation = new TH2D("neutralNeutralCorrelation", "Resonance Decay #pi^{0}#pi^{0} Spatial Correlation for p_{T}(#pi^{0}) > 0.5 GeV/c", 100, -3.0, 3.0, 100, -2.0, 2.0);
      neutralNeutralCorrelation->SetXTitle("#Delta#eta");
      neutralNeutralCorrelation->SetYTitle("#Delta#phi");
      (neutralNeutralCorrelation->GetXaxis())->SetLabelSize(0.050);
      (neutralNeutralCorrelation->GetXaxis())->SetTitleOffset(1.0);
      (neutralNeutralCorrelation->GetXaxis())->SetTitleSize(0.065);
      (neutralNeutralCorrelation->GetXaxis())->CenterTitle();
      (neutralNeutralCorrelation->GetYaxis())->SetLabelSize(0.050);
      (neutralNeutralCorrelation->GetYaxis())->SetTitleOffset(1.0);
      (neutralNeutralCorrelation->GetYaxis())->SetTitleSize(0.065);
      (neutralNeutralCorrelation->GetYaxis())->CenterTitle();
			
      TH2D *neutralChargedCorrelation = new TH2D("neutralChargedCorrelation", "Resonance Decay #pi^{0}#pi^{#pm} Spatial Correlation for p_{T}(#pi^{#pm}) > 0.3 GeV/c and p_{T}(#pi^{0}) > 0.5 GeV/c", 100, -4.0, 4.0, 100, -2.0, 2.0);
      neutralChargedCorrelation->SetXTitle("#Delta#eta");
      neutralChargedCorrelation->SetYTitle("#Delta#phi");
      (neutralChargedCorrelation->GetXaxis())->SetLabelSize(0.050);
      (neutralChargedCorrelation->GetXaxis())->SetTitleOffset(1.0);
      (neutralChargedCorrelation->GetXaxis())->SetTitleSize(0.065);
      (neutralChargedCorrelation->GetXaxis())->CenterTitle();
      (neutralChargedCorrelation->GetYaxis())->SetLabelSize(0.050);
      (neutralChargedCorrelation->GetYaxis())->SetTitleOffset(1.0);
      (neutralChargedCorrelation->GetYaxis())->SetTitleSize(0.065);
      (neutralChargedCorrelation->GetYaxis())->CenterTitle();			
			
      TH2D *chargedChargedCorrelation = new TH2D("chargedChargedCorrelation", "Resonance Decay #pi^{#pm}#pi^{#pm} Spatial Correlation for p_{T}(#pi^{#pm}) > 0.3 GeV/c ", 100, -4.0, 4.0, 100, -2.0, 2.0);
      chargedChargedCorrelation->SetXTitle("#Delta#eta");
      chargedChargedCorrelation->SetYTitle("#Delta#phi");
      (chargedChargedCorrelation->GetXaxis())->SetLabelSize(0.050);
      (chargedChargedCorrelation->GetXaxis())->SetTitleOffset(1.0);
      (chargedChargedCorrelation->GetXaxis())->SetTitleSize(0.065);
      (chargedChargedCorrelation->GetXaxis())->CenterTitle();
      (chargedChargedCorrelation->GetYaxis())->SetLabelSize(0.050);
      (chargedChargedCorrelation->GetYaxis())->SetTitleOffset(1.0);
      (chargedChargedCorrelation->GetYaxis())->SetTitleSize(0.065);
      (chargedChargedCorrelation->GetYaxis())->CenterTitle();	
			
      TH2D *nonResonancePi0Correlation = new TH2D("nonResonancePi0Correlation", "Non-resonance #pi^{0}#pi^{0} Spatial Correlation for p_{T}(#pi^{0}) > 0.5 GeV/c", 100, -3.0, 3.0, 100, -2.0, 2.0);
      nonResonancePi0Correlation->SetXTitle("#Delta#eta");
      nonResonancePi0Correlation->SetYTitle("#Delta#phi");
      (nonResonancePi0Correlation->GetXaxis())->SetLabelSize(0.050);
      (nonResonancePi0Correlation->GetXaxis())->SetTitleOffset(1.0);
      (nonResonancePi0Correlation->GetXaxis())->SetTitleSize(0.065);
      (nonResonancePi0Correlation->GetXaxis())->CenterTitle();
      (nonResonancePi0Correlation->GetYaxis())->SetLabelSize(0.050);
      (nonResonancePi0Correlation->GetYaxis())->SetTitleOffset(1.0);
      (nonResonancePi0Correlation->GetYaxis())->SetTitleSize(0.065);
      (nonResonancePi0Correlation->GetYaxis())->CenterTitle();
			
      TH2D *nonResonanceMixedCorrelation = new TH2D("nonResonanceMixedCorrelation", "Mixed-Event Non-resonance #pi^{0}#pi^{0} Spatial Correlation for p_{T}(#pi^{0}) > 0.5 GeV/c", 100, -3.0, 3.0, 100, -2.0, 2.0);
      nonResonanceMixedCorrelation->SetXTitle("#Delta#eta");
      nonResonanceMixedCorrelation->SetYTitle("#Delta#phi");
      (nonResonanceMixedCorrelation->GetXaxis())->SetLabelSize(0.050);
      (nonResonanceMixedCorrelation->GetXaxis())->SetTitleOffset(1.0);
      (nonResonanceMixedCorrelation->GetXaxis())->SetTitleSize(0.065);
      (nonResonanceMixedCorrelation->GetXaxis())->CenterTitle();
      (nonResonanceMixedCorrelation->GetYaxis())->SetLabelSize(0.050);
      (nonResonanceMixedCorrelation->GetYaxis())->SetTitleOffset(1.0);
      (nonResonanceMixedCorrelation->GetYaxis())->SetTitleSize(0.065);
      (nonResonanceMixedCorrelation->GetYaxis())->CenterTitle();
			
      TH2D *nonResonanceDividedCorrelation = new TH2D("nonResonanceDividedCorrelation", "Normalized Non-resonance #pi^{0}#pi^{0} Spatial Correlation for p_{T}(#pi^{0}) > 0.5 GeV/c", 100, -3.0, 3.0, 100, -2.0, 2.0);
      nonResonanceDividedCorrelation->SetXTitle("#Delta#eta");
      nonResonanceDividedCorrelation->SetYTitle("#Delta#phi");
      (nonResonanceDividedCorrelation->GetXaxis())->SetLabelSize(0.050);
      (nonResonanceDividedCorrelation->GetXaxis())->SetTitleOffset(1.0);
      (nonResonanceDividedCorrelation->GetXaxis())->SetTitleSize(0.065);
      (nonResonanceDividedCorrelation->GetXaxis())->CenterTitle();
      (nonResonanceDividedCorrelation->GetYaxis())->SetLabelSize(0.050);
      (nonResonanceDividedCorrelation->GetYaxis())->SetTitleOffset(1.0);
      (nonResonanceDividedCorrelation->GetYaxis())->SetTitleSize(0.065);
      (nonResonanceDividedCorrelation->GetYaxis())->CenterTitle();			
			
      int acceptedEvents = 0;
      int decayMesons = 0;
      int orphanMesons = 0;
			
      int countSameEventEntries = 0;
      int countMixedEventEntries = 0;

      const int ARRAYMAX = 2000;
      const int arrayLimitChargedPions = ARRAYMAX;
      const int arrayLimitNeutralPions = 1000;
      const int arrayLimitNonResonancePions = 1000;
			
      float chargedPionEtaArray[ARRAYMAX];
      float chargedPionPhiArray[ARRAYMAX];
      float neutralPionEtaArray[1000];
      float neutralPionPhiArray[1000];
      float nonResonancePionEtaArray[ARRAYMAX];
      float nonResonancePionPhiArray[ARRAYMAX];
      float nonResonancePionPtArray[ARRAYMAX];
      float lastNonResonancePionEtaArray[ARRAYMAX];
      float lastNonResonancePionPhiArray[ARRAYMAX];
      float lastNonResonancePionPtArray[ARRAYMAX];
			
      const float jetPt = 0.0;
			
      int maximumNumberChargedPions = 0;
      int maximumNumberNeutralPions = 0;
      int maximumNumberNonResonancePions = 0;
			
      int lastCountNonResonancePions = 0;
			
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);
        
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " and nMesonSize = " << nMesonSize;
	}

	if(useHighPurityTracks) {
	  if(nHighPurityTracks < lowMultiplicity || nHighPurityTracks > highMultiplicity)
	    continue;
	}
	else {
	  if(nHITracks < lowMultiplicity || nHITracks > highMultiplicity)
	    continue;
	}
        
	acceptedEvents++;
				
	int countNeutralPions = 0;
	int countChargedPions = 0;
	int countNonResonancePions = 0;
								
	for(int jMeson=0; jMeson<nMesonSize; jMeson++) {
					
	  if(pdgIdMeson[jMeson] == 111 && motherIdMeson[jMeson] == -1 && fabs(etaMeson[jMeson]) < 1.5 && ptMeson[jMeson] > 0.5) {
	    orphanMesons++;
	    nonResonancePionEtaArray[countNonResonancePions] = etaMeson[jMeson];
	    nonResonancePionPhiArray[countNonResonancePions] = phiMeson[jMeson];
	    nonResonancePionPtArray[countNonResonancePions] = ptMeson[jMeson];
	    countNonResonancePions++;
	  }
					
	  if(pdgIdMeson[jMeson] == 111 ||  daughtersFromMeson[jMeson] < 2)
	    continue;
					
	  decayMesons++;
					
	  if((pdgIdDecay1Meson[jMeson] == 211 || pdgIdDecay1Meson[jMeson] == -211) && fabs(etaDecay1Meson[jMeson]) < 2.5) {
	    chargedPionEtaArray[countChargedPions] = etaDecay1Meson[jMeson];
	    chargedPionPhiArray[countChargedPions] = phiDecay1Meson[jMeson];
	    countChargedPions++;
	  }
	  if(pdgIdDecay1Meson[jMeson] == 111 && fabs(etaDecay1Meson[jMeson]) < 1.5 && ptDecay1Meson[jMeson] > 0.5) {
	    neutralPionEtaArray[countNeutralPions] = etaDecay1Meson[jMeson];
	    neutralPionPhiArray[countNeutralPions] = phiDecay1Meson[jMeson];
	    countNeutralPions++;
	  }
	  if((pdgIdDecay2Meson[jMeson] == 211 || pdgIdDecay2Meson[jMeson] == -211) && fabs(etaDecay2Meson[jMeson]) < 2.5) {
	    chargedPionEtaArray[countChargedPions] = etaDecay2Meson[jMeson];
	    chargedPionPhiArray[countChargedPions] = phiDecay2Meson[jMeson];
	    countChargedPions++;
	  }
	  if(pdgIdDecay2Meson[jMeson] == 111 && fabs(etaDecay2Meson[jMeson]) < 1.5 && ptDecay2Meson[jMeson] > 0.5) {
	    neutralPionEtaArray[countNeutralPions] = etaDecay2Meson[jMeson];
	    neutralPionPhiArray[countNeutralPions] = phiDecay2Meson[jMeson];
	    countNeutralPions++;
	  }
					
	  if(daughtersFromMeson[jMeson] == 3) {
	    if((pdgIdDecay3Meson[jMeson] == 211 || pdgIdDecay3Meson[jMeson] == -211) && fabs(etaDecay3Meson[jMeson]) < 2.5) {
	      chargedPionEtaArray[countChargedPions] = etaDecay3Meson[jMeson];
	      chargedPionPhiArray[countChargedPions] = phiDecay3Meson[jMeson];
	      countChargedPions++;
	    }
	    if(pdgIdDecay3Meson[jMeson] == 111 && fabs(etaDecay3Meson[jMeson]) < 1.5 && ptDecay3Meson[jMeson] > 0.5) {
	      neutralPionEtaArray[countNeutralPions] = etaDecay3Meson[jMeson];
	      neutralPionPhiArray[countNeutralPions] = phiDecay3Meson[jMeson];
	      countNeutralPions++;
	    }
	  } // check for three daughters

	  if(countChargedPions >= arrayLimitChargedPions) {
	    cerr << "\n Exceeding arrayLimitChargedPions" << endl;
	    return;
	  }
	  if(countNeutralPions >= arrayLimitNeutralPions) {
	    cerr << "\n Exceeding arrayLimitNeutralPions" << endl;
	    return;
	  }
	  if(countNonResonancePions >= arrayLimitNonResonancePions) {
	    cerr << "\n Exceeding arrayLimitNonResonancePions" << endl;
	    return;
	  }
					
	  if(countChargedPions > maximumNumberChargedPions)
	    maximumNumberChargedPions = countChargedPions;
					
	  if(countNeutralPions > maximumNumberNeutralPions)
	    maximumNumberNeutralPions = countNeutralPions;
					
	  if(countNonResonancePions > maximumNumberNonResonancePions)
	    maximumNumberNonResonancePions = countNonResonancePions;
					
	  if(countNeutralPions >= 1000) {
	    cerr << "\n\n  Too many neutral pions " << countNeutralPions << endl;
	    return;
	  }
					
	  if(countChargedPions >= ARRAYMAX) {
	    cerr << "\n\n  Too many charged pions " << countChargedPions << endl;
	    return;
	  }		
					
	  if(countNonResonancePions >= ARRAYMAX) {
	    cerr << "\n\n  Too many non-resonance pions " << countNonResonancePions << endl;
	    return;
	  }				
								 
	} // loop over meson entries
				
	if(countNeutralPions > 1) {
	  int jMesonHighLimit = countNeutralPions - 1;
	  for(int jMeson=0; jMeson<jMesonHighLimit; jMeson++) {
	    int mMesonLowLimit = jMeson + 1;
	    float firstEta = neutralPionEtaArray[jMeson];
	    float firstPhi = neutralPionPhiArray[jMeson];
	    for(int mMeson=mMesonLowLimit; mMeson<countNeutralPions; mMeson++) {
	      float deltaEta = neutralPionEtaArray[mMeson] - firstEta;
	      float deltaPhiSharma = neutralPionPhiArray[mMeson] - firstPhi;
	      deltaPhiSharma = asin(deltaPhiSharma);
	      neutralNeutralCorrelation->Fill(deltaEta, deltaPhiSharma);
	    } // inner mMeson loop
	  } // outer jMeson loop
	} // check on 2 or more neutral pions
				
	if(countNeutralPions > 0 && countChargedPions > 0) {
	  for(int jMeson=0; jMeson<countChargedPions; jMeson++) {
	    float firstEta = neutralPionEtaArray[jMeson];
	    float firstPhi = neutralPionPhiArray[jMeson];
	    for(int mMeson=0; mMeson<countChargedPions; mMeson++) {
	      float deltaEta = chargedPionEtaArray[mMeson] - firstEta;
	      float deltaPhiSharma = chargedPionPhiArray[mMeson] - firstPhi;
	      deltaPhiSharma = asin(deltaPhiSharma);
	      neutralChargedCorrelation->Fill(deltaEta, deltaPhiSharma);
	    } // inner mMeson loop
	  } // outer jMeson loop
	} // check on 1 or more neutral pions and 1 or more charged pions
				
	if(countChargedPions > 1) {
	  int jMesonHighLimit = countChargedPions - 1;
	  for(int jMeson=0; jMeson<jMesonHighLimit; jMeson++) {
	    int mMesonLowLimit = jMeson + 1;
	    float firstEta = chargedPionEtaArray[jMeson];
	    float firstPhi = chargedPionPhiArray[jMeson];
	    for(int mMeson=mMesonLowLimit; mMeson<countChargedPions; mMeson++) {
	      float deltaEta = chargedPionEtaArray[mMeson] - firstEta;
	      float deltaPhiSharma = chargedPionPhiArray[mMeson] - firstPhi;
	      deltaPhiSharma = asin(deltaPhiSharma);
	      chargedChargedCorrelation->Fill(deltaEta, deltaPhiSharma);
	    } // inner mMeson loop
	  } // outer jMeson loop
	} // check on 2 or more charged pions
				
	if(countNonResonancePions > 1) {
	  int jMesonHighLimit = countNonResonancePions - 1;
	  for(int jMeson=0; jMeson<jMesonHighLimit; jMeson++) {
	    int mMesonLowLimit = jMeson + 1;
	    float firstEta = nonResonancePionEtaArray[jMeson];
	    float firstPhi = nonResonancePionPhiArray[jMeson];
	    float firstPt = nonResonancePionPtArray[jMeson];
	    for(int mMeson=mMesonLowLimit; mMeson<countNonResonancePions; mMeson++) {
	      float deltaEta = nonResonancePionEtaArray[mMeson] - firstEta;
	      float deltaPhiSharma = nonResonancePionPhiArray[mMeson] - firstPhi;
	      deltaPhiSharma = asin(deltaPhiSharma);
	      if(firstPt > jetPt || nonResonancePionPtArray[mMeson] > jetPt) {
		nonResonancePi0Correlation->Fill(deltaEta, deltaPhiSharma);
		countSameEventEntries++;
	      }
	    } // inner mMeson loop
	  } // outer jMeson loop
	} // check on 2 or more non-resonance pions
				
	if(lastCountNonResonancePions > 0) {
	  if(countNonResonancePions > 0) {
	    for(int jMeson=0; jMeson<lastCountNonResonancePions; jMeson++) {
	      float firstEta = lastNonResonancePionEtaArray[jMeson];
	      float firstPhi = lastNonResonancePionPhiArray[jMeson];
	      float firstPt = lastNonResonancePionPtArray[jMeson];
	      for(int mMeson=0; mMeson<countNonResonancePions; mMeson++) {
		float deltaEta = nonResonancePionEtaArray[mMeson] - firstEta;
		float deltaPhiSharma = nonResonancePionPhiArray[mMeson] - firstPhi;
		deltaPhiSharma = asin(deltaPhiSharma);
		if(firstPt > jetPt || nonResonancePionPtArray[mMeson] > jetPt) {
		  nonResonanceMixedCorrelation->Fill(deltaEta, deltaPhiSharma);
		  countMixedEventEntries++;
		}
	      } // inner mMeson loop
	    } // outer jMeson loop
	  } // check for number of entries in current event
	} // check for number of entries in last event
				
	if(countNonResonancePions > 0) {
	  //
	  // Set up new last event arrays
	  //
	  lastCountNonResonancePions = countNonResonancePions;
	  for(int jMeson=0; jMeson<lastCountNonResonancePions; jMeson++) {
	    lastNonResonancePionEtaArray[jMeson] = nonResonancePionEtaArray[jMeson];
	    lastNonResonancePionPhiArray[jMeson] = nonResonancePionPhiArray[jMeson];
	    lastNonResonancePionPtArray[jMeson] = nonResonancePionPtArray[jMeson];
	  }
	} // check for number of entries in current event
				
      } // loop over hTree entries
			
      cout << "\n\n Number of accepted events " << acceptedEvents;
      cout << ", number of decay mesons " << decayMesons;
      cout << "\n Maximum number of neutral pions " << maximumNumberNeutralPions;
      cout << "\n Maximum number of charged pions " << maximumNumberChargedPions;
      cout << "\n Maximum number of non-resonance pions " << maximumNumberNonResonancePions;
      cout << endl;
			
      float normFactor = 1.0;
      if(countMixedEventEntries > 0 && countSameEventEntries > 0 )
	normFactor = float(countMixedEventEntries)/float(countSameEventEntries);
						
      c1->Divide(2,2);

      if(iOption == 40) {
								
	c1->cd(1);
	neutralNeutralCorrelation->SetStats(0);
	neutralNeutralCorrelation->SetMinimum(0);
	neutralNeutralCorrelation->Draw("surf3");
				
	c1->cd(2);
	neutralChargedCorrelation->SetStats(0);
	neutralChargedCorrelation->SetMinimum(0);
	neutralChargedCorrelation->Draw("surf3");
				
	c1->cd(3);
	chargedChargedCorrelation->SetStats(0);
	chargedChargedCorrelation->SetMinimum(0);
	chargedChargedCorrelation->Draw("surf3");
				
	c1->cd(4);
	nonResonancePi0Correlation->SetStats(0);
	nonResonancePi0Correlation->SetMinimum(0);
	nonResonancePi0Correlation->Draw("surf3");
      } // iOption = 40
			
      if(iOption == 41) {
				
	c1->cd(1);
	neutralNeutralCorrelation->SetStats(0);
	neutralNeutralCorrelation->SetMinimum(0);
	neutralNeutralCorrelation->Draw("surf3");
				
	c1->cd(2);
	nonResonancePi0Correlation->SetStats(0);
	nonResonancePi0Correlation->SetTitle("Same-Event Non-resonance #pi^{0}#pi^{0} Spatial Correlation for p_{T}(#pi^{0}) > 0.5 GeV/c");
	nonResonancePi0Correlation->SetMinimum(0);
	nonResonancePi0Correlation->Draw("surf3");
				
	c1->cd(3);
	nonResonanceMixedCorrelation->SetStats(0);
	nonResonanceMixedCorrelation->SetMinimum(0);
	nonResonanceMixedCorrelation->Draw("surf3");
				
	c1->cd(4);
	nonResonanceDividedCorrelation->Divide(nonResonancePi0Correlation, nonResonanceMixedCorrelation, normFactor);
	nonResonanceDividedCorrelation->SetStats(0);
	nonResonanceDividedCorrelation->SetMinimum(0);
	nonResonanceDividedCorrelation->SetMaximum(5.0);
	nonResonanceDividedCorrelation->Draw("surf3");
				
      } // iOption = 41
		
      cout << "\n\n Same-event entries " << countSameEventEntries;
      cout << "\n Mixed-event entries " << countMixedEventEntries;
      cout << "\n Normalization factor " << normFactor;
      cout << endl;
			
      return;
			
    } // iOption = 40, looking at Delta-eta Delta-phi 2D surface plots
		
    if(iOption == 42) { // look at K0-short decays to pizero in the simTracks collection
			
      int acceptedEvents = 0;
      int countTotalK0Short = 0;
      int countPrimaryK0Short = 0;
      int countPrimaryAcceptedK0Short = 0;
      int maximumNumberAcceptedK0Short = 0;
			
      int countTotalPi0 = 0;
      int countLowRadiusPi0 = 0;
      int countNoDecayPi0 = 0;
      int countAcceptedPi0 = 0;
      int maximumNumberAcceptedPi0 = 0;
			
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);
        
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " njSim size= " << njSim;
	}
    
    	if(useHighPurityTracks) {
	  if(nHighPurityTracks < lowMultiplicity || nHighPurityTracks > highMultiplicity)
	    continue;
	}
	else {
	  if(nHITracks < lowMultiplicity || nHITracks > highMultiplicity)
	    continue;
	}    

	if(zPrimaryVtx < zVertexLowLimit || zPrimaryVtx > zVertexHighLimit) {
	  continue;
	}
        
	acceptedEvents++;

	for(int jSim=0; jSim<=njSim; jSim++) {

	  if(pdgIdSim[jSim] == 310) {
	    countTotalK0Short++;
	    if(bestAngleMatchGenSim[jSim] < 0.01) {
	      countPrimaryK0Short++;
	      if(etaSim[jSim] > etaLowLimit && etaSim[jSim] < etaHighLimit) {
		countPrimaryAcceptedK0Short++;
	      } // check eta limit
	    } // check for primary
	  } // check for any K0-short
	} // loop over simTracks
								
      } // loop over entries
						 
      cout << "\n\n Number of K0-short " << countTotalK0Short << " in " << acceptedEvents << " accepted events";
      cout << "\n Number of primary K0-short " << countPrimaryK0Short;
      cout << "\n Number of accepted primary K0-short " << countPrimaryAcceptedK0Short;
      cout << "\n Maximum number of accepted primary K0-short in one event " << maximumNumberAcceptedK0Short;
      cout << "\n Total pi0 " << countTotalPi0;
      cout << "\n Number of low radius pi0 " << countLowRadiusPi0;
      cout << "\n Number of no decay pi0 " << countNoDecayPi0;
      cout << "\n Number of accepted pi0 " << countAcceptedPi0;
      cout << "\n Maximum number of accepted pi0 in one event " << maximumNumberAcceptedPi0;
      cout << endl;
			
      return;
			
    } // iOption = 42, look at K0-short decays to pizero in the simTrack collection

    if(iOption == 43) { // making histograms for toy model

      //
      // Conversion histograms for primary photons
      // Distributions in eta: one for unconverted primary, other for converted primary
      // Primary photon defined as trackIdSim <= highestMatchedGenSimTrack
      // Converted photon identified by number of daughters
      // Ratio of two histograms is the conversion probability at that eta value
      // Can get a fit function of eta to predict this conversion probability
      //   [All done September 22, 2013]
      // 

      cout << "\n Creating output file pi0Multiplicity.root" << endl;

      TFile *pi0MultiplicityFile = new TFile("pi0Multiplicity.root", "recreate", "Multiplicity histograms for pi0");

      TH1F *allParentPi0Pt = new TH1F("allParentPi0Pt", "p_{T} Distribution for all #pi^{0} mesons", 2000, 0.0, 20.0);
      TH1F *allParentEtaPt = new TH1F("allParentEtaPt", "p_{T} Distribution for all #eta-mesons", 2000, 0.0, 20.0);

      TH1F *allParentPi0Multiplicity = new TH1F("allParentPi0Multiplicity", "Multiplicities for all #pi^{0} mesons", 201, 0, 200);
      TH1F *allParentEtaMultiplicity = new TH1F("allParentEtaMultiplicity", "Multiplicities for all #eta-mesons", 201, 0, 200);

      TH1F *allPrimaryPhotonEta = new TH1F("allPrimaryPhotonEta", "Eta distribution for all photons > 300 MeV", 300, -1.5, 1.5);
      TH1F *convertedPrimaryPhotonEta = new TH1F("convertedPrimaryPhotonEta", "Eta distribution for converted photons > 300 MeV", 300, -1.5, 1.5);

      int lastCountAllParentPi0 = 0;
      for (Long64_t i=0; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);
        
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " with nMesonSize = " << nMesonSize << " and lastCountAllParentPi0 = " <<  lastCountAllParentPi0 ;
	}

	int countAllParentPi0 = 0;
	int countAllParentEta = 0;
	for(int jMeson=0; jMeson<nMesonSize; jMeson++) {
	  if(pdgIdMeson[jMeson] == 111) {
	    countAllParentPi0++;
	    allParentPi0Pt->Fill(ptMeson[jMeson]);
	  }
	  if(pdgIdMeson[jMeson] == 221) {
	    countAllParentEta++;
	    allParentEtaPt->Fill(ptMeson[jMeson]);
	  }
	} // loop over meson collection
	allParentPi0Multiplicity->Fill(countAllParentPi0);
	allParentEtaMultiplicity->Fill(countAllParentEta);

	lastCountAllParentPi0 = countAllParentPi0;
	for(int jSim=0; jSim<njSim; jSim++) {
	  if(pdgIdSim[jSim] != 22)
	    continue;

	  if(fabs(etaSim[jSim]) > 1.5)
	    continue;

	  if(trackIdSim[jSim] > highestMatchedGenSimTrack)
	    continue;

	  if(eSim[jSim] < 0.30)
	    continue;
	  
	  allPrimaryPhotonEta->Fill(etaSim[jSim]);

	  if(nDaughtersSim[jSim] !=0 )
	    convertedPrimaryPhotonEta->Fill(etaSim[jSim]);
	     
	} // loop over sim entries

      } // loop over entries

      pi0MultiplicityFile->Write();
      pi0MultiplicityFile->Close();

      return;

    } // iOption = 43 produce output file with histograms

    if(iOption == 44) { // study of photon conversion 


      TFile *pi0ConversionsFile = new TFile("pi0Conversions.root", "recreate", "Conversion histograms for pi0");

      TH2D *higherElectronPt = new TH2D("higherElectronPt", "Decay Energy Fraction vs Parent Pt for Higher p_{T} Daughter", 100, 0.0, 3.0, 100, 0., 1.0);
      TH2D *lowerElectronPt = new TH2D("lowerElectronPt", "Decay Energy Fraction vs Parent Pt for Lower p_{T} Daughter", 100, 0.0, 3.0, 100, 0., 1.0);
      TH2D *ratioElectronPt = new TH2D("ratioElectronPt", "Ratio of Decay Higher p_{T} over Lower p_{T} Daughter", 100, 0.0, 3.0, 100, 0.5, 5.0);

      int maximumNumberOfConversions = 0;
      int countExcessDaughters = 0;
      int totalConvertingPhotons = 0;
      int totalConvertingPhotonsTwoDaughters = 0;

      bool firstExcess = true;

      for (Long64_t i=0; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);
        
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " njSim size= " << njSim;
	}

	const int MAXIMUMCONVERSIONLIMIT = 200;
	bool firstConversion = true;
	int countConvertingPhotons = 0;
	int countDaughters[200];
	int parentIndex[200];
	float parentPt[200];
	float photon1Pt[200];
	float photon2Pt[200];
	for(int kConvert=0; kConvert<MAXIMUMCONVERSIONLIMIT; kConvert++) {
	  countDaughters[kConvert] = 0;
	}
	for (int iSim=0; iSim<njSim; iSim++) {

	  if(parentKSim[iSim] < 0)
	    continue;

	  if((pdgIdSim[iSim] == 11 || pdgIdSim[iSim] == -11) && parentIdSim[iSim] == 22 && parentTrackSim[iSim] <= highestMatchedGenSimTrack) {
	    int kSimParent = parentKSim[iSim];
	    
	    if(nDaughtersSim[kSimParent] != 2) continue;

	    // cout << "\n kSimParent " << kSimParent;
	    // cout << ",  idParent = " << pdgIdSim[kSimParent];
	    // cout << ",  thisPdgId = " << pdgIdSim[iSim];
	    // cout << endl;
	    if(firstConversion) {
	      firstConversion = false;
	      parentIndex[0] = kSimParent;
	      parentPt[0] = ptSim[kSimParent];
	      photon1Pt[0] = ptSim[iSim];
	      countDaughters[0] = 1;
	      countConvertingPhotons = 1;
	    }
	    else {
	      //
	      // check if this parent has already been found
	      //

	      bool foundPhotonParent = false;
	      for(int kConvert=0; kConvert<countConvertingPhotons; kConvert++) {
		if(kSimParent == parentIndex[kConvert]){
		  foundPhotonParent = true;
		  countDaughters[kConvert]++;
		  if(countDaughters[kConvert] == 2) {
		    photon2Pt[kConvert] = ptSim[iSim];
		    totalConvertingPhotonsTwoDaughters++;
		  }
		  else {
		    if(firstExcess) {
		      firstExcess = false;
		      cout << "\n\n First excess event " << Event;
		      cout << "\n   lumisection " << LumiSection;
		      cout << "\n   kSimParent " << kSimParent;
		      cout << "\n   nDaughtersParent " << nDaughtersSim[kSimParent];
		      cout << endl;
		    }
		    countExcessDaughters++;
		  }
		  break;
		} // check previous index
	      } // loop over previous converting photons

	      if(!foundPhotonParent) {
		if(countConvertingPhotons < MAXIMUMCONVERSIONLIMIT) {
		  parentIndex[countConvertingPhotons] = kSimParent;
		  parentPt[countConvertingPhotons] = ptSim[kSimParent];
		  photon1Pt[countConvertingPhotons] = ptSim[iSim];
		  countDaughters[countConvertingPhotons] = 1;
		  countConvertingPhotons++;
		}
		else {
		  cerr << "\n\n Reached maximum conversion limit" << endl << endl;
		  return;
		}
	      } // new conversion photon

	    } // branch if beyond the first converting photon
	  } // check for parent being a primary photon

	} // loop over simulation entries

	if(maximumNumberOfConversions < countConvertingPhotons)
	  maximumNumberOfConversions = countConvertingPhotons;

	//
	// Fill histograms
	//
	for(int kConvert=0; kConvert<countConvertingPhotons; kConvert++) {
	  if( countDaughters[kConvert] != 2 || parentPt[kConvert] < 0.3 || parentPt[kConvert] > 3.0)
	    continue;

	  float largerPt = photon1Pt[kConvert];
	  float smallerPt = photon2Pt[kConvert];
	  if(photon1Pt[kConvert] < photon2Pt[kConvert]) {
	    largerPt = photon2Pt[kConvert];
	    smallerPt = photon1Pt[kConvert];
	  }

	  higherElectronPt->Fill(parentPt[kConvert], largerPt/parentPt[kConvert]);
	  lowerElectronPt->Fill(parentPt[kConvert], smallerPt/parentPt[kConvert]);

	  if(smallerPt > 0.1)
	    ratioElectronPt->Fill(parentPt[kConvert], largerPt/smallerPt);

	} // loop over converting photons for this event

	totalConvertingPhotons += countConvertingPhotons;

      } // loop over entries

      cout << "\n\n  maximumNumberOfConversions = " << maximumNumberOfConversions;
      cout << "\n  totalConvertingPhotons = " << totalConvertingPhotons;
      cout << "\n  totalConvertingPhotonsTwoDaughters = " << totalConvertingPhotonsTwoDaughters;
      cout << "\n  countExcessDaughters = " << countExcessDaughters;

      cout << endl;

      pi0ConversionsFile->Write();
      pi0ConversionsFile->Close();

      return;

    } // option = 44, study photon conversions

    if(iOption == 45) { // study of HBT pairs correlations 

      int nqBins = 100;
      float maxQ = 0.5;
      float qStartNormalization = maxQ - 0.20;
      TH1F *sameEventQLong = new TH1F("sameEventQLong", "Foreground Q-Long Spectrum", nqBins, 0.0, maxQ);
      sameEventQLong->SetXTitle("#DeltaQ-Long (GeV/c)");
      sameEventQLong->SetYTitle("Counts per 5MeV bin" );
      (sameEventQLong->GetXaxis())->SetLabelSize(0.040);
      (sameEventQLong->GetXaxis())->SetTitleOffset(0.75);
      (sameEventQLong->GetXaxis())->SetTitleSize(0.055);
      (sameEventQLong->GetXaxis())->CenterTitle();
      (sameEventQLong->GetYaxis())->SetLabelSize(0.040);
      (sameEventQLong->GetYaxis())->SetTitleOffset(0.75);
      (sameEventQLong->GetYaxis())->SetTitleSize(0.055);
      (sameEventQLong->GetYaxis())->CenterTitle();

      TH1F *sameEventQOut = new TH1F("sameEventQOut", "Foreground Q-Out Spectrum", nqBins, 0.0, maxQ);
      sameEventQOut->SetXTitle("#DeltaQ-Out (GeV/c)");
      sameEventQOut->SetYTitle("Counts per 5MeV bin" );
      (sameEventQOut->GetXaxis())->SetLabelSize(0.040);
      (sameEventQOut->GetXaxis())->SetTitleOffset(0.75);
      (sameEventQOut->GetXaxis())->SetTitleSize(0.055);
      (sameEventQOut->GetXaxis())->CenterTitle();
      (sameEventQOut->GetYaxis())->SetLabelSize(0.040);
      (sameEventQOut->GetYaxis())->SetTitleOffset(0.75);
      (sameEventQOut->GetYaxis())->SetTitleSize(0.055);
      (sameEventQOut->GetYaxis())->CenterTitle();

      TH1F *sameEventQSide = new TH1F("sameEventQSide", "Foreground Q-Side Spectrum", nqBins, 0.0, maxQ);
      sameEventQSide->SetXTitle("#DeltaQ-Side (GeV/c)");
      sameEventQSide->SetYTitle("Counts per 5MeV bin" );
      (sameEventQSide->GetXaxis())->SetLabelSize(0.040);
      (sameEventQSide->GetXaxis())->SetTitleOffset(0.75);
      (sameEventQSide->GetXaxis())->SetTitleSize(0.055);
      (sameEventQSide->GetXaxis())->CenterTitle();
      (sameEventQSide->GetYaxis())->SetLabelSize(0.040);
      (sameEventQSide->GetYaxis())->SetTitleOffset(0.75);
      (sameEventQSide->GetYaxis())->SetTitleSize(0.055);
      (sameEventQSide->GetYaxis())->CenterTitle();

      TH1F *mixedEventQLong = new TH1F("mixedEventQLong", "Mixed-Event Q-Long Spectrum", nqBins, 0.0, maxQ);
      mixedEventQLong->SetXTitle("#DeltaQ-Long (GeV/c)");
      mixedEventQLong->SetYTitle("Counts per 5 MeV bin" );
      (mixedEventQLong->GetXaxis())->SetLabelSize(0.040);
      (mixedEventQLong->GetXaxis())->SetTitleOffset(0.75);
      (mixedEventQLong->GetXaxis())->SetTitleSize(0.055);
      (mixedEventQLong->GetXaxis())->CenterTitle();
      (mixedEventQLong->GetYaxis())->SetLabelSize(0.040);
      (mixedEventQLong->GetYaxis())->SetTitleOffset(0.75);
      (mixedEventQLong->GetYaxis())->SetTitleSize(0.055);
      (mixedEventQLong->GetYaxis())->CenterTitle();

      TH1F *mixedEventQOut = new TH1F("mixedEventQOut", "Mixed-Event Q-Out Spectrum", nqBins, 0.0, maxQ);
      mixedEventQOut->SetXTitle("#DeltaQ-Out (GeV/c)");
      mixedEventQOut->SetYTitle("Counts per 5 MeV bin" );
      (mixedEventQOut->GetXaxis())->SetLabelSize(0.040);
      (mixedEventQOut->GetXaxis())->SetTitleOffset(0.75);
      (mixedEventQOut->GetXaxis())->SetTitleSize(0.055);
      (mixedEventQOut->GetXaxis())->CenterTitle();
      (mixedEventQOut->GetYaxis())->SetLabelSize(0.040);
      (mixedEventQOut->GetYaxis())->SetTitleOffset(0.75);
      (mixedEventQOut->GetYaxis())->SetTitleSize(0.055);
      (mixedEventQOut->GetYaxis())->CenterTitle();
      
      TH1F *mixedEventQSide = new TH1F("mixedEventQSide", "Mixed-Event Q-Side Spectrum", nqBins, 0.0, maxQ);
      mixedEventQSide->SetXTitle("#DeltaQ-Side (GeV/c)");
      mixedEventQSide->SetYTitle("Counts per 5 MeV bin" );
      (mixedEventQSide->GetXaxis())->SetLabelSize(0.040);
      (mixedEventQSide->GetXaxis())->SetTitleOffset(0.75);
      (mixedEventQSide->GetXaxis())->SetTitleSize(0.055);
      (mixedEventQSide->GetXaxis())->CenterTitle();
      (mixedEventQSide->GetYaxis())->SetLabelSize(0.040);
      (mixedEventQSide->GetYaxis())->SetTitleOffset(0.75);
      (mixedEventQSide->GetYaxis())->SetTitleSize(0.055);
      (mixedEventQSide->GetYaxis())->CenterTitle();

      TH1F *normalizedEventQLong = new TH1F("normalizedEventQLong", "Normalized Q-Long Spectrum", nqBins, 0.0, maxQ);
      normalizedEventQLong->SetTitleSize(0.15);
      normalizedEventQLong->SetXTitle("#DeltaQ-Long (GeV/c)");
      normalizedEventQLong->SetYTitle("Counts per 5 MeV bin" );
      (normalizedEventQLong->GetXaxis())->SetLabelSize(0.040);
      (normalizedEventQLong->GetXaxis())->SetTitleOffset(0.75);
      (normalizedEventQLong->GetXaxis())->SetTitleSize(0.055);
      (normalizedEventQLong->GetXaxis())->CenterTitle();
      (normalizedEventQLong->GetYaxis())->SetLabelSize(0.040);
      (normalizedEventQLong->GetYaxis())->SetTitleOffset(0.75);
      (normalizedEventQLong->GetYaxis())->SetTitleSize(0.055);
      (normalizedEventQLong->GetYaxis())->CenterTitle();

      TH1F *normalizedEventQOut = new TH1F("normalizedEventQOut", "Normalized Q-Out Spectrum", nqBins, 0.0, maxQ);
      normalizedEventQOut->SetTitleSize(0.15);
      normalizedEventQOut->SetXTitle("#DeltaQ-Out (GeV/c)");
      normalizedEventQOut->SetYTitle("Counts per 5 MeV bin" );
      (normalizedEventQOut->GetXaxis())->SetLabelSize(0.040);
      (normalizedEventQOut->GetXaxis())->SetTitleOffset(0.75);
      (normalizedEventQOut->GetXaxis())->SetTitleSize(0.055);
      (normalizedEventQOut->GetXaxis())->CenterTitle();
      (normalizedEventQOut->GetYaxis())->SetLabelSize(0.040);
      (normalizedEventQOut->GetYaxis())->SetTitleOffset(0.75);
      (normalizedEventQOut->GetYaxis())->SetTitleSize(0.055);
      (normalizedEventQOut->GetYaxis())->CenterTitle();

      TH1F *normalizedEventQSide = new TH1F("normalizedEventQSide", "Normalized Q-Side Spectrum", nqBins, 0.0, maxQ);
      normalizedEventQSide->SetTitleSize(0.15);
      normalizedEventQSide->SetXTitle("#DeltaQ-Side (GeV/c)");
      normalizedEventQSide->SetYTitle("Counts per 5 MeV bin" );
      (normalizedEventQSide->GetXaxis())->SetLabelSize(0.040);
      (normalizedEventQSide->GetXaxis())->SetTitleOffset(0.75);
      (normalizedEventQSide->GetXaxis())->SetTitleSize(0.055);
      (normalizedEventQSide->GetXaxis())->CenterTitle();
      (normalizedEventQSide->GetYaxis())->SetLabelSize(0.040);
      (normalizedEventQSide->GetYaxis())->SetTitleOffset(0.75);
      (normalizedEventQSide->GetYaxis())->SetTitleSize(0.055);
      (normalizedEventQSide->GetYaxis())->CenterTitle();

      const int MAXRECOPI0MASS = 1000;
      int countTotalRecoPi0Mass = 0;
      int countRecoPi0 = 0;
      double recoPi0Px[1000];
      double recoPi0Py[1000];
      double recoPi0Pz[1000];

      int countRecoPi0Last = 0;
      double recoPi0PxLast[1000];
      double recoPi0PyLast[1000];
      double recoPi0PzLast[1000];

      const double pi0MassWindow = 0.030;
      const double lowLimitPi0Mass2 =  0.134976 - pi0MassWindow;  // NEED TO REVIEW
      const double highLimitPi0Mass2 = 0.134976 + pi0MassWindow;  // NEED TO REVIEW

      int maxArraySize = 0;
      
      float minimumSeparationSameEvent = 100.0;
      int countSameEventSeparationCut = 0;
      int countZVertexCut = 0;
      int countMatchedClusters = 0;
      int acceptedEvents = 0;
      int countConvertedPhotons = 0;
      int countNonDecayParents = 0;
      int countDecayParents = 0;
      int countTotalClusters = 0;
      int countSameEventAsymmetryCut = 0;
      int countIsolationCut = 0;

      for (Long64_t i=0; i<entriesToProcess; i++) {
        
	hTree->GetEntry(i);
        
	if(i%nEntries10 == 0 || i < 10) {
	  cout << "\n The entry " << i << " with event " << Event << " and nClu = " << nClu;
	}
        
	if(useHighPurityTracks) {
	  if(nHighPurityTracks < lowMultiplicity || nHighPurityTracks > highMultiplicity)
	    continue;
	}
	else {
	  if(nHITracks < lowMultiplicity || nHITracks > highMultiplicity)
	    continue;
	}
        
	if(zPrimaryVtx < zVertexLowLimit || zPrimaryVtx > zVertexHighLimit) {
	  countZVertexCut++;
	  continue;
	}
	
	acceptedEvents++;
        
	int kArray = 0;
	const int ARRAYMAX = 2000;
	// int kToJCluMap[2000];     for future use
	// int taggedCluster[2000];  for future use
	float ecalEnergy[2000];
	float ecalTheta[2000];
	float ecalPhi[2000];
	int kCrystal[2000];
	
	int countRecoPi0Mass = 0;
	// int firstPairMember[1000];  for future use
	// int secondPairMember[1000]; for future use
	// float etaRecoPi0Mass[1000]; for future use
	// float phiRecoPi0Mass[1000]; for future use
        
	for(int jClu=0; jClu<nClu; jClu++) {
					
	  if(useTrackMatchSuppression  && nGoodRecoMatches[jClu] > 0) {
	    countMatchedClusters++;
	    continue;  // skip clusters which have a match to a charged particle track
	  }
          
	  if(useClusterCrystalLimit) {
	    if(nCryClu[jClu] < lowCrystalLimit || nCryClu[jClu] > highCrystalLimit)
	      continue;
	  } // check on using crystal number limits
          
	  if(useClusterPairCrystalSumLimit && nCryClu[jClu] >= highClusterPairCrystalSumLimit)
	    continue;  // already over the cluster pair crystal sum limit with one cluster
					
	  bool failIsolationCut = false;
	  if(useClusterIsolationCut) {
	    float phi1 = ecalPhi[jClu];
	    float cosphi1 = cos(phi1);
	    float sinphi1 = sin(phi1);
            
	    float xCluster1 = rECal*cosphi1;
	    float yCluster1 = rECal*sinphi1;
	    float zCluster1 = rECal/tan(ecalTheta[jClu]);
            
	    for(int mClu=0; mClu<nClu; mClu++) {
	      if(mClu != jClu) {
		float phi2 = ecalPhi[mClu];
		float cosphi2 = cos(phi2);
		float sinphi2 = sin(phi2);
                
		float xCluster2 = rECal*cosphi2;
		float yCluster2 = rECal*sinphi2;
		float zCluster2 = rECal/tan(ecalTheta[mClu]);
                
		float dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		  (yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		  (zCluster2 - zCluster1)*(zCluster2- zCluster1);
                
		if(dSeparationSquared < clusterIsolationCutSizeSquared) {
		  failIsolationCut = true;
		  break;
		}
                
	      }
	    } // loop over all other clusters
            
	  } // check on using isolation cut
          
	  if(failIsolationCut) {
	    countIsolationCut++;
	    continue;
	  }
          
	  bool convertedPhoton = false;
	  bool decayFromGrandParentResonance = false;
					
	  if(useConversionSuppression && simulationTruthChoice == 1) {
	    //
	    // check if this cluster is associated with an unconverted photon in the mergedTrackTruth collection
	    //
	    bool foundUnconvertedPhoton = false;
	    for(int jMerge=0; jMerge<mergedTrackTruthSize; jMerge++) {
	      if(primaryTrackMerge[jMerge] == 1 && pdgIdMerge[jMerge] == 22) {
		if(numberDecayVerticesMerge[jMerge] == 0) {
		  int indexEcal = bestEcalIndexMatch[jMerge];
		  if(indexEcal > -1 && indexEcal < nClu) {
		    if(indexEcal == jClu && bestEcalAngleMatch[jMerge] >= 0.0 && bestEcalAngleMatch[jMerge] < 0.010) {
		      foundUnconvertedPhoton = true;
		      break;
		    } // check if angle match is good
		  } // check for valid indexEcal
		} // check that this photon did not convert
	      } // check that the merge entry is a primary photon
	    } // loop over jMerge
	    convertedPhoton = !foundUnconvertedPhoton;
	  } // check on using conversion suppression with the mergedTrackTruth collection
					
	  if(useConversionSuppression && simulationTruthChoice == 2) {
	    //
	    // check if this cluster is associated with an unconverted photon in the simTracks collection
	    //
	    if(countNoConvertSimMatchEcal[jClu] == 0 ||  bestNoConvertSimAngleEcal[jClu] > 0.018) {
	      convertedPhoton = true;
	    } // check whether the cluster can be matched to an unconverted photon
	    else {
	      //
	      // These clusters are matched to unconverted photons in the simTracks collection
	      //
	      // Check that the photon parent meson did not come from a higher mass resonance decay
	      //
	      int jSim = bestNoConvertSimIndexEcal[jClu];
	      if(jSim < 0 || jSim >= njSim) {
		cerr << "\n Invalid value of jSim " << jSim << " for a matched unconverted ECAL cluster jClu " << jClu;
		cerr << endl;
		return;
	      } // safety check
	      if(gMotherGenIdSim[jSim] > -1) {
		decayFromGrandParentResonance = true;
		countDecayParents++;
	      }
	      else {
		countNonDecayParents++; // these will also be unconverted photons
	      } // check on grandmother PDG ID
	    } // branch for further checking of unconverted photons
	  } // check on using conversion suppression with the simTracksCollection collection

	  if(useOnlyNonDecay && decayFromGrandParentResonance)
	    continue;

	  if(useOnlyDecay && !decayFromGrandParentResonance)
	    continue;
					
	  countTotalClusters++;
	  if(convertedPhoton) {
	    countConvertedPhotons++;
	    continue;
	  }
          
	  int crystalIndex = nCryClu[jClu] - 1;
					
	  float ecalEnergyUncorrected = S9Clu[jClu];
	  if(ecalEnergyUncorrected > lowEnergyCutParameter && S4Clu[jClu]/ecalEnergyUncorrected > 0.80) {
            
	    if(kArray < ARRAYMAX) {
	      // kToJCluMap[kArray] = jClu;   for future use
	      // taggedCluster[kArray] = 0;   for future use
	      kCrystal[kArray] =  nCryClu[jClu];
	      ecalPhi[kArray] = phiClu[jClu];
	      float ecalEta = etaClu[jClu];
	      ecalTheta[kArray] = 2.0*atan(exp(-ecalEta));
	      ecalEnergy[kArray] = ecalEnergyUncorrected;
              
	      if(useEnergyCorrection)
		ecalEnergy[kArray] = crystalCorrectionFunction(crystalIndex, ecalEnergyUncorrected);
							
	    }
	    kArray++;
						
	  }  // check for S9Clu above cut parameter
					
	} // loop on clusters

	if(kArray > maxArraySize)
	  maxArraySize = kArray;

	if(kArray > 1) { // check for at least two clusters
	  countRecoPi0 = 0;
	  int kArrayMinusOne = kArray - 1;
					
	  for(int jClu=0; jClu<kArrayMinusOne; jClu++) {
						
	    float cosTheta1 = cos(ecalTheta[jClu]);
	    if(randomRotate && randomValue->Rndm() > 0.5) {
	      cosTheta1 = -cosTheta1;
	    }
	    float sinTheta1 = sin(ecalTheta[jClu]);
	    float phi1 = ecalPhi[jClu];
	    if(randomRotate) {
	      phi1 += 2*TMath::Pi()*randomValue->Rndm();
	    }
	    float cosphi1 = cos(phi1);
	    float sinphi1 = sin(phi1);
	    float energy1 = ecalEnergy[jClu];
						
	    float pt1 = energy1*sinTheta1;
	    float px1 = pt1*cosphi1;
	    float py1 = pt1*sinphi1;
	    float pz1 = energy1*cosTheta1;
						
	    float xCluster1 = rECal*cosphi1;
	    float yCluster1 = rECal*sinphi1;
	    float zCluster1 = rECal/tan(ecalTheta[jClu]);
            
	    int jCluPlusOne = jClu + 1;
            
	    int jCrystal = kCrystal[jClu];
            
	    for(int mClu=jCluPlusOne; mClu<kArray; mClu++) {
              
	      if(useClusterPairCrystalSumLimit) {
		int clusterPairCrystalSum = jCrystal + kCrystal[mClu];
		if(clusterPairCrystalSum < lowClusterPairCrystalSumLimit ||
		   clusterPairCrystalSum > highClusterPairCrystalSumLimit)
		  continue;
	      }
							
	      float cosTheta2 = cos(ecalTheta[mClu]);
	      if(randomRotate && randomValue->Rndm() > 0.5) {
		cosTheta2 = -cosTheta2;
	      }
	      float sinTheta2 = sin(ecalTheta[mClu]);
	      float phi2 = ecalPhi[mClu];
	      if(randomRotate) {
		phi2 += 2*TMath::Pi()*randomValue->Rndm();
	      }
	      float cosphi2 = cos(phi2);
	      float sinphi2 = sin(phi2);
	      float energy2 = ecalEnergy[mClu];
              
	      if(useClusterEnergyAsymmetryCut) {
		float ratio = fabs(energy1 - energy2)/(energy1 + energy2);
		if(ratio > clusterEnergyAsymmetryCutSize) {
		  countSameEventAsymmetryCut++;
		  continue;
		}
	      } // check on using aysmmetery cut
              
	      float xCluster2 = rECal*cosphi2;
	      float yCluster2 = rECal*sinphi2;
	      float zCluster2 = rECal/tan(ecalTheta[mClu]);
              
	      float dSeparationSquared = (xCluster2 - xCluster1)*(xCluster2- xCluster1) +
		(yCluster2 - yCluster1)*(yCluster2- yCluster1) +
		(zCluster2 - zCluster1)*(zCluster2- zCluster1);
              
	      float dSeparation = sqrt(dSeparationSquared);
              
	      if(dSeparation < minimumSeparation) {
		countSameEventSeparationCut++;
		continue;
	      }
              
	      if(dSeparation <  minimumSeparationSameEvent)
		minimumSeparationSameEvent= dSeparation;
              
	      float pt2 = energy2*sinTheta2;
	      float px2 = pt2*cosphi2;
	      float py2 = pt2*sinphi2;
	      float pz2 = energy2*cosTheta2;

	      float px = px1 + px2;
	      float py = py1 + py2;
	      float pt = sqrt(px*px + py*py);
	      float pz = pz1 + pz2;
	      // float ptot = sqrt(pt*pt + pz*pz);  for future use
							
	      float cosOpenAngle = cosTheta1*cosTheta2 + sinTheta1*sinTheta2*cos(phi1 - phi2);
	      float openAngle = acos(cosOpenAngle);
	      bool failOpeningAngleCut = false;
	      if(useFixedOpeningAngleCut) {
		failOpeningAngleCut = true;
                
		// opening angle cut according to pT-Dependent parameterization
                
		float pTDependentOpenAngleCut = aOpenAngleCutParameter/pt + bOpenAngleCutParameter/(pt*pt);
		if(openAngle > pTDependentOpenAngleCut)
		  failOpeningAngleCut = false;
	      } // check on using pT-dependent opening angle parameterization
              
	      float massTest = 2.0*energy1*energy2*(1.0 - cosOpenAngle);
	      if(!failOpeningAngleCut && massTest > 0.0) {
		massTest = sqrt(massTest);
		if(massTest > lowLimitPi0Mass2 && massTest < highLimitPi0Mass2) { // should defer filling the mass histogram until the pi0 pair mass opening angle check is made
		  if(countRecoPi0Mass < MAXRECOPI0MASS) {
		    // firstPairMember[countRecoPi0Mass] = jClu;  for future use
		    // secondPairMember[countRecoPi0Mass] = mClu; for future use
		    // phiRecoPi0Mass[countRecoPi0Mass] = atan2(py,px);  for future use
		    // float pi0Theta = acos(pz/ptot);  for future use
		    // etaRecoPi0Mass[countRecoPi0Mass] = -log(tan(pi0Theta/2.0));  for future use					 
		    countRecoPi0Mass++;
		  } // safety check
		} // check if this looks like a pi0 mass
		//
		// For HBT studies
		// Accumulate a set of accepted pi0
		// The acceptance conditions are the mass is within a certain window, and the pT is within a certain window
		// The accepted pi0 will be according to their pT, eta, theta, phi, and possible simulation or data tags
		//
		// At the end of the event, the pi0 pairs are combined into the qLong, qOut, and qSide foreground histograms
		// The equivalent mixed-event histogram are also produced
		// The foreground and mixed-event histograms are divided at the end of the scan
		//
		if(pt > lowPi0PtCut && pt < highPi0PtCut && massTest > lowLimitPi0Mass2  && massTest < highLimitPi0Mass2) {
		  countTotalRecoPi0Mass++;
		  recoPi0Px[countRecoPi0] = px;
		  recoPi0Py[countRecoPi0] = py;
		  recoPi0Pz[countRecoPi0] = pz;
		  countRecoPi0++;
		} // check on value of reco mass and the pT cut

	      } // check on positive mass
              
	    } // inner cluster loop
            
	  } // outer cluster loop

	} // check on kArray > 1

	if(countRecoPi0 > 1) { // to do foreground event
	  //
	  // Foreground same event
	  //
	  int countRecoPi0MinusOne = countRecoPi0 - 1;
	  for(int kPi0=0; kPi0<countRecoPi0MinusOne; kPi0++) {
	    double px1 = recoPi0Px[kPi0];
	    double py1 = recoPi0Py[kPi0];
	    double pz1 = recoPi0Pz[kPi0];

	    double phi1 = atan2(py1, px1);
	    double theta1 = acos(pz1/sqrt(px1*px1 + py1*py1 + pz1*pz1));

	    float xpi01 = rECal*cos(phi1);
	    float ypi01 = rECal*sin(phi1);
	    float zpi01 = rECal/tan(theta1);

	    int kPi0PlusOne = kPi0 + 1;
	    for(int jPi0=kPi0PlusOne; jPi0<countRecoPi0; jPi0++) {
	      double px2 = recoPi0Px[jPi0];
	      double py2 = recoPi0Py[jPi0];
	      double pz2 = recoPi0Pz[jPi0];

	      double phi2 = atan2(py2, px2);
	      double theta2 = acos(pz2/sqrt(px2*px2 + py2*py2 + pz2*pz2));

	      float xpi02 = rECal*cos(phi2);
	      float ypi02 = rECal*sin(phi2);
	      float zpi02 = rECal/tan(theta2);
              
	      float dSeparationSquared = (xpi02 - xpi01)*(xpi02- xpi01) +
		(ypi02 - ypi01)*(ypi02- ypi01) +
		(zpi02 - zpi01)*(zpi02- zpi01);
              
	      float dSeparation = sqrt(dSeparationSquared);
              
	      if(dSeparation < minimumSeparationPi0)
		continue;

	      double qLong = fabs(pz2 - pz1);
	      
	      //
	      // Calculate the kT direction (out) from the mean of pt1 + pt2
	      //
	      double ktx = (px1 + px2)/2.0;
	      double kty = (py1 + py2)/2.0;
	      double ktMag = sqrt(ktx*ktx + kty*kty);
	    
	      double qOut1 = (px1*ktx + py1*kty)/ktMag;
	      double qOut2 = (px2*ktx + py2*kty)/ktMag;

	      double qOut = fabs(qOut2 - qOut1);

	      //
	      // Establish the parallel (side) unit vector perpendicular to kT
	      //
	      double parax = kty;
	      double paray = -ktx;
	      double paraMag = ktMag;  // same two components but in different Cartesian directions

	      double qSide1 = (px1*parax + py1*paray)/paraMag;
	      double qSide2 = (px2*parax + py2*paray)/paraMag;

	      double qSide = (qSide2 - qSide1);

	      double fillWeight = 1.0;
	      if(useHBT) {
		fillWeight = gaus3DCorrelation(qLong, qOut, qSide, lambdaHBT);
		if(fillWeight > 2.0 || fillWeight < 1.0) {
		  cout << "\n Fill weight error " << fillWeight << " with ";
		  cout << "  qLong " << qLong << ", qOut " << qOut << ", qSide " << qSide;
		  cout << "\n kPi0 " << kPi0 << " with countRecoPi0  " << countRecoPi0;
		  cout << endl;
		  return;
		}
	      }

	      if(qLong < maxQ)
		sameEventQLong->Fill(qLong, fillWeight);

	      if(qOut < maxQ)
		sameEventQOut->Fill(qOut, fillWeight);

	      if(qSide < maxQ)
		sameEventQSide->Fill(qSide, fillWeight);

	    } // inner loop over jPi0
	  } // outer loop over kPi0

	} // check for countRecoPi0 > 0 to do foreground event

	if(countRecoPi0 > 0) { // to do background event
	  if(countRecoPi0Last > 0) {
	    //
	    // do the background
	    //
	    for(int kPi0=0; kPi0<countRecoPi0; kPi0++) {
	      double px1 = recoPi0Px[kPi0];
	      double py1 = recoPi0Py[kPi0];
	      double pz1 = recoPi0Pz[kPi0];

	      double phi1 = atan2(py1, px1);
	      double theta1 = acos(pz1/sqrt(px1*px1 + py1*py1 + pz1*pz1));

	      float xpi01 = rECal*cos(phi1);
	      float ypi01 = rECal*sin(phi1);
	      float zpi01 = rECal/tan(theta1);

	      for(int jPi0=0; jPi0<countRecoPi0Last; jPi0++) {
		double px2 = recoPi0PxLast[jPi0];
		double py2 = recoPi0PyLast[jPi0];
		double pz2 = recoPi0PzLast[jPi0];

		double phi2 = atan2(py2, px2);
		double theta2 = acos(pz2/sqrt(px2*px2 + py2*py2 + pz2*pz2));

		float xpi02 = rECal*cos(phi2);
		float ypi02 = rECal*sin(phi2);
		float zpi02 = rECal/tan(theta2);
              
		float dSeparationSquared = (xpi02 - xpi01)*(xpi02- xpi01) +
		  (ypi02 - ypi01)*(ypi02- ypi01) +
		  (zpi02 - zpi01)*(zpi02- zpi01);
              
		float dSeparation = sqrt(dSeparationSquared);
              
		if(dSeparation < minimumSeparationPi0)
		  continue;

		double qLong = fabs(pz2 - pz1);
		if(qLong < maxQ)
		  mixedEventQLong->Fill(qLong);

		//
		// Calculate the kT direction (out) from the mean of pt1 + pt2
		//
		double ktx = (px1 + px2)/2.0;
		double kty = (py1 + py2)/2.0;
		double ktMag = sqrt(ktx*ktx + kty*kty);
		
		double qOut1 = (px1*ktx + py1*kty)/ktMag;
		double qOut2 = (px2*ktx + py2*kty)/ktMag;

		double qOut = fabs(qOut2 - qOut1);

		if(qOut < maxQ)
		  mixedEventQOut->Fill(fabs(qOut));

		//
		// Establish the parallel (side) unit vector perpendicular to kT
		//
		double parax = kty;
		double paray = -ktx;
		double paraMag = ktMag;  // same two components but in different Cartesian directions
		
		double qSide1 = (px1*parax + py1*paray)/paraMag;
		double qSide2 = (px2*parax + py2*paray)/paraMag;
		
		double qSide = (qSide2 - qSide1);

		if(qSide < maxQ)
		  mixedEventQSide->Fill(qSide);

	      } // inner loop over jPi0
	    } // outer loop over kPi0
	  } // check on countRecoPi0Last > 0
	  for(int kPi0=0; kPi0<countRecoPi0; kPi0++) {
	    recoPi0PxLast[kPi0] = recoPi0Px[kPi0];
	    recoPi0PyLast[kPi0] = recoPi0Py[kPi0];
	    recoPi0PzLast[kPi0] = recoPi0Pz[kPi0];
	  } //transfer to the last event buffers
	  countTotalRecoPi0Mass += countRecoPi0;
	  countRecoPi0Last = countRecoPi0;
	} // check for countRecoPi0 > 0 to do background event

      } // loop over entries

      c1->Divide(1,3);

      c1->cd(1);
      double sumForegroundQLong = 0.0;
      double sumBackgroundQLong = 0.0;
      for(int kBin=0; kBin<nqBins; kBin++) {
	if(sameEventQLong->GetBinCenter(kBin) > qStartNormalization) {
	  sumForegroundQLong += sameEventQLong->GetBinContent(kBin);
	  sumBackgroundQLong += mixedEventQLong->GetBinContent(kBin);
	}
      } // getting sums for normalization factor
      double normalizationFactorQLong = sumBackgroundQLong/sumForegroundQLong; 
      cout << "\n\n sumForegroundQLong " << sumForegroundQLong;
      cout << ", sumBackgroundQLong " << sumBackgroundQLong;
      cout << ",  normalizationFactorQLong " << normalizationFactorQLong;
      cout << endl;
      for(int kBin=0; kBin<nqBins; kBin++) {
	double foreground = sameEventQLong->GetBinContent(kBin);
	double background = mixedEventQLong->GetBinContent(kBin);
	if(background > 0.0) {
	  double ratio =  normalizationFactorQLong*foreground/background;
	  normalizedEventQLong->SetBinContent(kBin, ratio);
	  double error = 0.0;
	  if(foreground > 0.0) {
	    error = sqrt(1.0/foreground + 1.0/background);
	  }
	  normalizedEventQLong->SetBinError(kBin, ratio*error);

	  if(sameEventQLong->GetBinCenter(kBin) < 0.00) {
	    cout << "\n qLong: " << kBin << ") center " << sameEventQLong->GetBinCenter(kBin) << ", foreground " << foreground;
	    cout << ", background " << background << ", ratio " << ratio << ", error " << error;
	  }
	}
      } // loop over bins

      float maxHistQLong = normalizedEventQLong->GetMaximum();
      maxHistQLong *= 1.3;
      if(maxHistQLong < 2.0)
	maxHistQLong =  2.0;
      normalizedEventQLong->SetMaximum(maxHistQLong);
      normalizedEventQLong->SetMinimum(0.8);
      normalizedEventQLong->SetStats(0);
      normalizedEventQLong->SetMarkerStyle(20);
      normalizedEventQLong->SetMarkerColor(kRed);
      normalizedEventQLong->SetMarkerSize(0.9);
      normalizedEventQLong->Draw();

      TF1 *fitHBTQLong = new TF1("fitHBTQLong", gausCorrelation, 0.0, maxQ, 2);
      fitHBTQLong->SetParameter(0, 5.0);
      fitHBTQLong->SetParameter(1, 1.0);
      fitHBTQLong->SetParName(0, "R_L");
      fitHBTQLong->SetParName(1, "Lambda_L");
      fitHBTQLong->SetNpx(500);
      fitHBTQLong->SetLineColor(4);
      normalizedEventQLong->Fit("fitHBTQLong", "", "", 0.005, maxQ);

      double rLongFit = fabs(fitHBTQLong->GetParameter(0));
      double rLongFitError = fitHBTQLong->GetParError(0);
      char *rLongBuffer = new char[200];

      if(simRun)
	sprintf(rLongBuffer, "Fit R_{L} = %4.2f #pm %4.2f fm (HIJING simulation run)", rLongFit, rLongFitError);
      else
	sprintf(rLongBuffer, "Fit R_{L} = %4.2f #pm %4.2f fm (Data)", rLongFit, rLongFitError);

      if(simRunEPOS)
	sprintf(rLongBuffer, "Fit R_{L} = %4.2f #pm %4.2f fm (EPOS simulation run)", rLongFit, rLongFitError);

      TLatex *rLongText = new TLatex(0.075, 0.90*(maxHistQLong - 0.8) + 0.8, rLongBuffer);
      rLongText->SetTextColor(kBlue);
      rLongText->SetTextSize(0.08);
      rLongText->Draw();

      double lLongFit = fabs(fitHBTQLong->GetParameter(1));
      double lLongFitError = fitHBTQLong->GetParError(1);
      char *lLongBuffer = new char[200];
      sprintf(lLongBuffer, "Fit #lambda_{L} = %4.2f #pm %4.2f", lLongFit, lLongFitError);
      TLatex *lLongText = new TLatex(0.075, 0.70*(maxHistQLong - 0.8) + 0.8, lLongBuffer);
      lLongText->SetTextColor(kBlue);
      lLongText->SetTextSize(0.08);
      lLongText->Draw();

      char *piSizeBuffer = new char[200];
      sprintf(piSizeBuffer, "%d < N_{Tracks} < %d", lowMultiplicity, highMultiplicity);
      TLatex *piSizeText = new TLatex(0.26, 0.75*(maxHistQLong-0.8) + 0.8, piSizeBuffer);
      piSizeText->SetTextColor(kRed);
      piSizeText->SetTextSize(0.07);
      piSizeText->Draw();

      char *piPtCutBuffer = new char[200];
      sprintf(piPtCutBuffer, "%4.2f < p_{T}(#pi^{0}) < %4.2f GeV/c", lowPi0PtCut, highPi0PtCut);
      TLatex *piPtCutText = new TLatex(0.26, 0.60*(maxHistQLong-0.8) + 0.8, piPtCutBuffer);
      piPtCutText->SetTextColor(kRed);
      piPtCutText->SetTextSize(0.07);
      piPtCutText->Draw();

      char *piEtaCutBuffer = new char[200];
      sprintf(piEtaCutBuffer, "%4.2f < #eta(#pi^{0}) < %4.2f", etaLowLimit, etaHighLimit);
      TLatex *piEtaCutText = new TLatex(0.26, 0.45*(maxHistQLong-0.8) + 0.8, piEtaCutBuffer);
      piEtaCutText->SetTextColor(kRed);
      piEtaCutText->SetTextSize(0.07);
      piEtaCutText->Draw();

      (c1->cd(1))->SetGrid();

      c1->cd(2);
      double sumForegroundQOut = 0.0;
      double sumBackgroundQOut = 0.0;
      for(int kBin=0; kBin<nqBins; kBin++) {
	if(sameEventQOut->GetBinCenter(kBin) > qStartNormalization) {
	  sumForegroundQOut += sameEventQOut->GetBinContent(kBin);
	  sumBackgroundQOut += mixedEventQOut->GetBinContent(kBin);
	}
      } // getting sums for normalization factor
      double normalizationFactorQOut = sumBackgroundQOut/sumForegroundQOut; 
      cout << "\n\n sumForegroundQOut " << sumForegroundQOut;
      cout << ", sumBackgroundQOut " << sumBackgroundQOut;
      cout << ",  normalizationFactorQOut " << normalizationFactorQOut;
      cout << endl;
      for(int kBin=0; kBin<nqBins; kBin++) {
	double foreground = sameEventQOut->GetBinContent(kBin);
	double background = mixedEventQOut->GetBinContent(kBin);
	if(background > 0.0) {
	  double ratio =  normalizationFactorQOut*foreground/background;
	  normalizedEventQOut->SetBinContent(kBin, ratio);
	  double error = 0.0;
	  if(foreground > 0.0) {
	    error = sqrt(1.0/foreground + 1.0/background);
	  }
	  normalizedEventQOut->SetBinError(kBin, ratio*error);

	  if(sameEventQOut->GetBinCenter(kBin) < 0.00) {
	    cout << "\n qOut: " << kBin << ") center " << sameEventQOut->GetBinCenter(kBin) << ", foreground " << foreground;
	    cout << ", background " << background << ", ratio " << ratio << ", error " << error;
	  }
	}
      } // loop over bins

      float maxHistQOut = normalizedEventQOut->GetMaximum();
      maxHistQOut *= 1.3;
      if(maxHistQOut < 2.0)
	maxHistQOut =  2.0;
      normalizedEventQOut->SetMaximum(maxHistQOut);
      normalizedEventQOut->SetMinimum(0.8);
      normalizedEventQOut->SetStats(0);
      normalizedEventQOut->SetMarkerStyle(20);
      normalizedEventQOut->SetMarkerColor(kRed);
      normalizedEventQOut->SetMarkerSize(0.9);
      normalizedEventQOut->Draw();

      TF1 *fitHBTQOut = new TF1("fitHBTQOut", gausCorrelation, 0.0, maxQ, 2);
      fitHBTQOut->SetParameter(0, 5.0);
      fitHBTQOut->SetParameter(1, 1.0);
      fitHBTQOut->SetParName(0, "R_O");
      fitHBTQOut->SetParName(1, "Lambda_O");
      fitHBTQOut->SetNpx(500);
      fitHBTQOut->SetLineColor(4);
      normalizedEventQOut->Fit("fitHBTQOut", "", "", 0.005, maxQ);

      double rOutFit = fabs(fitHBTQOut->GetParameter(0));
      double rOutFitError = fitHBTQOut->GetParError(0);
      char *rOutBuffer = new char[200];

      if(simRun)
	sprintf(rOutBuffer, "Fit R_{O} = %4.2f #pm %4.2f fm (HIJING simulation run)", rOutFit, rOutFitError);
      else
	sprintf(rOutBuffer, "Fit R_{O} = %4.2f #pm %4.2f fm (Data)", rOutFit, rOutFitError);

      if(simRunEPOS)
	sprintf(rOutBuffer, "Fit R_{O} = %4.2f #pm %4.2f fm (EPOS simulation run)", rOutFit, rOutFitError);

      TLatex *rOutText = new TLatex(0.075, 0.90*(maxHistQOut - 0.8) + 0.8, rOutBuffer);
      rOutText->SetTextColor(kBlue);
      rOutText->SetTextSize(0.08);
      rOutText->Draw();

      double lOutFit = fabs(fitHBTQOut->GetParameter(1));
      double lOutFitError = fitHBTQOut->GetParError(1);
      char *lOutBuffer = new char[200];
      sprintf(lOutBuffer, "Fit #lambda_{O} = %4.2f #pm %4.2f", lOutFit, lOutFitError);
      TLatex *lOutText = new TLatex(0.075, 0.70*(maxHistQOut - 0.8) + 0.8, lOutBuffer);
      lOutText->SetTextColor(kBlue);
      lOutText->SetTextSize(0.08);
      lOutText->Draw();
      (c1->cd(2))->SetGrid();

      c1->cd(3);
      double sumForegroundQSide = 0.0;
      double sumBackgroundQSide = 0.0;
      for(int kBin=0; kBin<nqBins; kBin++) {
	if(sameEventQSide->GetBinCenter(kBin) > qStartNormalization) {
	  sumForegroundQSide += sameEventQSide->GetBinContent(kBin);
	  sumBackgroundQSide += mixedEventQSide->GetBinContent(kBin);
	}
      } // getting sums for normalization factor
      double normalizationFactorQSide = sumBackgroundQSide/sumForegroundQSide; 
      cout << "\n\n sumForegroundQSide " << sumForegroundQSide;
      cout << ", sumBackgroundQSide " << sumBackgroundQSide;
      cout << ",  normalizationFactorQSide " << normalizationFactorQSide;
      cout << endl;
      for(int kBin=0; kBin<nqBins; kBin++) {
	double foreground = sameEventQSide->GetBinContent(kBin);
	double background = mixedEventQSide->GetBinContent(kBin);
	if(background > 0.0) {
	  double ratio =  normalizationFactorQSide*foreground/background;
	  normalizedEventQSide->SetBinContent(kBin, ratio);
	  double error = 0.0;
	  if(foreground > 0.0) {
	    error = sqrt(1.0/foreground + 1.0/background);
	  }
	  normalizedEventQSide->SetBinError(kBin, ratio*error);

	  if(sameEventQSide->GetBinCenter(kBin) < 0.00) {
	    cout << "\n qSide: " << kBin << ") center " << sameEventQSide->GetBinCenter(kBin) << ", foreground " << foreground;
	    cout << ", background " << background << ", ratio " << ratio << ", error " << error;
	  }
	}
      } // loop over bins

      float maxHistQSide = normalizedEventQSide->GetMaximum();
      maxHistQSide *= 1.3;
      if(maxHistQSide < 2.0)
	maxHistQSide =  2.0;
      normalizedEventQSide->SetMaximum(maxHistQSide);
      normalizedEventQSide->SetMinimum(0.8);
      normalizedEventQSide->SetStats(0);
      normalizedEventQSide->SetMarkerStyle(20);
      normalizedEventQSide->SetMarkerColor(kRed);
      normalizedEventQSide->SetMarkerSize(0.9);
      normalizedEventQSide->Draw();

      TF1 *fitHBTQSide = new TF1("fitHBTQSide", gausCorrelation, 0.0, maxQ, 2);
      fitHBTQSide->SetParameter(0, 5.0);
      fitHBTQSide->SetParameter(1, 1.0);
      fitHBTQSide->SetParName(0, "R_S");
      fitHBTQSide->SetParName(1, "Lambda_S");
      fitHBTQSide->SetNpx(500);
      fitHBTQSide->SetLineColor(4);
      normalizedEventQSide->Fit("fitHBTQSide", "", "", 0.005, maxQ);

      double rSideFit = fabs(fitHBTQSide->GetParameter(0));
      double rSideFitError = fitHBTQSide->GetParError(0);
      char *rSideBuffer = new char[200];
      if(simRun)
	sprintf(rSideBuffer, "Fit R_{S} = %4.2f #pm %4.2f fm (HIJING simulation run)", rSideFit, rSideFitError);
      else
	sprintf(rSideBuffer, "Fit R_{S} = %4.2f #pm %4.2f fm (Data)", rSideFit, rSideFitError);

      if(simRunEPOS)
	sprintf(rSideBuffer, "Fit R_{S} = %4.2f #pm %4.2f fm (EPOS simulation run)", rSideFit, rSideFitError);

      TLatex *rSideText = new TLatex(0.075, 0.90*(maxHistQSide - 0.8) + 0.8, rSideBuffer);
      rSideText->SetTextColor(kBlue);
      rSideText->SetTextSize(0.08);
      rSideText->Draw();

      double lSideFit = fabs(fitHBTQSide->GetParameter(1));
      double lSideFitError = fitHBTQSide->GetParError(1);
      char *lSideBuffer = new char[200];
      sprintf(lSideBuffer, "Fit #lambda_{S} = %4.2f #pm %4.2f", lSideFit, lSideFitError);
      TLatex *lSideText = new TLatex(0.075, 0.70*(maxHistQSide - 0.8) + 0.8, lSideBuffer);
      lSideText->SetTextColor(kBlue);
      lSideText->SetTextSize(0.08);
      lSideText->Draw();
      (c1->cd(3))->SetGrid();

    } // option = 45, study of HBT pairs correlations
	
  } // iOption >= 10 for processing hTree
	
  if(iOption == 0 || iOption == 2) {
    c1->Divide(2,4);
		
    TFile *inputFile_2 = 0;
    if(iOption == 0) {
      inputFile_2 = new TFile(rootInputFile_2);
      if(!inputFile_2) {
	cerr << "\n Unable to find second input file " << rootInputFile_2 << endl;
	return;
      }
    }
		
    c1->cd(1);
    TH1D *p0MassHistSameEvent_1 = 0;
    p0MassHistSameEvent_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassHistSameEvent");
    if(!p0MassHistSameEvent_1) {
      cerr << "\n Unable to find p0MassHistSameEvent in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassHistSameEvent_1->SetStats(0);
    p0MassHistSameEvent_1->SetLineColor(2);
    if(iOption == 2)
      p0MassHistSameEvent_1->SetLineColor(4);
    (p0MassHistSameEvent_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassHistSameEvent_1->GetYaxis())->SetLabelSize(0.07);
    if(iOption == 2) {
      (p0MassHistSameEvent_1->GetXaxis())->SetTitleSize(0.09);
      (p0MassHistSameEvent_1->GetXaxis())->SetTitleOffset(-0.5);
      (p0MassHistSameEvent_1->GetXaxis())->CenterTitle();
      (p0MassHistSameEvent_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassHistSameEvent_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassHistSameEvent_1->GetYaxis())->CenterTitle();
    }
		
    p0MassHistSameEvent_1->Draw("");
		
    if(iOption == 0) {
      TH1D *p0MassHistSameEvent_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassHistSameEvent");
      if(!p0MassHistSameEvent_2) {
	cerr << "\n Unable to find p0MassHistSameEvent in first input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassHistSameEvent_2->SetStats(0);
      p0MassHistSameEvent_2->SetLineColor(kBlue);
      p0MassHistSameEvent_2->Draw("same");
    }
		
    TLine *pi0MassValue1 = new TLine(0.134976, 0.0, 0.134976, p0MassHistSameEvent_1->GetMaximum());
    pi0MassValue1->SetLineColor(kMagenta);
    pi0MassValue1->SetLineWidth(2);
    pi0MassValue1->Draw();
		
    TLine *etaMassValue1 = new TLine(0.5475, 0.0, 0.5475, p0MassHistSameEvent_1->GetMaximum());
    etaMassValue1->SetLineColor(kOrange);
    etaMassValue1->SetLineWidth(2);
    etaMassValue1->Draw();
		
    (c1->cd(1))->SetGridx();
    (c1->cd(1))->SetGridy();
		
    double maxHistogramValue = 1.30*p0MassHistSameEvent_1->GetMaximum();

    p0MassHistSameEvent_1->SetMaximum(maxHistogramValue);
    char *runLabelText = new char[200];
    if(simRun) {
			
      if(simRunV1)
	sprintf(runLabelText, "43K HIJING pPb Min Bias Events, v1 set");
			
      if(simRunV2)
	sprintf(runLabelText, "179K HIJING pPb Min Bias Events, v2 set");
			
    } // simRun
    else {
      if(ppRun) {
	sprintf(runLabelText, "Min Bias 2013 pp runs (0.08 fraction of data set)");
      }
      else {
	if(pPbRunNormal) {
	  sprintf(runLabelText, "First Min Bias 2013 pPb runs, 210676 - 211256");
	}
	if(pPbRunReverse) {
	  sprintf(runLabelText, "Reverse Min Bias 2013 pPb runs, 211313 - 211631");
	}
      } // not a ppRun and not a simRun
    } // not a simRun
    TLatex *runLabel = new TLatex(0.075, 0.87*maxHistogramValue, runLabelText);
    runLabel->SetTextColor(kBlack);
    runLabel->SetTextSize(0.08);
    runLabel->Draw();
		
    if(iOption != 2) {
      TLatex *etaLabel_1 = new TLatex(0.152, 0.70*maxHistogramValue, "Cluster |#eta| < 1.49");
      etaLabel_1->SetTextColor(kRed);
      etaLabel_1->SetTextSize(0.07);
      etaLabel_1->Draw();
    }
		
    float yFactor = 0.60;
    if(iOption == 2)
      yFactor = 0.75;
    
    TLatex *etaLabel_2 = 0;
    if(!simRun && iOption == 2 && !ppRun)
      etaLabel_2 = new TLatex(0.152, yFactor*maxHistogramValue, "Cluster |#eta| < 1.30");
		
    if(simRunV1 || simRunV2)
      etaLabel_2 = new TLatex(0.152, yFactor*maxHistogramValue, "Cluster |#eta| < 1.49");
		
    if(ppRun || pPbRunNormal || pPbRunReverse) {
      char *etaLabelText = new char[200];
      sprintf(etaLabelText, "Cluster %3.2f <=|#eta|<= %3.2f", etaLowLimit, etaHighLimit);
      etaLabel_2 = new TLatex(0.152, yFactor*maxHistogramValue, etaLabelText);
    }
    etaLabel_2->SetTextColor(kBlue);
    etaLabel_2->SetTextSize(0.07);
    etaLabel_2->Draw();
				
    TLatex *trackSuppression = 0;
    if(useTrackMatchSuppression) {
      trackSuppression = new TLatex(0.152, 0.66*maxHistogramValue, "Using track-matched suppression");
    }
    else {
      trackSuppression = new TLatex(0.152, 0.66*maxHistogramValue, "No track-matched suppression");
    }
    trackSuppression->SetTextColor(kBlue);
    trackSuppression->SetTextSize(0.07);
    trackSuppression->Draw();
		
    c1->cd(2);
    TH1D *p0MassSameEventPtBin0_1 = 0;
    p0MassSameEventPtBin0_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin0");
    if(!p0MassSameEventPtBin0_1) {
      cerr << "\n Unable to find p0MassSameEventPtBin0 in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassSameEventPtBin0_1->SetStats(0);
    p0MassSameEventPtBin0_1->SetLineColor(2);
    if(iOption == 2)
      p0MassSameEventPtBin0_1->SetLineColor(4);
    p0MassSameEventPtBin0_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin0_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (p0MassSameEventPtBin0_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassSameEventPtBin0_1->GetYaxis())->SetLabelSize(0.07);
    if(iOption == 2) {
      (p0MassSameEventPtBin0_1->GetXaxis())->SetTitleSize(0.09);
      (p0MassSameEventPtBin0_1->GetXaxis())->SetTitleOffset(-0.5);
      (p0MassSameEventPtBin0_1->GetXaxis())->CenterTitle();
      (p0MassSameEventPtBin0_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassSameEventPtBin0_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassSameEventPtBin0_1->GetYaxis())->CenterTitle();
    }
		
    p0MassSameEventPtBin0_1->Draw("");
		
    TH1D *p0MassSameEventPtBin0_2 = 0;
    if(iOption == 0) {
      p0MassSameEventPtBin0_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin0");
      if(!p0MassSameEventPtBin0_2) {
	cerr << "\n Unable to find p0MassSameEventPtBin0 in second input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassSameEventPtBin0_2->SetStats(0);
      p0MassSameEventPtBin0_2->SetLineColor(kBlue);
      p0MassSameEventPtBin0_2->Draw("same");
    }
		
    TLine *pi0MassValue2 = new TLine(0.134976, 0.0, 0.134976, p0MassSameEventPtBin0_1->GetMaximum());
    pi0MassValue2->SetLineColor(kMagenta);
    pi0MassValue2->SetLineWidth(2);
    pi0MassValue2->Draw();
		
    TLine *etaMassValue2 = new TLine(0.5475, 0.0, 0.5475, p0MassSameEventPtBin0_1->GetMaximum());
    etaMassValue2->SetLineColor(kOrange);
    etaMassValue2->SetLineWidth(2);
    etaMassValue2->Draw();
		
    (c1->cd(2))->SetGridx();
    (c1->cd(2))->SetGridy();
		
    c1->cd(3);
    TH1D *p0MassSameEventPtBin1_1 = 0;
    p0MassSameEventPtBin1_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin1");
    if(!p0MassSameEventPtBin1_1) {
      cerr << "\n Unable to find p0MassSameEventPtBin1 in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassSameEventPtBin1_1->SetStats(0);
    p0MassSameEventPtBin1_1->SetLineColor(2);
		
    p0MassSameEventPtBin1_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin1_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
		
    p0MassSameEventPtBin1_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin1_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (p0MassSameEventPtBin1_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassSameEventPtBin1_1->GetYaxis())->SetLabelSize(0.07);
		
    if(iOption == 2) {
      p0MassSameEventPtBin1_1->SetLineColor(4);
      (p0MassSameEventPtBin1_1->GetXaxis())->SetTitleSize(0.09);
      (p0MassSameEventPtBin1_1->GetXaxis())->SetTitleOffset(-0.5);
      (p0MassSameEventPtBin1_1->GetXaxis())->CenterTitle();
      (p0MassSameEventPtBin1_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassSameEventPtBin1_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassSameEventPtBin1_1->GetYaxis())->CenterTitle();
    }
		
    p0MassSameEventPtBin1_1->Draw("");
		
    if(iOption == 0) {
      TH1D *p0MassSameEventPtBin1_2 = 0;
      p0MassSameEventPtBin1_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin1");
      if(!p0MassSameEventPtBin1_2) {
	cerr << "\n Unable to find p0MassSameEventPtBin1 in second input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassSameEventPtBin1_2->SetStats(0);
      p0MassSameEventPtBin1_2->SetLineColor(kBlue);
      p0MassSameEventPtBin1_2->Draw("same");
    }
		
    TLine *pi0MassValue3 = new TLine(0.134976, 0.0, 0.134976, p0MassSameEventPtBin1_1->GetMaximum());
    pi0MassValue3->SetLineColor(kMagenta);
    pi0MassValue3->SetLineWidth(2);
    pi0MassValue3->Draw();
		
    TLine *etaMassValue3 = new TLine(0.5475, 0.0, 0.5475, p0MassSameEventPtBin1_1->GetMaximum());
    etaMassValue3->SetLineColor(kOrange);
    etaMassValue3->SetLineWidth(2);
    etaMassValue3->Draw();
		
    (c1->cd(3))->SetGridx();
    (c1->cd(3))->SetGridy();
		
    c1->cd(4);
    TH1D *p0MassSameEventPtBin2_1 = 0;
    p0MassSameEventPtBin2_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin2");
    if(!p0MassSameEventPtBin2_1) {
      cerr << "\n Unable to find p0MassSameEventPtBin2 in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassSameEventPtBin2_1->SetStats(0);
    p0MassSameEventPtBin2_1->SetLineColor(2);
		
    p0MassSameEventPtBin2_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin2_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
		
    p0MassSameEventPtBin2_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin2_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (p0MassSameEventPtBin2_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassSameEventPtBin2_1->GetYaxis())->SetLabelSize(0.07);
		
    if(iOption == 2) {
      p0MassSameEventPtBin2_1->SetLineColor(4);
      (p0MassSameEventPtBin2_1->GetXaxis())->SetTitleSize(0.09);
      (p0MassSameEventPtBin2_1->GetXaxis())->SetTitleOffset(-0.5);
      (p0MassSameEventPtBin2_1->GetXaxis())->CenterTitle();
      (p0MassSameEventPtBin2_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassSameEventPtBin2_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassSameEventPtBin2_1->GetYaxis())->CenterTitle();
    }
		
    p0MassSameEventPtBin2_1->Draw("");
		
    if(iOption == 0) {
      TH1D *p0MassSameEventPtBin2_2 = 0;
      p0MassSameEventPtBin2_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin2");
      if(!p0MassSameEventPtBin2_2) {
	cerr << "\n Unable to find p0MassSameEventPtBin2 in second input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassSameEventPtBin2_2->SetStats(0);
      p0MassSameEventPtBin2_2->SetLineColor(kBlue);
      p0MassSameEventPtBin2_2->Draw("same");
    }
		
    TLine *pi0MassValue4 = new TLine(0.134976, 0.0, 0.134976, p0MassSameEventPtBin2_1->GetMaximum());
    pi0MassValue4->SetLineColor(kMagenta);
    pi0MassValue4->SetLineWidth(2);
    pi0MassValue4->Draw();
		
    TLine *etaMassValue4 = new TLine(0.5475, 0.0, 0.5475, p0MassSameEventPtBin2_1->GetMaximum());
    etaMassValue4->SetLineColor(kOrange);
    etaMassValue4->SetLineWidth(2);
    etaMassValue4->Draw();		
		
    (c1->cd(4))->SetGridx();
    (c1->cd(4))->SetGridy();
		
    c1->cd(5);
    TH1D *p0MassSameEventPtBin3_1 = 0;
    p0MassSameEventPtBin3_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin3");
    if(!p0MassSameEventPtBin3_1) {
      cerr << "\n Unable to find p0MassSameEventPtBin3 in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassSameEventPtBin3_1->SetStats(0);
    p0MassSameEventPtBin3_1->SetLineColor(2);
    p0MassSameEventPtBin3_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin3_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
		
    p0MassSameEventPtBin3_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (p0MassSameEventPtBin3_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassSameEventPtBin3_1->GetYaxis())->SetLabelSize(0.07);
		
    if(iOption == 2) {
      p0MassSameEventPtBin3_1->SetLineColor(4);
      (p0MassSameEventPtBin3_1->GetXaxis())->SetTitleSize(0.09);
      (p0MassSameEventPtBin3_1->GetXaxis())->SetTitleOffset(-0.5);
      (p0MassSameEventPtBin3_1->GetXaxis())->CenterTitle();
      (p0MassSameEventPtBin3_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassSameEventPtBin3_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassSameEventPtBin3_1->GetYaxis())->CenterTitle();
    }

    p0MassSameEventPtBin3_1->Draw("");
		
    if(iOption == 0) {
      TH1D *p0MassSameEventPtBin3_2 = 0;
      p0MassSameEventPtBin3_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin3");
      if(!p0MassSameEventPtBin3_2) {
	cerr << "\n Unable to find p0MassSameEventPtBin3 in second input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassSameEventPtBin3_2->SetStats(0);
      p0MassSameEventPtBin3_2->SetLineColor(kBlue);
      p0MassSameEventPtBin3_2->Draw("same");
    }
		
    TLine *pi0MassValue5 = new TLine(0.134976, 0.0, 0.134976, p0MassSameEventPtBin3_1->GetMaximum());
    pi0MassValue5->SetLineColor(kMagenta);
    pi0MassValue5->SetLineWidth(2);
    pi0MassValue5->Draw();
		
    TLine *etaMassValue5 = new TLine(0.5475, 0.0, 0.5475, p0MassSameEventPtBin3_1->GetMaximum());
    etaMassValue5->SetLineColor(kOrange);
    etaMassValue5->SetLineWidth(2);
    etaMassValue5->Draw();
		
    (c1->cd(5))->SetGridx();
    (c1->cd(5))->SetGridy();
		
    c1->cd(6);
    TH1D *p0MassSameEventPtBin4_1 = 0;
    p0MassSameEventPtBin4_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin4");
    if(!p0MassSameEventPtBin4_1) {
      cerr << "\n Unable to find p0MassSameEventPtBin4 in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassSameEventPtBin4_1->SetStats(0);
    p0MassSameEventPtBin4_1->SetLineColor(2);
    p0MassSameEventPtBin4_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin4_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
		
    p0MassSameEventPtBin4_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (p0MassSameEventPtBin4_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassSameEventPtBin4_1->GetYaxis())->SetLabelSize(0.07);
		
    if(iOption == 2) {
      p0MassSameEventPtBin4_1->SetLineColor(4);
      (p0MassSameEventPtBin4_1->GetXaxis())->SetTitleSize(0.09);
      (p0MassSameEventPtBin4_1->GetXaxis())->SetTitleOffset(-0.5);
      (p0MassSameEventPtBin4_1->GetXaxis())->CenterTitle();
      (p0MassSameEventPtBin4_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassSameEventPtBin4_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassSameEventPtBin4_1->GetYaxis())->CenterTitle();
    }
		
    p0MassSameEventPtBin4_1->Draw("");
		
    if(iOption == 0) {
      TH1D *p0MassSameEventPtBin4_2 = 0;
      p0MassSameEventPtBin4_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin4");
      if(!p0MassSameEventPtBin4_2) {
	cerr << "\n Unable to find p0MassSameEventPtBin4 in second input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassSameEventPtBin4_2->SetStats(0);
      p0MassSameEventPtBin4_2->SetLineColor(kBlue);
      p0MassSameEventPtBin4_2->Draw("same");
    }
		
    TLine *pi0MassValue6 = new TLine(0.134976, 0.0, 0.134976, p0MassSameEventPtBin4_1->GetMaximum());
    pi0MassValue6->SetLineColor(kMagenta);
    pi0MassValue6->SetLineWidth(2);
    pi0MassValue6->Draw();
		
    TLine *etaMassValue6 = new TLine(0.5475, 0.0, 0.5475, p0MassSameEventPtBin4_1->GetMaximum());
    etaMassValue6->SetLineColor(kOrange);
    etaMassValue6->SetLineWidth(2);
    etaMassValue6->Draw();
		
    (c1->cd(6))->SetGridx();
    (c1->cd(6))->SetGridy();
		
    c1->cd(7);
    TH1D *p0MassSameEventPtBin5_1 = 0;
    p0MassSameEventPtBin5_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin5");
    if(!p0MassSameEventPtBin5_1) {
      cerr << "\n Unable to find p0MassSameEventPtBin5 in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassSameEventPtBin5_1->SetStats(0);
    p0MassSameEventPtBin5_1->SetLineColor(2);
    p0MassSameEventPtBin5_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin5_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
		
    p0MassSameEventPtBin5_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin5_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (p0MassSameEventPtBin5_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassSameEventPtBin5_1->GetYaxis())->SetLabelSize(0.07);
		
    if(iOption == 2) {
      p0MassSameEventPtBin5_1->SetLineColor(4);
      (p0MassSameEventPtBin5_1->GetXaxis())->SetTitleSize(0.06);
      (p0MassSameEventPtBin5_1->GetXaxis())->SetTitleOffset(-0.4);
      (p0MassSameEventPtBin5_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassSameEventPtBin5_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassSameEventPtBin5_1->GetYaxis())->CenterTitle();
    }
		
    p0MassSameEventPtBin5_1->Draw("");
		
    if(iOption == 0) {
      TH1D *p0MassSameEventPtBin5_2 = 0;
      p0MassSameEventPtBin5_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin5");
      if(!p0MassSameEventPtBin5_2) {
	cerr << "\n Unable to find p0MassSameEventPtBin5 in second input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassSameEventPtBin5_2->SetStats(0);
      p0MassSameEventPtBin5_2->SetLineColor(kBlue);
      p0MassSameEventPtBin5_2->Draw("same");
    }
		
    TLine *pi0MassValue7 = new TLine(0.134976, 0.0, 0.134976, p0MassSameEventPtBin5_1->GetMaximum());
    pi0MassValue7->SetLineColor(kMagenta);
    pi0MassValue7->SetLineWidth(2);
    pi0MassValue7->Draw();
		
    TLine *etaMassValue7 = new TLine(0.5475, 0.0, 0.5475, p0MassSameEventPtBin5_1->GetMaximum());
    etaMassValue7->SetLineColor(kOrange);
    etaMassValue7->SetLineWidth(2);
    etaMassValue7->Draw();
		
    (c1->cd(7))->SetGridx();
    (c1->cd(7))->SetGridy();
		
    c1->cd(8);
    TH1D *p0MassSameEventPtBin6_1 = 0;
    p0MassSameEventPtBin6_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin6");
    if(!p0MassSameEventPtBin6_1) {
      cerr << "\n Unable to find p0MassSameEventPtBin6 in first input file " << rootInputFile_1 << endl;
      return;
    }
    p0MassSameEventPtBin6_1->SetStats(0);
    p0MassSameEventPtBin6_1->SetLineColor(2);
    p0MassSameEventPtBin6_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin6_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
		
    p0MassSameEventPtBin6_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassSameEventPtBin6_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (p0MassSameEventPtBin6_1->GetXaxis())->SetLabelSize(0.1);
    (p0MassSameEventPtBin6_1->GetYaxis())->SetLabelSize(0.07);
		
    if(iOption == 2) {
      p0MassSameEventPtBin6_1->SetLineColor(4);
      (p0MassSameEventPtBin6_1->GetXaxis())->SetTitleSize(0.06);
      (p0MassSameEventPtBin6_1->GetXaxis())->SetTitleOffset(-0.3);
      (p0MassSameEventPtBin6_1->GetYaxis())->SetTitleSize(0.07);
      (p0MassSameEventPtBin6_1->GetYaxis())->SetTitleOffset(0.6);
      (p0MassSameEventPtBin6_1->GetYaxis())->CenterTitle();
    }
		
    p0MassSameEventPtBin6_1->Draw("");
		
    if(iOption == 0) {
      TH1D *p0MassSameEventPtBin6_2 = 0;
      p0MassSameEventPtBin6_2 = (TH1D*)inputFile_2->Get("EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin6");
      if(!p0MassSameEventPtBin6_2) {
	cerr << "\n Unable to find p0MassSameEventPtBin6 in second input file " << rootInputFile_2 << endl;
	return;
      }
      p0MassSameEventPtBin6_2->SetStats(0);
      p0MassSameEventPtBin6_2->SetLineColor(kBlue);
      p0MassSameEventPtBin6_2->Draw("same");
    }
		
    TLine *pi0MassValue8 = new TLine(0.134976, 0.0, 0.134976, p0MassSameEventPtBin6_1->GetMaximum());
    pi0MassValue8->SetLineColor(kMagenta);
    pi0MassValue8->SetLineWidth(2);
    pi0MassValue8->Draw();
		
    TLine *etaMassValue8 = new TLine(0.5475, 0.0, 0.5475, p0MassSameEventPtBin6_1->GetMaximum());
    etaMassValue8->SetLineColor(kOrange);
    etaMassValue8->SetLineWidth(2);
    etaMassValue8->Draw();
		
    (c1->cd(8))->SetGridx();
    (c1->cd(8))->SetGridy();
		
		
  } // iOption = 0 or iOption = 2
	
  if(iOption == 1) {
		
    TH1D *p0MassHistSameEvent_1 = 0;
    p0MassHistSameEvent_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassHistSameEvent");
    if(!p0MassHistSameEvent_1) {
      cerr << "\n Unable to find p0MassHistSameEvent in first input file " << rootInputFile_1 << endl;
      return;
    }
		
    TH1D *p0MassHistMixed_1 = 0;
    p0MassHistMixed_1 = (TH1D*)inputFile_1->Get("EcalFlowNtp/NeutralPions/pi0MassHistMixed");
    if(!p0MassHistMixed_1) {
      cerr << "\n Unable to find p0MassHistMixed in first input file " << rootInputFile_1 << endl;
      return;
    }
		
    TLine *baseLine = new TLine(0.0, 0.0, highMass, 0.0);
    baseLine->SetLineColor(kBlack);
    baseLine->SetLineWidth(2);
		
    int dataMarkerColor = 2;
    c1->Divide(2,4);
		
    c1->cd(1);
    TH1D *pi0MassHistSameSubtracted = new TH1D("pi0MassHistSameSubtracted", "Background subtracted #pi^{0}", 75, 0.0, 0.30);
    pi0MassHistSameSubtracted->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    pi0MassHistSameSubtracted->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
		
    double sumBackground = 0.0;
    double sumForeground = 0.0;
    for(unsigned int kBin=0; kBin<75; kBin++) {
      double massValue = p0MassHistSameEvent_1->GetBinCenter(kBin);
      if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	sumForeground += p0MassHistSameEvent_1->GetBinContent(kBin);
	sumBackground += p0MassHistMixed_1->GetBinContent(kBin);
      } // check on mass value of the bin
			
      if(massValue >= highMassBackground)
	break;
			
    } // sum over all mass bins
		
    double normFactorInclusive = 0;
    if(sumBackground > 0) {
      normFactorInclusive = sumForeground/sumBackground;
    }
    cout << "\n Inclusive normalization factor = " << normFactorInclusive << endl;
		
    for(unsigned int kBin=0; kBin<=75; kBin++) {
      double countForeground = p0MassHistSameEvent_1->GetBinContent(kBin);
      double countBackground = p0MassHistMixed_1->GetBinContent(kBin);
      pi0MassHistSameSubtracted->SetBinContent(kBin, countForeground - normFactorInclusive*countBackground);
      double countError = sqrt(countForeground + countBackground*normFactorInclusive*normFactorInclusive);
      pi0MassHistSameSubtracted->SetBinError(kBin, countError);
    }
		
    pi0MassHistSameSubtracted->SetMarkerStyle(20);
    pi0MassHistSameSubtracted->SetMarkerColor(dataMarkerColor);
    pi0MassHistSameSubtracted->SetMarkerSize(0.5);
    pi0MassHistSameSubtracted->SetStats(0);
		
    pi0MassHistSameSubtracted->Draw();
    baseLine->Draw();
    
    (c1->cd(1))->SetGridx();
    (c1->cd(1))->SetGridy();
		
    double maxHistogramValue = pi0MassHistSameSubtracted->GetMaximum();
    TLatex *runLabel = 0;
    if(ppRun) {
      runLabel = new TLatex(0.152, 0.90*maxHistogramValue, "2013 pp runs (8% of data set)");
    }
    else {
      runLabel = new TLatex(0.152, 0.90*maxHistogramValue, "2013 pPb runs");
    }
    runLabel->SetTextColor(kBlack);
    runLabel->SetTextSize(0.08);
    runLabel->Draw();
		
    char *etaString = new char[200];
    sprintf(etaString, "Cluster %4.2f <= |#eta| <= %4.2f", etaLowLimit, etaHighLimit);
    TLatex *etaLabel_1 = new TLatex(0.152, 0.75*maxHistogramValue, etaString);
    etaLabel_1->SetTextColor(dataMarkerColor);
    etaLabel_1->SetTextSize(0.07);
    etaLabel_1->Draw();
		
    TLatex *normFactorLabel1 = new TLatex(0.152, 0.60*maxHistogramValue, "Mixed-event normalization");
    normFactorLabel1->SetTextColor(dataMarkerColor);
    normFactorLabel1->SetTextSize(0.07);
    normFactorLabel1->Draw();
		
    char *normFactorString2 = new char[200];
    sprintf(normFactorString2, "from %4.3f to %4.3f GeV/c^{2}", lowMassBackground, highMassBackground);
    TLatex *normFactorLabel2 = new TLatex(0.152, 0.50*maxHistogramValue, normFactorString2);
    normFactorLabel2->SetTextColor(dataMarkerColor);
    normFactorLabel2->SetTextSize(0.07);
    normFactorLabel2->Draw();
		
    TLine *pi0MassValue = new TLine(0.134976, 0.0, 0.134976, pi0MassHistSameSubtracted->GetMaximum());
    pi0MassValue->SetLineColor(kMagenta);
    pi0MassValue->SetLineWidth(2);
    pi0MassValue->Draw();
		
    TLine *pi0MassValuePtBin[7];
		
    TH1D *pi0MassSubtractedPtBin[7];
    char *histogramName = new char[200];
    char *histogramTitle = new char[200];
    float pTLowLimit[7] =  {1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0};
    float pTHighLimit[7] = {1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0};
    for(unsigned int kPt=0; kPt<7; kPt++) {
      sprintf(histogramName, "pi0MassSubtractedPtBin%d", kPt);
      sprintf(histogramTitle, "#pi^{0} for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[kPt], pTHighLimit[kPt]);
      pi0MassSubtractedPtBin[kPt] = new TH1D(histogramName, histogramTitle, 75, 0.0, 0.30);
      pi0MassSubtractedPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      pi0MassSubtractedPtBin[kPt]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
      pi0MassSubtractedPtBin[kPt]->SetMarkerStyle(20);
      pi0MassSubtractedPtBin[kPt]->SetMarkerColor(dataMarkerColor);
      pi0MassSubtractedPtBin[kPt]->SetMarkerSize(0.5);
      pi0MassSubtractedPtBin[kPt]->SetStats(0);
    }
		
    TH1D *pi0MassSameEventPtBin[7];
    TH1D *pi0MassMixedEventPtBin[7];
    for(unsigned int kPt=0; kPt<7; kPt++) {
      sprintf(histogramName, "EcalFlowNtp/NeutralPions/pi0MassSameEventPtBin%d", kPt);
      pi0MassSameEventPtBin[kPt] = (TH1D*)inputFile_1->Get(histogramName);
      if(!pi0MassSameEventPtBin[kPt]) {
	cerr << "\n Unable to find foreground " << histogramName << " in first input file " << rootInputFile_1 << endl;
	return;
      }
      sprintf(histogramName, "EcalFlowNtp/NeutralPions/pi0MassMixedEventPtBin%d", kPt);
      pi0MassMixedEventPtBin[kPt] = (TH1D*)inputFile_1->Get(histogramName);
      if(!pi0MassMixedEventPtBin[kPt]) {
	cerr << "\n Unable to find background " << histogramName << " in first input file " << rootInputFile_1 << endl;
	return;
      }
			
    } // loop over pT bins
		
    for(unsigned int kPanel=2; kPanel<=8; kPanel++) {
      c1->cd(kPanel);
      unsigned int kPt = kPanel - 2;
			
      sumBackground = 0.0;
      sumForeground = 0.0;
      for(unsigned int kBin=0; kBin<75; kBin++) {
	double massValue = pi0MassSameEventPtBin[kPt]->GetBinCenter(kBin);
	if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	  sumForeground += pi0MassSameEventPtBin[kPt]->GetBinContent(kBin);
	  sumBackground += pi0MassMixedEventPtBin[kPt]->GetBinContent(kBin);
	} // check on mass value of the bin
				
	if(massValue >= highMassBackground)
	  break;
				
      } // sum over all mass bins
			
      double normFactorPtBin = 0;
      if(sumBackground > 0) {
	normFactorPtBin = sumForeground/sumBackground;
      }
      cout << "\n Normalization factor for pT from " << pTLowLimit[kPt];
      cout << " to " << pTHighLimit[kPt]  << " GeV/c = " << normFactorPtBin;
			
      for(unsigned int kBin=0; kBin<=75; kBin++) {
	double countForeground = pi0MassSameEventPtBin[kPt]->GetBinContent(kBin);
	double countBackground = pi0MassMixedEventPtBin[kPt]->GetBinContent(kBin);
	pi0MassSubtractedPtBin[kPt]->SetBinContent(kBin, countForeground - normFactorPtBin*countBackground);
	double countError = sqrt(countForeground + countBackground*normFactorPtBin*normFactorPtBin);
	pi0MassSubtractedPtBin[kPt]->SetBinError(kBin, countError);
      }

      pi0MassSubtractedPtBin[kPt]->Fit("gaus", "", "", 0.06, 0.17);
      TF1 *fit =  pi0MassSubtractedPtBin[kPt]->GetFunction("gaus");
      float centroid = fit->GetParameter(1);
      float width = fabs(fit->GetParameter(2));
      cout << "\n  Centroid = " << centroid;
      cout << ",  Width = " << width;
      double signalSum = 0.0;
      double signalError = 0.0;
      double centroidMinusTwoSigma = centroid - 2.0*width;
      double centroidPlusTwoSigma = centroid + 2.0*width;
      for(unsigned int kBin=0; kBin<=75; kBin++) {
	double massValue = pi0MassSubtractedPtBin[kPt]->GetBinCenter(kBin);
	if(massValue >= centroidMinusTwoSigma && massValue <= centroidPlusTwoSigma) {
	  signalSum += pi0MassSubtractedPtBin[kPt]->GetBinContent(kBin);
	  double error = pi0MassSubtractedPtBin[kPt]->GetBinError(kBin);
	  signalError += error*error;
	}
      }
      cout << "\n Signal yield = " << int(signalSum) << " +/- " << int(sqrt(signalError));
      cout << endl;
			
      pi0MassSubtractedPtBin[kPt]->Draw();
      baseLine->Draw();
			
      pi0MassValuePtBin[kPt] = new TLine(0.134976, 0.0, 0.134976, pi0MassSubtractedPtBin[kPt]->GetMaximum());
      pi0MassValuePtBin[kPt]->SetLineColor(kMagenta);
      pi0MassValuePtBin[kPt]->SetLineWidth(2);
      pi0MassValuePtBin[kPt]->Draw();

      double maxHistogramValue2 = pi0MassSubtractedPtBin[kPt]->GetMaximum();

      char *peakLabel = new char[200];
      sprintf(peakLabel, "Fit: centroid = %5.3f, #sigma = %5.3f", centroid, width);
      TLatex *peakText = new TLatex(0.17, 0.6*maxHistogramValue2, peakLabel);
      peakText->SetTextColor(kBlue);
      peakText->SetTextSize(0.065);
      peakText->Draw();

      char *yieldLabel = new char[200];
      sprintf(yieldLabel, "Signal sum = %d #pm %d", int(signalSum), int(sqrt(signalError)));
      TLatex *yieldText = new TLatex(0.17, 0.4*maxHistogramValue2, yieldLabel);
      yieldText->SetTextColor(kBlue);
      yieldText->SetTextSize(0.065);
      yieldText->Draw();
			
      (c1->cd(kPanel))->SetGridx();
      (c1->cd(kPanel))->SetGridy();
			
    } // loop over panels in figure
		
    return;
		
  } // iOption = 1
	
  if(iOption == 3 || iOption == 4 || iOption == 5) { // eta-meson mass plots
    if(iOption == 5)
      c1->Divide(2,2);
    else
      c1->Divide(2,4);
		
    char *ecalHeaderName = new char[200];
    if(multiplicityBin == -1) {
      sprintf(ecalHeaderName, "EcalFlowNtp/");
    }
    if(multiplicityBin == 0) {
      sprintf(ecalHeaderName, "EcalFlowNtpMult100/");
    }
    if(multiplicityBin == 1) {
      sprintf(ecalHeaderName, "EcalFlowNtpMult130/");
    }
    if(multiplicityBin == 2) {
      sprintf(ecalHeaderName, "EcalFlowNtpMult160/");
    }
    if(multiplicityBin == 3) {
      sprintf(ecalHeaderName, "EcalFlowNtpMult190/");
    }
		
    char *p0MassHistSameEventName = new char[200];
    char *p0MassHistMixedName = new char[200];
    sprintf(p0MassHistSameEventName, "NeutralPions/pi0MassHistSameEvent");
    sprintf(p0MassHistMixedName, "NeutralPions/pi0MassHistMixed");			
		
    char *p0MassHistSameEventFullName = new char[200];
    char *p0MassHistMixedFullName = new char[200];
    strcpy(p0MassHistSameEventFullName, ecalHeaderName);
    strcat(p0MassHistSameEventFullName, p0MassHistSameEventName);
    strcpy(p0MassHistMixedFullName, ecalHeaderName);
    strcat(p0MassHistMixedFullName, p0MassHistMixedName);
		
    TH1D *p0MassHistSameEvent_1 = 0;
    p0MassHistSameEvent_1 = (TH1D*)inputFile_1->Get(p0MassHistSameEventFullName);
    if(!p0MassHistSameEvent_1) {
      cerr << "\n Unable to find histogram " << p0MassHistSameEventFullName << " in first input file " << rootInputFile_1 << endl;
      return;
    }
		
    TH1D *p0MassHistMixed_1 = 0;
    p0MassHistMixed_1 = (TH1D*)inputFile_1->Get(p0MassHistMixedFullName);
    if(!p0MassHistMixed_1) {
      cerr << "\n Unable to find histogram " << p0MassHistMixedFullName << " in first input file " << rootInputFile_1 << endl;
      return;
    }
		
    TH1D *p0MassHistSameEventResum_1 = 0;
    TH1D *p0MassHistMixedEventResum_1 = 0;
    double sumForeground = 0;
    double sumBackground = 0;
    if(resumMassPlots) {
      p0MassHistSameEventResum_1 = new TH1D("p0MassHistSameEventResum_1", "Inclusive Mass Plot", 100, 0.0, 0.80);
      p0MassHistSameEventResum_1->SetYTitle("Counts per 8 MeV/c^{2} mass bin");
      p0MassHistMixedEventResum_1 = new TH1D("p0MassHistMixedEventResum_1", "Inclusive Mass Plot, Mixed Events", 100, 0.0, 0.80);
      p0MassHistMixedEventResum_1->SetYTitle("Counts per 8 MeV/c^{2} mass bin");
      unsigned int jBin = 0;
      for(unsigned int kBin=1; kBin<=199; kBin=kBin+2) {
	double massValue = p0MassHistSameEvent_1->GetBinCenter(kBin);
	if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	  sumForeground += p0MassHistSameEvent_1->GetBinContent(kBin);
	  sumBackground += p0MassHistMixed_1->GetBinContent(kBin);
	} // check on mass value of the bin
	massValue = p0MassHistSameEvent_1->GetBinCenter(kBin+1);
	if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	  sumForeground += p0MassHistSameEvent_1->GetBinContent(kBin+1);
	  sumBackground += p0MassHistMixed_1->GetBinContent(kBin+1);
	} // check on mass value of the bin
	jBin++;
	double count = p0MassHistSameEvent_1->GetBinContent(kBin) + p0MassHistSameEvent_1->GetBinContent(kBin+1);
	p0MassHistSameEventResum_1->SetBinContent(jBin, count);
	if(count > 0) {
	  p0MassHistSameEventResum_1->SetBinError(jBin, sqrt(count));
	}
	else {
	  p0MassHistSameEventResum_1->SetBinError(kBin/2, 0.0);
	}
	count = p0MassHistMixed_1->GetBinContent(kBin) + p0MassHistMixed_1->GetBinContent(kBin+1);
	p0MassHistMixedEventResum_1->SetBinContent(jBin, count);
	if(count > 0) {
	  p0MassHistMixedEventResum_1->SetBinError(jBin, sqrt(count));
	}
	else {
	  p0MassHistSameEventResum_1->SetBinError(kBin/2, 0.0);
	}
      }
    }
    else {
      p0MassHistSameEventResum_1 = new TH1D("p0MassHistSameEventResum_1", "Inclusive Mass Plot", 200, 0.0, 0.80);
      p0MassHistSameEventResum_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
      p0MassHistMixedEventResum_1 = new TH1D("p0MassHistMixedEventResum_1", "Inclusive Mass Plot, Mixed Events", 200, 0.0, 0.80);
      p0MassHistMixedEventResum_1->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    }
    p0MassHistSameEventResum_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    p0MassHistMixedEventResum_1->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
		
    double inclusiveNormalizationFactor = 0;
    if(sumBackground > 0.0) {
      inclusiveNormalizationFactor = sumForeground/sumBackground;
    }
    cout << "\n Foreground " << sumForeground << ",  background " << sumBackground << ", normalization " << inclusiveNormalizationFactor << endl;
    if(resumMassPlots) {
      for(unsigned int kBin=1; kBin<=100; kBin++) {
	double count =  p0MassHistMixedEventResum_1->GetBinContent(kBin);
	p0MassHistMixedEventResum_1->SetBinContent(kBin, inclusiveNormalizationFactor*count);
	double error =  p0MassHistMixedEventResum_1->GetBinError(kBin);
	p0MassHistMixedEventResum_1->SetBinError(kBin, inclusiveNormalizationFactor*error);
      }
    }
		
    c1->cd(1);
		
    p0MassHistSameEventResum_1->SetStats(0);
    p0MassHistSameEventResum_1->SetLineColor(4);
    p0MassHistSameEventResum_1->SetMinimum(0);
    double maxHistogramValue = p0MassHistSameEventResum_1->GetMaximum();
    p0MassHistSameEventResum_1->SetMaximum(1.6*maxHistogramValue);
    p0MassHistSameEventResum_1->SetAxisRange(lowMassPlotLimit, highMassPlotLimit);
    if(iOption != 5)
      p0MassHistSameEventResum_1->Draw();
		
    TF1 *peakFcn1 = 0;
    float peakFcn1Amplitude = 0;
    if(iOption == 4) {
      TF1 *fitFcn1 = 0;
			
      cout << "\n\n Fitting with two parameter background function" << endl << endl;
      fitFcn1 = new TF1("fitFcn1",fitFunctionLinear, fitStart, fitEnd, 5);
      fitFcn1->SetParameters(150, 1000., 1500., 0.50, 0.03);
      fitFcn1->SetParName(0, "constant bgrnd");
      fitFcn1->SetParName(1, "linear bgrnd");
      fitFcn1->SetParName(2, "peak Amplitude");
      fitFcn1->SetParName(3, "peak Centroid"); 
      fitFcn1->SetParName(4, "peak Sigma"); 
      fitFcn1->SetNpx(500);
      fitFcn1->SetLineWidth(2);
      fitFcn1->SetLineColor(kRed);
			
      p0MassHistSameEventResum_1->Fit("fitFcn1", "", "", fitStart, fitEnd);
			
      peakFcn1 = new TF1("peakFcn1", gaussPeak, fitStart, fitEnd, 3);
      peakFcn1Amplitude = fitFcn1->GetParameter(2);
      peakFcn1->SetParameter(0, 5.0*peakFcn1Amplitude);
      peakFcn1->SetParameter(1, fitFcn1->GetParameter(3));
      peakFcn1->SetParameter(2, fitFcn1->GetParameter(4));
			
      peakFcn1->SetLineColor(6);
      peakFcn1->Draw("same");
			
    }
		
    p0MassHistMixedEventResum_1->SetLineColor(kRed);
    p0MassHistMixedEventResum_1->SetFillColor(kYellow);
    if(iOption == 3)
      p0MassHistMixedEventResum_1->Draw("same");
		
    if(iOption != 5) {
      (c1->cd(1))->SetGridx();
      (c1->cd(1))->SetGridy();
    }
		
    TLatex *runLabel = new TLatex(0.312, 1.4*maxHistogramValue, "Min Bias 2013 pPb runs");
    runLabel->SetTextColor(kBlack);
    runLabel->SetTextSize(0.08);
    runLabel->Draw();
		
    TLatex *massPlotLabel1 = new TLatex(0.312, 1.2*maxHistogramValue, "Same-event pair mass");
    massPlotLabel1->SetTextColor(kBlue);
    massPlotLabel1->SetTextSize(0.07);
    massPlotLabel1->Draw();
		
    if(iOption == 3) {
      TLatex *massPlotLabel2 = new TLatex(0.312, 1.0*maxHistogramValue, "Mixed-event pair mass normalized (0.625 - 0.675 GeV/c^{2}");
      massPlotLabel2->SetTextColor(kRed);
      massPlotLabel2->SetTextSize(0.07);
      massPlotLabel2->Draw();
    }
		
    if(iOption == 4) {
      TLatex *massPlotLabel2 = new TLatex(0.312, 1.0*maxHistogramValue, "Fit (5 parameters): Linear Background + Gauss Peak");
      massPlotLabel2->SetTextColor(kRed);
      massPlotLabel2->SetTextSize(0.060);
      massPlotLabel2->Draw();
			
      TLatex *peakPlotLabel1 = new TLatex(0.5, 6.0*peakFcn1Amplitude, "Peak x5 (magnified)");
      peakPlotLabel1->SetTextColor(kMagenta);
      peakPlotLabel1->SetTextSize(0.055);
      peakPlotLabel1->Draw();
			
    }
		
    TH1D *pi0SameEventResumPtBin[7];
    TH1D *pi0MixedEventResumPtBin[7];
    char *histogramName = new char[200];
    char *histogramTitle = new char[200];
    float pTLowLimit[7] =  {1.6, 2.0, 2.5, 3.0, 4.0, 5.0, 6.0};
    float pTHighLimit[7] = {2.0, 2.5, 3.0, 4.0, 5.0, 6.0, 8.0};
    for(unsigned int kPt=0; kPt<7; kPt++) {
      sprintf(histogramName, "pi0SameEventResumPtBin%d", kPt);
      sprintf(histogramTitle, "Pair mass for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[kPt], pTHighLimit[kPt]);
      pi0SameEventResumPtBin[kPt] = new TH1D(histogramName, histogramTitle, 100, 0.0, 0.80);
      pi0SameEventResumPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      pi0SameEventResumPtBin[kPt]->SetYTitle("Counts per 8 MeV/c^{2} mass bin");
      pi0SameEventResumPtBin[kPt]->SetMarkerStyle(20);
      pi0SameEventResumPtBin[kPt]->SetMarkerColor(4);
      pi0SameEventResumPtBin[kPt]->SetMarkerSize(0.5);
      pi0SameEventResumPtBin[kPt]->SetStats(0);
			
      sprintf(histogramName, "pi0MixedEventResumPtBin%d", kPt);
      sprintf(histogramTitle, "Pair mass for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[kPt], pTHighLimit[kPt]);
      pi0MixedEventResumPtBin[kPt] = new TH1D(histogramName, histogramTitle, 100, 0.0, 0.80);
      pi0MixedEventResumPtBin[kPt]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
      pi0MixedEventResumPtBin[kPt]->SetYTitle("Counts per 8 MeV/c^{2} mass bin");
      pi0MixedEventResumPtBin[kPt]->SetMarkerStyle(20);
      pi0MixedEventResumPtBin[kPt]->SetMarkerColor(4);
      pi0MixedEventResumPtBin[kPt]->SetMarkerSize(0.5);
      pi0MixedEventResumPtBin[kPt]->SetStats(0);
			
    }
		
    sprintf(histogramTitle, "Pair mass for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[3], pTHighLimit[6]);
    TH1D *pi0SameEventResumAllPtBins = new TH1D("pi0SameEventResumAllPtBins", histogramTitle, 100, 0.0, 0.80);
    pi0SameEventResumAllPtBins->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    pi0SameEventResumAllPtBins->SetYTitle("Counts per 8 MeV/c^{2} mass bin");
    pi0SameEventResumAllPtBins->SetMarkerStyle(20);
    pi0SameEventResumAllPtBins->SetMarkerColor(4);
    pi0SameEventResumAllPtBins->SetMarkerSize(0.5);
    pi0SameEventResumAllPtBins->SetStats(0);
		
    TH1D *pi0MassSameEventPtBin[7];
    TH1D *pi0MassMixedEventPtBin[7];
    for(unsigned int kPt=0; kPt<7; kPt++) {
      char *histogramFullName = new char[200];
      strcpy(histogramFullName, ecalHeaderName);
      sprintf(histogramName, "NeutralPions/pi0MassSameEventPtBin%d", kPt);
      strcat(histogramFullName, histogramName);
      pi0MassSameEventPtBin[kPt] = (TH1D*)inputFile_1->Get(histogramFullName);
      if(!pi0MassSameEventPtBin[kPt]) {
	cerr << "\n Unable to find foreground " << histogramFullName << " in first input file " << rootInputFile_1 << endl;
	return;
      }
			
      strcpy(histogramFullName, ecalHeaderName);
      sprintf(histogramName, "NeutralPions/pi0MassMixedEventPtBin%d", kPt);
      strcat(histogramFullName, histogramName);
      pi0MassMixedEventPtBin[kPt] = (TH1D*)inputFile_1->Get(histogramFullName);
      if(!pi0MassMixedEventPtBin[kPt]) {
	cerr << "\n Unable to find background " << histogramFullName << " in first input file " << rootInputFile_1 << endl;
	return;
      }
			
    } // loop over pT bins to define histograms
		
    unsigned int kPanelStart = 2;
    if(iOption == 5)
      kPanelStart = 5;
    for(unsigned int kPanel=kPanelStart; kPanel<=8; kPanel++) {
      if(iOption != 5)
	c1->cd(kPanel);
      else
	c1->cd(kPanel - 4);
			
      unsigned int kPt = kPanel - 2;
			
      sumBackground = 0.0;
      sumForeground = 0.0;
      for(unsigned int kBin=0; kBin<200; kBin++) {
	double massValue = pi0MassSameEventPtBin[kPt]->GetBinCenter(kBin);
	if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	  sumForeground += pi0MassSameEventPtBin[kPt]->GetBinContent(kBin);
	  sumBackground += pi0MassMixedEventPtBin[kPt]->GetBinContent(kBin);
	} // check on mass value of the bin
				
	if(massValue >= highMassBackground)
	  break;
				
      } // sum over all mass bins
			
      double normFactorPtBin = 0;
      if(sumBackground > 0) {
	normFactorPtBin = sumForeground/sumBackground;
      }
      cout << "\n Normalization factor for pT from " << pTLowLimit[kPt];
      cout << " to " << pTHighLimit[kPt]  << " GeV/c = " << normFactorPtBin << endl;
			
      unsigned int jBin = 0;
      for(unsigned int kBin=1; kBin<=200; kBin=kBin+2) {
	jBin++;
	double countForeground = pi0MassSameEventPtBin[kPt]->GetBinContent(kBin) + pi0MassSameEventPtBin[kPt]->GetBinContent(kBin+1);
	double countBackground = pi0MassMixedEventPtBin[kPt]->GetBinContent(kBin) + pi0MassMixedEventPtBin[kPt]->GetBinContent(kBin+1);
	double errorForeground = sqrt(countForeground);
	double errorBackground = sqrt(countBackground);
	pi0SameEventResumPtBin[kPt]->SetBinContent(jBin, countForeground);
	pi0SameEventResumPtBin[kPt]->SetBinError(jBin, errorForeground);
	pi0MixedEventResumPtBin[kPt]->SetBinContent(jBin, normFactorPtBin*countBackground);
	pi0MixedEventResumPtBin[kPt]->SetBinError(jBin, normFactorPtBin*errorBackground);
	if(iOption == 5 && etaSumForPt && kPt >2) {
	  if(kPt == 3) {
	    pi0SameEventResumAllPtBins->SetBinContent(jBin, countForeground);
	  }
	  else {
	    double previousCount = pi0SameEventResumAllPtBins->GetBinContent(jBin);
	    double newCount = previousCount + countForeground;
	    pi0SameEventResumAllPtBins->SetBinContent(jBin, newCount);
	    if(kPt == 6 && newCount >= 0) {
	      pi0SameEventResumAllPtBins->SetBinError(jBin, sqrt(newCount));
	    }
	  }
					
	}
      } // loop over bins
			
      if(!etaSumForPt) {
	pi0SameEventResumPtBin[kPt]->SetAxisRange(lowMassPlotLimit, highMassPlotLimit);
	pi0SameEventResumPtBin[kPt]->SetMinimum(0);
	double maxHistogramValuePtBin = pi0SameEventResumPtBin[kPt]->GetMaximum();
	pi0SameEventResumPtBin[kPt]->SetMaximum(1.4*maxHistogramValuePtBin);
	pi0SameEventResumPtBin[kPt]->Draw();
	pi0MixedEventResumPtBin[kPt]->SetMarkerColor(2);
	pi0MixedEventResumPtBin[kPt]->SetLineColor(2);
	if(iOption == 3)
	  pi0MixedEventResumPtBin[kPt]->Draw("same");
				
	(c1->cd(kPanel))->SetGridx();
	(c1->cd(kPanel))->SetGridy();
				
	if(iOption == 5 || (kPanel > 2 && iOption == 4)) {
					
	  TF1 *fitFcn1 = 0;
					
	  cout << "\n\n Fitting with two parameter background function" << endl << endl;
	  fitFcn1 = new TF1("fitFcn1",fitFunctionLinear, 1.05*fitStart, 0.95*fitEnd, 5);
	  fitFcn1->SetParameters(133, 440, 37., 0.54, 0.060);
	  fitFcn1->SetParName(0, "constant bgrnd");
	  fitFcn1->SetParName(1, "linear bgrnd");
	  fitFcn1->SetParName(2, "peak Amplitude");
	  fitFcn1->SetParName(3, "peak Centroid"); 
	  fitFcn1->SetParName(4, "peak Sigma"); 
					
	  fitFcn1->SetNpx(500);
	  fitFcn1->SetLineWidth(2);
	  fitFcn1->SetLineColor(kRed);
					
	  pi0SameEventResumPtBin[kPt]->Fit("fitFcn1", "", "", 1.1*fitStart, 0.95*fitEnd);
					
	  peakFcn1Amplitude = fitFcn1->GetParameter(2);
					
	  peakFcn1 = new TF1("peakFcn1", gaussPeak, 1.1*fitStart, 0.95*fitEnd, 3);
	  peakFcn1->SetParameter(0, 2.0*peakFcn1Amplitude);
	  peakFcn1->SetParameter(1, fitFcn1->GetParameter(3));
	  peakFcn1->SetParameter(2, fitFcn1->GetParameter(4));
					
	  peakFcn1->SetLineColor(6);
	  if(fitFcn1->GetParameter(1) > 0.0) { // if background slope is negative, the fit is no good
	    peakFcn1->Draw("same");  // draw peak fit only if the background slope is positive
	  }
          
	  double scaledAmplitude = peakFcn1Amplitude;
	  if(2.6*scaledAmplitude < 0.3*pi0SameEventResumPtBin[kPt]->GetMaximum())
	    scaledAmplitude = (0.3/2.6)*pi0SameEventResumPtBin[kPt]->GetMaximum();
					
	  TLatex *peakPlotLabel1 = new TLatex(0.5, 2.6*scaledAmplitude, "Peak (x2 magnified)");
	  peakPlotLabel1->SetTextColor(kMagenta);
	  peakPlotLabel1->SetTextSize(0.055);
	  peakPlotLabel1->Draw();
          
	  TF1 *backgroundFcn1 = new TF1("backgroundFcn1",linearBackground, 1.1*fitStart, 0.95*fitEnd, 2);
	  backgroundFcn1->SetParameter(0, fitFcn1->GetParameter(0));
	  backgroundFcn1->SetParameter(1, fitFcn1->GetParameter(1));
					
	  double etaYield = 0.0;
	  double backgroundYield = 0.0;
	  double etaYieldError = 0.0;
	  TH1D *subtractedMass = new TH1D("subtractedMass", "Subtracted Mass", 100, 0.0, 0.80);
	  for(unsigned int kBin=1; kBin<=100; kBin++) {
	    double foregroundCount = pi0SameEventResumPtBin[kPt]->GetBinContent(kBin);
	    double massValue = pi0SameEventResumPtBin[kPt]->GetBinCenter(kBin);
	    double backgroundCount = backgroundFcn1->Eval(massValue);
	    double subtractedCount = foregroundCount - backgroundCount;
	    subtractedMass->SetBinContent(kBin, 2.0*subtractedCount);
	    if(massValue >= peakStart && massValue <= peakEnd)
	      etaYield += subtractedCount;
	    backgroundYield += backgroundCount;
	    etaYieldError += (foregroundCount + backgroundCount)/4.0;
	  } // loop over mass bins
	  if(etaYieldError > 0.0)
	    etaYieldError = sqrt(etaYieldError);
          
	  cout << "\n For kPt = " << kPt << " the eta-meson yield = " << etaYield;
	  cout << ",  with a background yield " << backgroundYield << endl;
					
	  double thisHistogramMaximumValue = pi0SameEventResumPtBin[kPt]->GetMaximum();
					
	  if(fitFcn1->GetParameter(1) > 0.0) { // if background slope is negative, the fit is no good	
	    subtractedMass->SetMarkerColor(1);
	    subtractedMass->SetLineWidth(2);
	    subtractedMass->SetAxisRange(peakStart, peakEnd);
	    subtractedMass->SetMarkerStyle(20);
	    subtractedMass->SetMarkerSize(0.20);
	    subtractedMass->Draw("same");
						
	    char *etaYieldString = new char[200];
	    sprintf(etaYieldString, "#eta-meson yield = %d #pm %d ", int(0.5*etaYield), int(etaYieldError));
						
	    TLatex *peakPlotLabel2 = new TLatex(0.31, 2.0*scaledAmplitude, etaYieldString);
	    peakPlotLabel2->SetTextColor(1);
	    peakPlotLabel2->SetTextSize(0.05);
	    peakPlotLabel2->Draw();
						
	    char *etaCentroidString = new char[200];
	    sprintf(etaCentroidString, "Centroid = %d MeV/c^{2}", int(1000*fitFcn1->GetParameter(3)));
						
	    TLatex *peakPlotLabel3 = new TLatex(0.31, 1.2*scaledAmplitude, etaCentroidString);
	    peakPlotLabel3->SetTextColor(1);
	    peakPlotLabel3->SetTextSize(0.05);
	    peakPlotLabel3->Draw();
						
						
	    char *etaBackgroundString = new char[200];
	    sprintf(etaBackgroundString, "Brgnd = %d #pm %d ", int(0.5*backgroundYield), int(sqrt(0.5*backgroundYield)));
						
	    TLatex *peakPlotLabel4 = new TLatex(0.31, 0.4*scaledAmplitude, etaBackgroundString);
	    peakPlotLabel4->SetTextColor(1);
	    peakPlotLabel4->SetTextSize(0.05);
	    peakPlotLabel4->Draw();
						
	  }
	  else {
	    cerr << "\n Bad fit with negative background slope value = " << fitFcn1->GetParameter(1) << endl;
						
	    TLatex *peakPlotLabel4 = new TLatex(0.31, 0.20*thisHistogramMaximumValue, "Fit failed");
	    peakPlotLabel4->SetTextColor(6);
	    peakPlotLabel4->SetTextSize(0.055);
	    peakPlotLabel4->Draw();
	  }
					
	  if(iOption == 5 && kPanel == 5) {
	    TLatex *dataPlotLabel1 = new TLatex(0.31, 0.91*thisHistogramMaximumValue, mainPlotLabel);
	    dataPlotLabel1->SetTextColor(4);
	    dataPlotLabel1->SetTextSize(0.055);
	    dataPlotLabel1->Draw();
						
	    TLatex *dataPlotLabel2 = new TLatex(0.31, 0.81*thisHistogramMaximumValue, "No energy re-cal, no track-match suppression");
	    dataPlotLabel2->SetTextColor(4);
	    dataPlotLabel2->SetTextSize(0.0525);
	    dataPlotLabel2->Draw();
						
	    TLatex *dataPlotLabel3 = new TLatex(0.31, 0.72*thisHistogramMaximumValue, "Fit (5 parameters): linear background + Gauss peak");
	    dataPlotLabel3->SetTextColor(2);
	    dataPlotLabel3->SetTextSize(0.05);
	    dataPlotLabel3->Draw();
						
	  } // iOption = 5 and kPanel = 5
					
	} // check on kPanel and iOption = 4
				
      } // check on etaSumForPt being false
      else {
	//
	// etaSumForPt is true
	//
	if(kPanel == 8) {
	  c1->Clear();  // reset to only one panel
	  double thisHistogramMaximumValue = 1.5*pi0SameEventResumAllPtBins->GetMaximum();
	  pi0SameEventResumAllPtBins->SetMaximum(thisHistogramMaximumValue);
	  pi0SameEventResumAllPtBins->SetMinimum(0.0);
	  pi0SameEventResumAllPtBins->SetAxisRange(lowMassPlotLimit, highMassPlotLimit);
	  pi0SameEventResumAllPtBins->Draw();
					
	  TF1 *fitFcn1 = 0;
					
	  cout << "\n\n Fitting with two parameter background function" << endl << endl;
	  fitFcn1 = new TF1("fitFcn1",fitFunctionLinear, 1.05*fitStart, 0.95*fitEnd, 5);
	  fitFcn1->SetParameters(133, 440, 37., 0.50, 0.033);
	  fitFcn1->SetParName(0, "constant bgrnd");
	  fitFcn1->SetParName(1, "linear bgrnd");
	  fitFcn1->SetParName(2, "peak Amplitude");
	  fitFcn1->SetParName(3, "peak Centroid"); 
	  fitFcn1->SetParName(4, "peak Sigma"); 
					
	  fitFcn1->SetNpx(500);
	  fitFcn1->SetLineWidth(2);
	  fitFcn1->SetLineColor(kRed);
					
	  pi0SameEventResumAllPtBins->Fit("fitFcn1", "", "", 1.1*fitStart, 0.95*fitEnd);
					
	  TLatex *dataPlotLabel1 = new TLatex(0.31, 0.91*thisHistogramMaximumValue, mainPlotLabel);
	  dataPlotLabel1->SetTextColor(4);
	  dataPlotLabel1->SetTextSize(0.040);
	  dataPlotLabel1->Draw();
					
	  TLatex *dataPlotLabel2 = new TLatex(0.31, 0.81*thisHistogramMaximumValue, "ECAL barrel limit |#eta| < 1.30");
	  dataPlotLabel2->SetTextColor(4);
	  dataPlotLabel2->SetTextSize(0.038);
	  dataPlotLabel2->Draw();
					
	  TLatex *dataPlotLabel3 = new TLatex(0.31, 0.72*thisHistogramMaximumValue, "Fit (5 parameters): linear background + Gauss peak");
	  dataPlotLabel3->SetTextColor(2);
	  dataPlotLabel3->SetTextSize(0.035);
	  dataPlotLabel3->Draw();
					
	  TF1 *peakFcn2 = new TF1("peakFcn2", gaussPeak, peakStart, peakEnd, 3);
	  double peakFcn2Amplitude = fitFcn1->GetParameter(2);
	  peakFcn2->SetParameter(0, 2.0*peakFcn2Amplitude);
	  peakFcn2->SetParameter(1, fitFcn1->GetParameter(3));
	  peakFcn2->SetParameter(2, fitFcn1->GetParameter(4));
					
	  peakFcn2->SetLineColor(6);
	  if(fitFcn1->GetParameter(1) > 0.0) { // if background slope is negative, the fit is no good
	    peakFcn2->Draw("same");  // draw peak fit only if the background slope is positive
	  }
					
	  TF1 *backgroundFcn1 = new TF1("backgroundFcn1",linearBackground, 1.1*fitStart, 0.95*fitEnd, 2);
	  backgroundFcn1->SetParameter(0, fitFcn1->GetParameter(0));
	  backgroundFcn1->SetParameter(1, fitFcn1->GetParameter(1));
					
	  double etaYield = 0.0;
	  double backgroundYield = 0.0;
	  double etaYieldError = 0.0;
	  TH1D *subtractedMass = new TH1D("subtractedMass", "Subtracted Mass", 100, 0.0, 0.80);
	  for(unsigned int kBin=1; kBin<=100; kBin++) {
	    double foregroundCount = pi0SameEventResumAllPtBins->GetBinContent(kBin);
	    double massValue = pi0SameEventResumAllPtBins->GetBinCenter(kBin);
	    double backgroundCount = backgroundFcn1->Eval(massValue);
	    double subtractedCount = foregroundCount - backgroundCount;
	    subtractedMass->SetBinContent(kBin, 2.0*subtractedCount);
	    if(massValue >= peakStart && massValue <= peakEnd)
	      etaYield += subtractedCount;
	    backgroundYield += backgroundCount;
	    etaYieldError += (foregroundCount + backgroundCount)/4.0;
	  } // loop over mass bins
	  if(etaYieldError > 0.0)
	    etaYieldError = sqrt(etaYieldError);
          
	  cout << "\n For summed Pt bins the eta-meson yield = " << etaYield << " +/- etaYieldError"; 
	  cout << ",  with a background yield " << backgroundYield << endl;
					
	  if(fitFcn1->GetParameter(1) > 0.0) { // if background slope is negative, the fit is no good
	    double scaledAmplitude = peakFcn2Amplitude;
						
	    subtractedMass->SetMarkerColor(1);
	    subtractedMass->SetLineWidth(2);
	    subtractedMass->SetAxisRange(peakStart, peakEnd);
	    subtractedMass->SetMarkerStyle(20);
	    subtractedMass->SetMarkerSize(0.20);
	    subtractedMass->Draw("same");
						
	    c1->SetGridx();
	    c1->SetGridy();
						
	    char *etaYieldString = new char[200];
	    sprintf(etaYieldString, "#eta-meson yield = %d #pm %d ", int(0.5*etaYield), int(etaYieldError));
						
	    TLatex *peakPlotLabel2 = new TLatex(0.31, 3.2*scaledAmplitude, etaYieldString);
	    peakPlotLabel2->SetTextColor(1);
	    peakPlotLabel2->SetTextSize(0.035);
	    peakPlotLabel2->Draw();
						
	    char *etaCentroidString = new char[200];
	    sprintf(etaCentroidString, "Centroid = %d MeV/c^{2}", int(1000*fitFcn1->GetParameter(3)));
						
	    TLatex *peakPlotLabel3 = new TLatex(0.31, 2.2*scaledAmplitude, etaCentroidString);
	    peakPlotLabel3->SetTextColor(1);
	    peakPlotLabel3->SetTextSize(0.035);
	    peakPlotLabel3->Draw();
	  }
	  else {
	    cerr << "\n Bad fit with negative background slope value = " << fitFcn1->GetParameter(1) << endl;
						
	    TLatex *peakPlotLabel4 = new TLatex(0.31, 0.20*thisHistogramMaximumValue, "Fit failed");
	    peakPlotLabel4->SetTextColor(6);
	    peakPlotLabel4->SetTextSize(0.035);
	    peakPlotLabel4->Draw();
	  }
					
	} // check on last kPanel
      } // etaSumForPt is true
			
    } // loop over kPanel
		
  } // iOption = 3 or iOption = 4 or iOption = 5
	
  if(iOption == -6 || iOption == 6 || iOption == 7 || iOption == -7) { // parameterized bacgkround fitting for the pair mass spectrum from the EDM output

    TGaxis::SetMaxDigits(4);
		 
    //
    // Special branch code for fitting one EDM output mass spectrum as a comparison check
    //
    
    unsigned int nBinsMass = 75;
    int nEDMEvents = 2854529;  // from tHPTracks_ in ECalFlowNtpMult100/ChargedParticles
    char *hTreePath = new char[200];
    sprintf(hTreePath, "%shTree", multText);

    if(!monikaFile) {
      TTree *hTree = (TTree*)inputFile_1->Get(hTreePath);
      nEDMEvents = hTree->GetEntries();
      cout << "\n Number of events in " << hTreePath << " = " << nEDMEvents << endl;
    }
    else {
      nBinsMass = 200;
      cout << "\n Number of events in Monika file = " << nEDMEvents << endl;
    }

    TH1D *pi0MassSubtractedPtBin[8];
    TH1D *pi0MassSubtractedCopyPtBin[8];

    float pTLowLimit[8] =  {0.7, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0};
    float pTHighLimit[8] = {1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0};

    char *histogramName = new char[200];
    char *histogramTitle = new char[200];

    sprintf(histogramName, "pi0MassSubtractedPtBin%d", kPtBinEDM);
    sprintf(histogramTitle, "#pi^{0} for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[kPtBinEDM], pTHighLimit[kPtBinEDM]);
    pi0MassSubtractedPtBin[kPtBinEDM] = new TH1D(histogramName, histogramTitle, nBinsMass, 0.0, 0.30);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetMarkerStyle(20);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetMarkerColor(kRed);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetMarkerSize(0.75);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetStats(0);

    pi0MassSubtractedPtBin[kPtBinEDM]->SetLineColor(1);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    if(monikaFile) {
      pi0MassSubtractedPtBin[kPtBinEDM]->SetYTitle("Counts per 1.5 MeV/c^{2} mass bin");
    }
    else {
      pi0MassSubtractedPtBin[kPtBinEDM]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    }
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetLabelSize(0.05);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->SetLabelSize(0.05);
    
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetTitleSize(0.06);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetTitleOffset(0.75);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetNoExponent(kTRUE);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->CenterTitle();
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->SetTitleSize(0.06);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->SetTitleOffset(0.75);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->CenterTitle();

    sprintf(histogramName, "pi0MassSubtractedCopyPtBin%d", kPtBinEDM);
    sprintf(histogramTitle, "#pi^{0} for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[kPtBinEDM], pTHighLimit[kPtBinEDM]);
    pi0MassSubtractedCopyPtBin[kPtBinEDM] = new TH1D(histogramName, histogramTitle, nBinsMass, 0.0, 0.30);
    pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetMarkerStyle(20);
    pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetMarkerColor(kRed);
    pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetMarkerSize(0.75);
    pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetStats(0);

    pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetLineColor(1);
    pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    if(monikaFile) {
      pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetYTitle("Counts per 1.5 MeV/c^{2} mass bin");
    }
    else {
      pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    }
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetXaxis())->SetLabelSize(0.05);
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetYaxis())->SetLabelSize(0.05);
    
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetXaxis())->SetTitleSize(0.06);
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetXaxis())->SetTitleOffset(0.75);
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetXaxis())->SetNoExponent(kTRUE);
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetXaxis())->CenterTitle();
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetYaxis())->SetTitleSize(0.06);
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetYaxis())->SetTitleOffset(0.75);
    (pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetYaxis())->CenterTitle();

    TH1D *backgroundPtBin = new TH1D("backgroundPtBin", "Normalized background", nBinsMass, 0.0, 0.30);
    backgroundPtBin->SetStats(0);
    backgroundPtBin->SetFillColor(kYellow);

    TH1D *pi0MassSameEventCopyPtBin[8];
    sprintf(histogramName, "pi0MassSameEventCopyPtBin%d", kPtBinEDM);
    sprintf(histogramTitle, "#pi^{0} for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[kPtBinEDM], pTHighLimit[kPtBinEDM]);
    pi0MassSameEventCopyPtBin[kPtBinEDM] = new TH1D(histogramName, histogramTitle, nBinsMass, 0.0, 0.30);
    pi0MassSameEventCopyPtBin[kPtBinEDM]->SetMarkerStyle(20);
    pi0MassSameEventCopyPtBin[kPtBinEDM]->SetMarkerColor(1);
    pi0MassSameEventCopyPtBin[kPtBinEDM]->SetMarkerSize(0.75);
    pi0MassSameEventCopyPtBin[kPtBinEDM]->SetStats(0);

    pi0MassSameEventCopyPtBin[kPtBinEDM]->SetLineColor(1);
    pi0MassSameEventCopyPtBin[kPtBinEDM]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    if(monikaFile) {
      pi0MassSameEventCopyPtBin[kPtBinEDM]->SetYTitle("Counts per 1.5 MeV/c^{2} mass bin");
    }
    else {
      pi0MassSameEventCopyPtBin[kPtBinEDM]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    }
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetXaxis())->SetLabelSize(0.05);
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetYaxis())->SetLabelSize(0.05);
    
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetXaxis())->SetTitleSize(0.06);
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetXaxis())->SetTitleOffset(0.75);
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetXaxis())->SetNoExponent(kTRUE);
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetXaxis())->CenterTitle();
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetYaxis())->SetTitleSize(0.06);
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetYaxis())->SetTitleOffset(0.75);
    (pi0MassSameEventCopyPtBin[kPtBinEDM]->GetYaxis())->CenterTitle();

    TH1D *pi0MassSameEventPtBin[8];
    TH1D *pi0MassMixedEventPtBin[8];
    sprintf(histogramName, "%spi0MassSameEventPtBin%d", multText, kPtBinEDM);
    pi0MassSameEventPtBin[kPtBinEDM] = (TH1D*)inputFile_1->Get(histogramName);
    if(!pi0MassSameEventPtBin[kPtBinEDM]) {
      cerr << "\n Unable to find foreground " << histogramName << " in first input file " << rootInputFile_1 << endl;
      return;
    }

    for(unsigned int kBin=0; kBin<=nBinsMass; kBin++) {
      double massValue = pi0MassSameEventPtBin[kPtBinEDM]->GetBinCenter(kBin);
      if(massValue > 0.03) {
	double countForeground = pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);
	double countError = pi0MassSameEventPtBin[kPtBinEDM]->GetBinError(kBin);
	pi0MassSameEventCopyPtBin[kPtBinEDM]->SetBinContent(kBin, countForeground);
	pi0MassSameEventCopyPtBin[kPtBinEDM]->SetBinError(kBin, countError);
      }
   }

   sprintf(histogramName, "%spi0MassMixedEventPtBin%d", multText, kPtBinEDM);

    pi0MassMixedEventPtBin[kPtBinEDM] = (TH1D*)inputFile_1->Get(histogramName);
    if(!pi0MassMixedEventPtBin[kPtBinEDM]) {
      cerr << "\n Unable to find background " << histogramName << " in first input file " << rootInputFile_1 << endl;
      return;
    }

    if(iOption == -6) { // foreground plot only
      if(!monikaFile) {
	pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis()->SetRange(0, 75);
      }
      pi0MassSameEventPtBin[kPtBinEDM]->Draw();
      c1->SetGrid();
      return;
    } // iOption = -6, single plot only

    float sumBackground = 0.0;
    float sumForeground = 0.0;
    float sumBackground2 = 0.0;
    float sumForeground2 = 0.0;
    for(unsigned int kBin=0; kBin<nBinsMass; kBin++) {
      double massValue = pi0MassSameEventPtBin[kPtBinEDM]->GetBinCenter(kBin);
      if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	sumForeground += pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);
	sumBackground += pi0MassMixedEventPtBin[kPtBinEDM]->GetBinContent(kBin);
      } // check on mass value of the bin

      if(massValue >= lowMassBackgroundDouble && massValue <= highMassBackgroundDouble) {
	sumForeground2 += pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);
	sumBackground2 += pi0MassMixedEventPtBin[kPtBinEDM]->GetBinContent(kBin);
      } // check on mass value of the bin
				
      if(massValue >= highMassBackground)
	break;
				
    } // sum over all mass bins
			
    double normFactorPtBin = 0;
    double normFactorPtBinDouble = 0; 
    if(sumBackground > 0) {
      normFactorPtBin = sumForeground/sumBackground;
    }

    if(sumBackground2 > 0) {
      normFactorPtBinDouble = sumForeground2/sumBackground2;
    }

    cout << "\n Normalization factor for pT from " << pTLowLimit[kPtBinEDM];
    cout << " to " << pTHighLimit[kPtBinEDM]  << " GeV/c = " << normFactorPtBin << ", with second normalization at " << normFactorPtBinDouble;
		  
    double backgroundInterpolationFactor = (normFactorPtBin - normFactorPtBinDouble)*backgroundInverseDenominatorDouble;
    float thisMassNormalizationFactor = normFactorPtBinDouble;
    float lastNormalizationFactor = normFactorPtBinDouble + (highMidMassBackgroundDouble - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;
    for(unsigned int kBin=0; kBin<=nBinsMass; kBin++) {
      double massValue = pi0MassSameEventPtBin[kPtBinEDM]->GetBinCenter(kBin);
      double countForeground = pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);
      double countBackground = pi0MassMixedEventPtBin[kPtBinEDM]->GetBinContent(kBin);

      thisMassNormalizationFactor = normFactorPtBinDouble + (massValue - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;
      if(massValue > highMidMassBackgroundDouble)
	thisMassNormalizationFactor = lastNormalizationFactor;  // constant at high pair mass

      double normalizedBackground = thisMassNormalizationFactor*countBackground;
      backgroundPtBin->SetBinContent(kBin, normalizedBackground);
      if(massValue > 0.030) {
	pi0MassSubtractedPtBin[kPtBinEDM]->SetBinContent(kBin, countForeground - normalizedBackground);
	double countError = sqrt(countForeground + countBackground*thisMassNormalizationFactor*thisMassNormalizationFactor);
	pi0MassSubtractedPtBin[kPtBinEDM]->SetBinError(kBin, countError);
      }
    }

    c1->Clear();
    c1->Divide(2,2);
    c1->cd(1);
  
    double maxHistogramValue1 = 1.1*pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(nBinsMass - 1);
    double maxHistogramValue2 = 2.5*pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(nBinsMass/2 + 1);
    if(maxHistogramValue2  > maxHistogramValue1)
      maxHistogramValue1 = maxHistogramValue2;

    pi0MassSameEventPtBin[kPtBinEDM]->SetMaximum(maxHistogramValue1);
    pi0MassSameEventCopyPtBin[kPtBinEDM]->SetMaximum(maxHistogramValue1);

    if(!monikaFile) {
      pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis()->SetRange(0, 75);
      pi0MassSameEventCopyPtBin[kPtBinEDM]->GetXaxis()->SetRange(0, 75);
    }

    pi0MassSameEventPtBin[kPtBinEDM]->SetStats(0);
    pi0MassSameEventPtBin[kPtBinEDM]->SetLineColor(1);
    pi0MassSameEventPtBin[kPtBinEDM]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    if(monikaFile) {
      pi0MassSameEventPtBin[kPtBinEDM]->SetYTitle("Counts per 1.5 MeV/c^{2} mass bin");
    }
    else {
      pi0MassSameEventPtBin[kPtBinEDM]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    }
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetLabelSize(0.05);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->SetLabelSize(0.05);
    
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetTitleSize(0.06);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetTitleOffset(0.75);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetNoExponent(kTRUE);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->CenterTitle();
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->SetTitleSize(0.06);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->SetTitleOffset(0.75);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->CenterTitle();

    pi0MassSameEventPtBin[kPtBinEDM]->Draw();
    backgroundPtBin->Draw("same");
    (c1->cd(1))->SetGrid();

    char *runLabelText1 = new char[200];
    if(simRun) {
      sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", nEDMEvents);
    }
    if(simRunEPOS) {
      sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", nEDMEvents);
    }
    if(pPbRunNormal) {
      sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", nEDMEvents);
    }
    if(iOption >=0 || iOption <4) {
      sprintf(runLabelText1, "2013 pPb runs, %d sampled HIHighPt events", nEDMEvents);
    }
    if(ppRun) {
      sprintf(runLabelText1, "2013 pp runs, %d sampled events", nEDMEvents);
    }
          
    TLatex *runLabel1 = new TLatex(0.03, 0.92*maxHistogramValue1, runLabelText1);
    runLabel1->SetTextColor(1);
    runLabel1->SetTextSize(0.060);
    runLabel1->Draw();

    char *runLabelText2 = new char[200];
    sprintf(runLabelText2, "%d <= NHPTrack < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
    TLatex *runLabel2 = new TLatex(0.03, 0.78*maxHistogramValue1, runLabelText2);
    runLabel2->SetTextColor(1);
    runLabel2->SetTextSize(0.060);
    runLabel2->Draw();

    if(useDoubleNormalization) {
      char *runLabel7Text = new char[200];
      sprintf(runLabel7Text, "Double normalization: %5.3f<m_{#gamma#gamma}<%5.3f, %5.3f<m_{#gamma#gamma}<%5.3f GeV/c^{2}", 
	      lowMassBackgroundDouble,  highMassBackgroundDouble, lowMassBackground, highMassBackground);
      TLatex *runLabel7 = new TLatex(0.03, 0.64*maxHistogramValue1,runLabel7Text);
      runLabel7->SetTextColor(1);
      runLabel7->SetTextSize(0.045);
      runLabel7->Draw();
    }

    char *plotLabelText = new char[200];
    sprintf(plotLabelText, "Plot date: %s", asciiDate);
    TLatex *plotLabel = new TLatex(0.03, 0.52*maxHistogramValue1, plotLabelText);
    plotLabel->SetTextColor(1);
    plotLabel->SetTextSize(0.045);
    plotLabel->Draw();

    c1->cd(3);

    TF1 *EDMPeak = new TF1("EDMPeak", gaussPeak, fitStart, fitEnd, 3);
    EDMPeak->SetParName(0, "Ampl");
    EDMPeak->SetParName(1, "Cent");
    EDMPeak->SetParName(2, "Sigma");
    EDMPeak->SetParameters(100., 0.135, 0.02);
    EDMPeak->SetLineColor(kBlue);
    pi0MassSubtractedPtBin[kPtBinEDM]->Fit("EDMPeak", "", "", fitStart, fitEnd);
 
    float centroid = EDMPeak->GetParameter(1);
    float width = fabs(EDMPeak->GetParameter(2));
    cout << "\n  EDFit:  Centroid = " << centroid;
    cout << ",  Width = " << width;
    double signalSum = 0.0;
    double signalError = 0.0;
    double backgroundSum = 0.0;
    double centroidMinusTwoSigma = centroid - 2.0*width;
    double centroidPlusTwoSigma = centroid + 2.0*width;
    int nDegFreeEDM = 0;
    for(unsigned int kBin=0; kBin<=nBinsMass; kBin++) {
      double massValue = pi0MassSubtractedPtBin[kPtBinEDM]->GetBinCenter(kBin);
      if(massValue >= centroidMinusTwoSigma && massValue <= centroidPlusTwoSigma) {
	signalSum += pi0MassSubtractedPtBin[kPtBinEDM]->GetBinContent(kBin);
	double error = pi0MassSubtractedPtBin[kPtBinEDM]->GetBinError(kBin);
	signalError += error*error;
	backgroundSum += backgroundPtBin->GetBinContent(kBin);
	nDegFreeEDM++;
      }
    } // loop over kBin

    cout << "\n  EDM fit:  Signal yield = " << int(signalSum) << " +/- " << int(sqrt(signalError));
    double reducedChiSquareEDM = EDMPeak->GetChisquare()/nDegFreeEDM;
    cout << "\n  Reduced chi-square EDM = " << reducedChiSquareEDM << endl << endl;

    char *edmFitText1 = new char[200];
    sprintf(edmFitText1, "D-Norm: cent = %5.1f MeV/c^{2}", 1000.*centroid);
    TLatex *edmFitLabel = new TLatex(0.16, 0.92*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum(), edmFitText1);
    edmFitLabel->SetTextColor(kBlue);
    edmFitLabel->SetTextSize(0.055);
    edmFitLabel->Draw();

    char *edmFitText2 = new char[200];
    sprintf(edmFitText2, "D-Norm: #sigma = %5.1f MeV/c^{2}", 1000.*width);
    TLatex *edmFitLabel2 = new TLatex(0.16, 0.80*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum(), edmFitText2);
    edmFitLabel2->SetTextColor(kBlue);
    edmFitLabel2->SetTextSize(0.055);
    edmFitLabel2->Draw();

    char *edmFitText3 = new char[200];
    sprintf(edmFitText3, "D-Norm: yield = %d", int(signalSum));
    TLatex *edmFitLabel3 = new TLatex(0.16, 0.68*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum(), edmFitText3);
    edmFitLabel3->SetTextColor(kBlue);
    edmFitLabel3->SetTextSize(0.055);
    edmFitLabel3->Draw();

    double foregroundSum = signalSum + backgroundSum;
    if(foregroundSum > 0 && signalError > 0.0) {
      float ratio = signalSum/foregroundSum;
      float ratioError = ratio*sqrt(signalError)/signalSum;
      char *edmFitText4 = new char[200];
      sprintf(edmFitText4, "S/(S+B) = %5.3f #pm %5.3f", ratio, ratioError);
      TLatex *edmFitLabel4 = new TLatex(0.16, 0.56*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum(), edmFitText4);
      edmFitLabel4->SetTextColor(kBlue);
      edmFitLabel4->SetTextSize(0.055);
      edmFitLabel4->Draw();
      cout << "\n  D-Norm:  S/(S+B)= " << ratio << " +/- " << ratioError;
    }

    char *edmLabelText5 = new char[200];
    sprintf(edmLabelText5, "Reduced #chi^{2} = %5.3f", reducedChiSquareEDM);
    TLatex *edmLabel5 = new TLatex(0.01, 0.56*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum(), edmLabelText5);
    edmLabel5->SetTextColor(kBlue);
    edmLabel5->SetTextSize(0.060);
    edmLabel5->Draw();

    cout << endl;

    (c1->cd(3))->SetGrid();

    TLine *pi0MassValueEDM = new TLine(0.134976, 0.0, 0.134976, 0.90*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum() );
    pi0MassValueEDM->SetLineColor(kMagenta);
    pi0MassValueEDM->SetLineWidth(2);
    pi0MassValueEDM->Draw("same");		

    TLine *baseLine = new TLine(0.0, 0.0, highMass, 0.0);
    baseLine->SetLineColor(kGreen);
    baseLine->SetLineWidth(2);
    baseLine->Draw("same");

    c1->cd(2);

    pi0MassSameEventCopyPtBin[kPtBinEDM]->Draw();

    char *fitName = new char[200];
    sprintf(fitName, "parametrizedFit");
    float paramFitStart = centroid - paramWidthScale*width;
    float paramFitEnd = centroid + paramWidthScale*width;

    int nDataPoints = 0;
    float firstValue = 0.;
    float lastValue = 0.;
    float midValue = 0.;
    int firstBin = -1;
    for(unsigned int kBin=0; kBin<nBinsMass; kBin++) {
      double massValue = pi0MassSameEventPtBin[kPtBinEDM]->GetBinCenter(kBin);
      if(massValue > paramFitStart && massValue < paramFitEnd) {
	double value = pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);

	if(firstBin == -1) {
	  firstBin = kBin;
	  firstValue = value;
	}

	if(massValue < 0.134976)
	  midValue = value;

	lastValue = value;

	nDataPoints++;
      }
    }
    int nDegFree = nDataPoints - 5;
    float slope = (lastValue - firstValue)/(paramFitEnd - paramFitStart);
    float intercept = lastValue - slope*paramFitEnd;
    float amplitude = midValue - (intercept + slope*0.134976);

    TF1 *parameterizedBackgroundFit = 0;

    if(iOption == 6) {
      parameterizedBackgroundFit = new TF1(fitName, fitFunctionLinear, paramFitStart, paramFitEnd, 5);
      parameterizedBackgroundFit->SetParName(0, "bkgConst");
      parameterizedBackgroundFit->SetParName(1, "bkgLin");
      parameterizedBackgroundFit->SetParName(2, "peakAmpl");
      parameterizedBackgroundFit->SetParName(3, "peakCent");
      parameterizedBackgroundFit->SetParName(4, "peakSigma");
      cout << "\n Intercept " << intercept;
      cout << ",  slope " << slope;
      cout << ",  amplitude " << amplitude;
      cout << ",  midValue " << midValue;
      cout << endl << endl;
      parameterizedBackgroundFit->SetParameters(intercept, slope, amplitude, centroid, width); // initialized guesses for the fit
    }

    if(iOption == 7) {
      nDegFree--;
      parameterizedBackgroundFit = new TF1(fitName, fitFunctionQuadratic, paramFitStart, paramFitEnd, 6);
      parameterizedBackgroundFit->SetParName(0, "bkgConst");
      parameterizedBackgroundFit->SetParName(1, "bkgLin");
      parameterizedBackgroundFit->SetParName(2, "bkgQuad");
      parameterizedBackgroundFit->SetParName(3, "peakAmpl");
      parameterizedBackgroundFit->SetParName(4, "peakCent");
      parameterizedBackgroundFit->SetParName(5, "peakSigma");
      parameterizedBackgroundFit->SetParameters(intercept, slope, 1.0e5, amplitude, centroid, width); // initialized guesses for the fit
    }

    if(iOption == -7) {
      nDegFree--;
      parameterizedBackgroundFit = new TF1(fitName, fitFunctionSquareRoot, paramFitStart, paramFitEnd, 6);
      parameterizedBackgroundFit->SetParName(0, "bkgLin");
      parameterizedBackgroundFit->SetParName(1, "bkgQuad");
      parameterizedBackgroundFit->SetParName(2, "bkgSqRoot");
      parameterizedBackgroundFit->SetParName(3, "peakAmpl");
      parameterizedBackgroundFit->SetParName(4, "peakCent");
      parameterizedBackgroundFit->SetParName(5, "peakSigma");
      parameterizedBackgroundFit->SetParameters(slope, 1.9e4, 1.0e4, amplitude, centroid, width); // initialized guesses for the fit
    }

    pi0MassSameEventCopyPtBin[kPtBinEDM]->Fit(fitName, "", "", paramFitStart, paramFitEnd);
    double reducedChiSquare = parameterizedBackgroundFit->GetChisquare()/nDegFree;
    cout << "\n Reduced chi-square = " << reducedChiSquare << endl << endl;

    float bkgConst = parameterizedBackgroundFit->GetParameter(0);
    float bkgLin = parameterizedBackgroundFit->GetParameter(1);

    char *fitNameBkg = new char[200];
    sprintf(fitNameBkg, "parametrizedBackground"); 
    int iOffset = 0;
    TF1 *parameterizedBackground = 0;

    if(iOption == 6) {
      parameterizedBackground = new TF1(fitNameBkg, linearBackground, paramFitStart, paramFitEnd, 2); // used for the background evaluation after the fits have been made
      parameterizedBackground->SetParameters(bkgConst, bkgLin);
      parameterizedBackground->SetParName(0, "bkgConst");
      parameterizedBackground->SetParName(1, "bkgLin");
    }

    if(iOption == 7) {
      parameterizedBackground = new TF1(fitNameBkg, quadraticBackground, paramFitStart, paramFitEnd, 3); // used for the background evaluation after the fits have been made
      float bkgQuad = parameterizedBackgroundFit->GetParameter(2);
      parameterizedBackground->SetParameters(bkgConst, bkgLin, bkgQuad);
      parameterizedBackground->SetParName(0, "bkgConst");
      parameterizedBackground->SetParName(1, "bkgLin");
      parameterizedBackground->SetParName(2, "bkgQuad");
      iOffset = 1;
    }

    if(iOption == -7) {
      parameterizedBackground = new TF1(fitNameBkg, squareRootBackground, paramFitStart, paramFitEnd, 3); // used for the background evaluation after the fits have been made
      float bkgSqRoot = parameterizedBackgroundFit->GetParameter(2);
      parameterizedBackground->SetParameters(bkgConst, bkgLin, bkgSqRoot);
      parameterizedBackground->SetParName(0, "bkgConst");
      parameterizedBackground->SetParName(1, "bkgLin");
      parameterizedBackground->SetParName(2, "bkgSqRoot");
      iOffset = 1;
    }

    parameterizedBackground->SetLineColor(kOrange);
    parameterizedBackground->Draw("same");

    float pi0PeakAmplitude = parameterizedBackgroundFit->GetParameter(2 + iOffset);
    float pi0PeakCentroid = parameterizedBackgroundFit->GetParameter(3 + iOffset);
    float pi0PeakWidth = fabs(parameterizedBackgroundFit->GetParameter(4 + iOffset)); 

    float pi0PeakStart = pi0PeakCentroid - 2.0*pi0PeakWidth;
    float pi0PeakEnd = pi0PeakCentroid + 2.0*pi0PeakWidth;
    TF1 *pi0Peak = new TF1("pi0Peak", gaussPeak, pi0PeakStart, pi0PeakEnd, 3);
    pi0Peak->SetParameters(pi0PeakAmplitude, pi0PeakCentroid, pi0PeakWidth);
    pi0Peak->SetLineColor(2);
    pi0Peak->Draw("same");
    runLabel1->Draw();
    runLabel2->Draw();

    char *fitLabelText2 = new char[200];
    if(iOption == 6) {
      sprintf(fitLabelText2, "Linear bgrnd: %5.3f < m_{#gamma#gamma} < %5.3f GeV/c^{2}", paramFitStart, paramFitEnd);
    }
    if(iOption == 7) {
      sprintf(fitLabelText2, "Quadratic bgrnd: %5.3f < m_{#gamma#gamma} < %5.3f GeV/c^{2}", paramFitStart, paramFitEnd);
    }
    if(iOption == -7) {
      sprintf(fitLabelText2, "Square root bgrnd: %5.3f < m_{#gamma#gamma} < %5.3f GeV/c^{2}", paramFitStart, paramFitEnd);
    }

    TLatex *fitLabel2 = new TLatex(0.03, 0.64*maxHistogramValue1, fitLabelText2);
    fitLabel2->SetTextColor(kBlue);
    fitLabel2->SetTextSize(0.060);
    fitLabel2->Draw();

    char *fitLabelText3 = new char[200];
    sprintf(fitLabelText3, "Reduced #chi^{2} = %5.3f", reducedChiSquare);
    TLatex *fitLabel3 = new TLatex(0.03, 0.50*maxHistogramValue1, fitLabelText3);
    fitLabel3->SetTextColor(kBlue);
    fitLabel3->SetTextSize(0.060);
    fitLabel3->Draw();

    (c1->cd(2))->SetGrid();

    c1->cd(4);

    double signalCopySum = 0.0;
    double backgroundCopySum = 0.0;
    double twoSigmaLow = pi0PeakCentroid - 2.0*pi0PeakWidth;
    double twoSigmaHigh = pi0PeakCentroid + 2.0*pi0PeakWidth;
    for(unsigned int kBin=0; kBin<nBinsMass; kBin++) {
      double massValue = pi0MassSameEventPtBin[kPtBinEDM]->GetBinCenter(kBin);
      if(massValue > paramFitStart && massValue < paramFitEnd) {
	double foreGround = pi0MassSameEventCopyPtBin[kPtBinEDM]->GetBinContent(kBin);
	double backGround = parameterizedBackground->Eval(massValue);
	double signal = foreGround - backGround;
	pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetBinContent(kBin, signal);
	double signalCopyError = sqrt(foreGround);
	pi0MassSubtractedCopyPtBin[kPtBinEDM]->SetBinError(kBin, signalCopyError);
	if(massValue > twoSigmaLow && massValue < twoSigmaHigh) {
	  backgroundCopySum += backGround;
	  signalCopySum += signal;
	}
      } // check on mass value of the bin
								
    } // sum over all mass bins

    pi0MassSubtractedCopyPtBin[kPtBinEDM]->Draw();
    pi0MassValueEDM->Draw("same");

    char *parFitText1 = new char[200];
    sprintf(parFitText1, "ParBkg: cent = %5.1f MeV/c^{2}", 1000.*pi0PeakCentroid);
    TLatex *parFitLabel = new TLatex(0.16, 0.92*pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetMaximum(), parFitText1);
    parFitLabel->SetTextColor(kBlue);
    parFitLabel->SetTextSize(0.055);
    parFitLabel->Draw();

    char *parFitText2 = new char[200];
    sprintf(parFitText2, "ParBkg: #sigma = %5.1f MeV/c^{2}", 1000.*pi0PeakWidth);
    TLatex *parFitLabel2 = new TLatex(0.16, 0.80*pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetMaximum(), parFitText2);
    parFitLabel2->SetTextColor(kBlue);
    parFitLabel2->SetTextSize(0.055);
    parFitLabel2->Draw();

    char *parFitText3 = new char[200];
    sprintf(parFitText3, "ParBkg: yield = %d", int(signalCopySum));
    TLatex *parFitLabel3 = new TLatex(0.16, 0.68*pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetMaximum(), parFitText3);
    parFitLabel3->SetTextColor(kBlue);
    parFitLabel3->SetTextSize(0.055);
    parFitLabel3->Draw();

    if(signalCopySum > 0.0 && backgroundCopySum > 0.0) {
      float ratio = signalCopySum/(signalCopySum + backgroundCopySum);
      float ratioError = ratio*sqrt(signalCopySum + backgroundCopySum)/signalCopySum;
      cout << "\n Parameterized signal: S = " << signalCopySum;
      cout << "\n Parameterized background: S/(S+B)= " << ratio<< " +/- " << ratioError;

      char *parFitText4 = new char[200];
      sprintf(parFitText4, "S/(S+B) = %5.3f #pm %5.3f", ratio, ratioError);
      TLatex *parFitLabel4 = new TLatex(0.16, 0.56*pi0MassSubtractedCopyPtBin[kPtBinEDM]->GetMaximum(), parFitText4);
      parFitLabel4->SetTextColor(kBlue);
      parFitLabel4->SetTextSize(0.055);
      parFitLabel4->Draw();

    }
    cout << endl << endl;
		
    baseLine->Draw("same");
    (c1->cd(4))->SetGrid();

    char *graphOutputFileName = new char[200];
    if(iOption == 6) {
      sprintf(graphOutputFileName, "pi0MassFitLinearCompare_PtBin%d_327Files_Multiplicity%d-%d_S25Cut-%3.1f_%d.pdf", kPtBinEDM, lowMultiplicity, highMultiplicity, clustS25Cut, date);
      c1->Print(graphOutputFileName);  // PDF file
      sprintf(graphOutputFileName, "pi0MassFitLinearCompare_PtBin%d_327Files_Multiplicity%d-%d_S25Cut-%3.1f_%d.root", kPtBinEDM, lowMultiplicity, highMultiplicity,clustS25Cut,  date);
      c1->Print(graphOutputFileName);  // ROOT file
    }
    if(iOption == 7) {
      sprintf(graphOutputFileName, "pi0MassFitQuadraticCompare_PtBin%d_327Files_Multiplicity%d-%d_S25Cut-%3.1f_%d.pdf", kPtBinEDM, lowMultiplicity, highMultiplicity, clustS25Cut, date);
      c1->Print(graphOutputFileName);  // PDF file
      sprintf(graphOutputFileName, "pi0MassFitQuadraticCompare_PtBin%d_327Files_Multiplicity%d-%d_S25Cut-%3.1f_%d.root", kPtBinEDM, lowMultiplicity, highMultiplicity, clustS25Cut,date);
      c1->Print(graphOutputFileName);  // ROOT file
    }
    if(iOption == -7) {
      sprintf(graphOutputFileName, "pi0MassFitSquareRootCompare_PtBin%d_327Files_Multiplicity%d-%d_S25Cut-%3.1f_%d.pdf", kPtBinEDM, lowMultiplicity, highMultiplicity, clustS25Cut, date);
      c1->Print(graphOutputFileName);  // PDF file
      sprintf(graphOutputFileName, "pi0MassFitSquareRootCompare_PtBin%d_327Files_Multiplicity%d-%d_S25Cut-%3.1f_%d.root", kPtBinEDM, lowMultiplicity, highMultiplicity, clustS25Cut, date);
      c1->Print(graphOutputFileName);  // ROOT file
    }	
    return;

  } // iOption = 6 or 7, fit the lowest 4 pT bins for the pi0 mass
	
  if(iOption == 8) { // fitting to derive the energy correction function according to number of crystals in the cluster
    //
    // Results from the scan of 200K events
    //
    const float ptMeasured1[7] = {0.342991,  0.443267, 0.543804, 0.643888,
				  0.743957,  0.843171, 0.954422};
		
    float correction1[7] = {0.287569, 0.280128,  0.27365, 0.267859,
			    0.262913, 0.25905, 0.245628};
		
    float correctionError1[7];
		
    int counts1[7] = {167138, 72798, 33463, 16249,
		      8034, 3713, 1582};
		
    float xError[7];
    float baseError = 0.00003;
    for(int iBin=0; iBin<7; iBin++) {
      xError[iBin] = 0.0;
      correctionError1[iBin] = sqrt(float(counts1[0]/counts1[iBin])*baseError*correction1[iBin]);
    }
		
    TGraphErrors *graphCorrection1 = new TGraphErrors(7, ptMeasured1, correction1, xError, correctionError1);
    graphCorrection1->SetTitle("Correction function for single crystal clusters");
    graphCorrection1->SetMarkerColor(4);
    graphCorrection1->SetMarkerStyle(20);
    graphCorrection1->SetMarkerSize(1.00);
    graphCorrection1->SetMinimum(0.20);
    graphCorrection1->SetMaximum(0.30);
		
    TF1 *fitCorrectionCrystal1 = new TF1("fitCorrectionCrystal1", linearBackground, 0.0, 1.0, 2);
    fitCorrectionCrystal1->SetParName(0, "Intercept");
    fitCorrectionCrystal1->SetParName(1, "Slope");
    fitCorrectionCrystal1->SetParameter(0, 0.24);
    fitCorrectionCrystal1->SetParameter(1, 0.10);
		
    c1->SetGrid();

    return;
		
  } // iOption = 8, to determine the energy correction function for single and double crystal cluster

  if(iOption == 9 || iOption == -9) { // plot EDM result, from Monika's code

    //
    // Special branch code for fitting one EDM output mass spectrum as a comparison check
    //

    char *hTreePath = new char[200];
    sprintf(hTreePath, "%shTree", multText);
    TTree *hTree = (TTree*)inputFile_1->Get(hTreePath);
    
    int nEDMEvents = hTree->GetEntries();
    cout << "\n Number of events in " << hTreePath << " = " << nEDMEvents << endl;

    TH1D *pi0MassSubtractedPtBin[8];
  
    float pTLowLimit[8] =  {0.7, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0};
    float pTHighLimit[8] = {1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0};

    char *histogramName = new char[200];
    char *histogramTitle = new char[200];

    sprintf(histogramName, "pi0MassSubtractedPtBin%d", kPtBinEDM);
    sprintf(histogramTitle, "#pi^{0} for %4.1f < p_{T} < %4.1f GeV/c", pTLowLimit[kPtBinEDM], pTHighLimit[kPtBinEDM]);
    pi0MassSubtractedPtBin[kPtBinEDM] = new TH1D(histogramName, histogramTitle, 75, 0.0, 0.30);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetMarkerStyle(20);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetMarkerColor(kRed);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetMarkerSize(0.75);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetStats(0);

    pi0MassSubtractedPtBin[kPtBinEDM]->SetLineColor(1);
    pi0MassSubtractedPtBin[kPtBinEDM]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    pi0MassSubtractedPtBin[kPtBinEDM]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetLabelSize(0.05);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->SetLabelSize(0.05);
    
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetTitleSize(0.06);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetTitleOffset(0.75);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->SetNoExponent(kTRUE);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetXaxis())->CenterTitle();
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->SetTitleSize(0.06);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->SetTitleOffset(0.75);
    (pi0MassSubtractedPtBin[kPtBinEDM]->GetYaxis())->CenterTitle();

    TH1D *backgroundPtBin = new TH1D("backgroundPtBin", "Normalized background", 75, 0.0, 0.30);
    backgroundPtBin->SetStats(0);
    backgroundPtBin->SetFillColor(kYellow);

    TH1D *pi0MassSameEventPtBin[8];
    TH1D *pi0MassMixedEventPtBin[8];
    sprintf(histogramName, "%spi0MassSameEventPtBin%d", multText, kPtBinEDM);
    pi0MassSameEventPtBin[kPtBinEDM] = (TH1D*)inputFile_1->Get(histogramName);
    if(!pi0MassSameEventPtBin[kPtBinEDM]) {
      cerr << "\n Unable to find foreground " << histogramName << " in first input file " << rootInputFile_1 << endl;
      return;
    }
    sprintf(histogramName, "%spi0MassMixedEventPtBin%d", multText, kPtBinEDM);

    pi0MassMixedEventPtBin[kPtBinEDM] = (TH1D*)inputFile_1->Get(histogramName);
    if(!pi0MassMixedEventPtBin[kPtBinEDM]) {
      cerr << "\n Unable to find background " << histogramName << " in first input file " << rootInputFile_1 << endl;
      return;
    }

    if(iOption == -9) { // foreground plot only
      pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis()->SetRange(0, 75);
      pi0MassSameEventPtBin[kPtBinEDM]->Draw();
      c1->SetGrid();
      return;
    } // iOption = -9, single plot only

    float sumBackground = 0.0;
    float sumForeground = 0.0;
    float sumBackground2 = 0.0;
    float sumForeground2 = 0.0;
    for(unsigned int kBin=0; kBin<75; kBin++) {
      double massValue = pi0MassSameEventPtBin[kPtBinEDM]->GetBinCenter(kBin);
      if(massValue >= lowMassBackground && massValue <= highMassBackground) {
	sumForeground += pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);
	sumBackground += pi0MassMixedEventPtBin[kPtBinEDM]->GetBinContent(kBin);
      } // check on mass value of the bin

      if(massValue >= lowMassBackgroundDouble && massValue <= highMassBackgroundDouble) {
	sumForeground2 += pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);
	sumBackground2 += pi0MassMixedEventPtBin[kPtBinEDM]->GetBinContent(kBin);
      } // check on mass value of the bin
				
      if(massValue >= highMassBackground)
	break;
				
    } // sum over all mass bins
			
    double normFactorPtBin = 0;
    double normFactorPtBinDouble = 0; 
    if(sumBackground > 0) {
      normFactorPtBin = sumForeground/sumBackground;
    }

    if(sumBackground2 > 0) {
      normFactorPtBinDouble = sumForeground2/sumBackground2;
    }

    cout << "\n Normalization factor for pT from " << pTLowLimit[kPtBinEDM];
    cout << " to " << pTHighLimit[kPtBinEDM]  << " GeV/c = " << normFactorPtBin << ", with second normalization at " << normFactorPtBinDouble;
		  
    double backgroundInterpolationFactor = (normFactorPtBin - normFactorPtBinDouble)*backgroundInverseDenominatorDouble;
    float thisMassNormalizationFactor = normFactorPtBinDouble;
    float lastNormalizationFactor = normFactorPtBinDouble + (highMidMassBackgroundDouble - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;
    for(unsigned int kBin=0; kBin<=75; kBin++) {
      double massValue = pi0MassSameEventPtBin[kPtBinEDM]->GetBinCenter(kBin);
      double countForeground = pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(kBin);
      double countBackground = pi0MassMixedEventPtBin[kPtBinEDM]->GetBinContent(kBin);

      thisMassNormalizationFactor = normFactorPtBinDouble + (massValue - lowMidMassBackgroundDouble)*backgroundInterpolationFactor;
      if(massValue > highMidMassBackgroundDouble)
	thisMassNormalizationFactor = lastNormalizationFactor;  // constant at high pair mass

      double normalizedBackground = thisMassNormalizationFactor*countBackground;
      backgroundPtBin->SetBinContent(kBin, normalizedBackground);
      if(massValue > 0.030) {
	pi0MassSubtractedPtBin[kPtBinEDM]->SetBinContent(kBin, countForeground - normalizedBackground);
	double countError = sqrt(countForeground + countBackground*thisMassNormalizationFactor*thisMassNormalizationFactor);
	pi0MassSubtractedPtBin[kPtBinEDM]->SetBinError(kBin, countError);
      }
    }

    c1->Clear();
    c1->Divide(1,2);
    c1->cd(1);
  
    double maxHistogramValue1 = 1.1*pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(74);
    double maxHistogramValue2 = 1.7*pi0MassSameEventPtBin[kPtBinEDM]->GetBinContent(38);
    if(maxHistogramValue2  > maxHistogramValue1)
      maxHistogramValue1 = maxHistogramValue2;

    pi0MassSameEventPtBin[kPtBinEDM]->SetMaximum(maxHistogramValue1);

    pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis()->SetRange(0, 75);

    pi0MassSameEventPtBin[kPtBinEDM]->SetStats(0);
    pi0MassSameEventPtBin[kPtBinEDM]->SetLineColor(1);
    pi0MassSameEventPtBin[kPtBinEDM]->SetXTitle("#gamma#gamma Invariant mass (GeV/c^{2})");
    pi0MassSameEventPtBin[kPtBinEDM]->SetYTitle("Counts per 4 MeV/c^{2} mass bin");
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetLabelSize(0.05);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->SetLabelSize(0.05);
    
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetTitleSize(0.06);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetTitleOffset(0.75);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->SetNoExponent(kTRUE);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetXaxis())->CenterTitle();
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->SetTitleSize(0.06);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->SetTitleOffset(0.75);
    (pi0MassSameEventPtBin[kPtBinEDM]->GetYaxis())->CenterTitle();

    pi0MassSameEventPtBin[kPtBinEDM]->Draw();
    backgroundPtBin->Draw("same");
    (c1->cd(1))->SetGrid();

    char *runLabelText1 = new char[200];
    if(simRun) {
      sprintf(runLabelText1, "%d Sampled HIJING pPb Min Bias Events", nEDMEvents);
    }
    if(simRunEPOS) {
      sprintf(runLabelText1, "%d Sampled EPOS pPb Min Bias Events", nEDMEvents);
    }
    if(pPbRunNormal) {
      sprintf(runLabelText1, "First Min Bias 2013 pPb runs, %d sampled events", nEDMEvents);
    }
    if(iOption >=0 || iOption <4) {
      sprintf(runLabelText1, "2013 pPb runs, %d sampled HIHighPt events", nEDMEvents);
    }
    if(ppRun) {
      sprintf(runLabelText1, "2013 pp runs, %d sampled events", nEDMEvents);
    }
          
    TLatex *runLabel1 = new TLatex(0.03, 0.92*maxHistogramValue1, runLabelText1);
    runLabel1->SetTextColor(1);
    runLabel1->SetTextSize(0.060);
    runLabel1->Draw();

    char *runLabelText2 = new char[200];
    sprintf(runLabelText2, "%d <= NHITrack < %d and  %4.1f < Z < %3.1f cm", lowMultiplicity, highMultiplicity, zVertexLowLimit, zVertexHighLimit);
    TLatex *runLabel2 = new TLatex(0.03, 0.78*maxHistogramValue1, runLabelText2);
    runLabel2->SetTextColor(1);
    runLabel2->SetTextSize(0.060);
    runLabel2->Draw();

    c1->cd(2);

    TF1 *EDMPeak = new TF1("EDMPeak", gaussPeak, fitStart, fitEnd, 3);
    EDMPeak->SetParName(0, "Ampl");
    EDMPeak->SetParName(1, "Cent");
    EDMPeak->SetParName(2, "Sigma");
    EDMPeak->SetParameters(100., 0.135, 0.02);
    EDMPeak->SetLineColor(kBlue);
    pi0MassSubtractedPtBin[kPtBinEDM]->Fit("EDMPeak", "", "", fitStart, fitEnd);

    float centroid = EDMPeak->GetParameter(1);
    float width = fabs(EDMPeak->GetParameter(2));
    cout << "\n  EDFit:  Centroid = " << centroid;
    cout << ",  Width = " << width;
    double signalSum = 0.0;
    double signalError = 0.0;
    double backgroundSum = 0.0;
    double centroidMinusTwoSigma = centroid - 2.0*width;
    double centroidPlusTwoSigma = centroid + 2.0*width;
    for(unsigned int kBin=0; kBin<=75; kBin++) {
      double massValue = pi0MassSubtractedPtBin[kPtBinEDM]->GetBinCenter(kBin);
      if(massValue >= centroidMinusTwoSigma && massValue <= centroidPlusTwoSigma) {
	signalSum += pi0MassSubtractedPtBin[kPtBinEDM]->GetBinContent(kBin);
	double error = pi0MassSubtractedPtBin[kPtBinEDM]->GetBinError(kBin);
	signalError += error*error;
	backgroundSum += backgroundPtBin->GetBinContent(kBin);
      }
    } // loop over kBin

    cout << "\n  EDM fit:  Signal yield = " << int(signalSum) << " +/- " << int(sqrt(signalError));

    char *edmFitText = new char[200];
    sprintf(edmFitText, "EDM fit: cent = %5.1f, #sigma = %5.1f, yield = %d", 1000.*centroid, 1000.*width, int(signalSum));
    TLatex *edmFitLabel = new TLatex(0.155, 0.80*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum(), edmFitText);
    edmFitLabel->SetTextColor(kBlue);
    edmFitLabel->SetTextSize(0.055);
    edmFitLabel->Draw();

    double foregroundSum = signalSum + backgroundSum;
    if(foregroundSum > 0 && signalError > 0.0) {
      float ratio = signalSum/foregroundSum;
      float ratioError = ratio*sqrt(signalError)/signalSum;
      char *edmFitText2 = new char[200];
      sprintf(edmFitText2, "S/(S+B) = %5.3f #pm %5.3f", ratio, ratioError);
      TLatex *edmFitLabel2 = new TLatex(0.155, 0.60*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum(), edmFitText2);
      edmFitLabel2->SetTextColor(kBlue);
      edmFitLabel2->SetTextSize(0.055);
      edmFitLabel2->Draw();
      cout << "\n  EDM fit:  S/(S+B)= " << ratio << " +/- " << ratioError;
    }
    cout << endl;

    (c1->cd(2))->SetGrid();

    TLine *pi0MassValueEDM = new TLine(0.134976, 0.0, 0.134976, 0.90*pi0MassSubtractedPtBin[kPtBinEDM]->GetMaximum() );
    pi0MassValueEDM->SetLineColor(kMagenta);
    pi0MassValueEDM->SetLineWidth(2);
    pi0MassValueEDM->Draw("same");		

    TLine *baseLine = new TLine(0.0, 0.0, highMass, 0.0);
    baseLine->SetLineColor(kGreen);
    baseLine->SetLineWidth(2);
    baseLine->Draw("same");

    char *graphOutputFileName = new char[200];
    sprintf(graphOutputFileName, "pi0MassHighPt_PtBin%d_327Files_Multiplicity%d-%d_%d.pdf", kPtBinEDM, lowMultiplicity, highMultiplicity, date);
    c1->Print(graphOutputFileName);  // PDF file
    sprintf(graphOutputFileName, "pi0MassHighPt_PtBin%d_327Files_Multiplicity%d-%d_%d.root", kPtBinEDM, lowMultiplicity, highMultiplicity, date);
    c1->Print(graphOutputFileName);  // ROOT file

    return;
		    
  } // iOption = 9	

}
